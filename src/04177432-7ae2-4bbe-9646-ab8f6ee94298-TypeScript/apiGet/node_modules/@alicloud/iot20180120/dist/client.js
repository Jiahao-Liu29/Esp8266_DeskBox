"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const endpoint_util_1 = __importDefault(require("@alicloud/endpoint-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddDataForApiSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiId: 'ApiId',
            content: 'Content',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            apiId: 'string',
            content: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.AddDataForApiSourceRequest = AddDataForApiSourceRequest;
class AddDataForApiSourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'number',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.AddDataForApiSourceResponseBody = AddDataForApiSourceResponseBody;
class AddDataForApiSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddDataForApiSourceResponseBody,
        };
    }
}
exports.AddDataForApiSourceResponse = AddDataForApiSourceResponse;
class AddShareTaskDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotIdList: 'IotIdList',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            shareTaskId: 'ShareTaskId',
        };
    }
    static types() {
        return {
            iotIdList: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            productKey: 'string',
            shareTaskId: 'string',
        };
    }
}
exports.AddShareTaskDeviceRequest = AddShareTaskDeviceRequest;
class AddShareTaskDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: AddShareTaskDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.AddShareTaskDeviceResponseBody = AddShareTaskDeviceResponseBody;
class AddShareTaskDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddShareTaskDeviceResponseBody,
        };
    }
}
exports.AddShareTaskDeviceResponse = AddShareTaskDeviceResponse;
class AsyncRRpcRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            extInfo: 'ExtInfo',
            iotInstanceId: 'IotInstanceId',
            messageContent: 'MessageContent',
            productKey: 'ProductKey',
            topicFullName: 'TopicFullName',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            extInfo: 'string',
            iotInstanceId: 'string',
            messageContent: 'string',
            productKey: 'string',
            topicFullName: 'string',
        };
    }
}
exports.AsyncRRpcRequest = AsyncRRpcRequest;
class AsyncRRpcResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            messageId: 'MessageId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            messageId: 'number',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.AsyncRRpcResponseBody = AsyncRRpcResponseBody;
class AsyncRRpcResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AsyncRRpcResponseBody,
        };
    }
}
exports.AsyncRRpcResponse = AsyncRRpcResponse;
class AttachDestinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destinationId: 'DestinationId',
            iotInstanceId: 'IotInstanceId',
            isFailover: 'IsFailover',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            destinationId: 'number',
            iotInstanceId: 'string',
            isFailover: 'boolean',
            parserId: 'number',
        };
    }
}
exports.AttachDestinationRequest = AttachDestinationRequest;
class AttachDestinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.AttachDestinationResponseBody = AttachDestinationResponseBody;
class AttachDestinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AttachDestinationResponseBody,
        };
    }
}
exports.AttachDestinationResponse = AttachDestinationResponse;
class AttachParserDataSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            iotInstanceId: 'IotInstanceId',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            iotInstanceId: 'string',
            parserId: 'number',
        };
    }
}
exports.AttachParserDataSourceRequest = AttachParserDataSourceRequest;
class AttachParserDataSourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.AttachParserDataSourceResponseBody = AttachParserDataSourceResponseBody;
class AttachParserDataSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AttachParserDataSourceResponseBody,
        };
    }
}
exports.AttachParserDataSourceResponse = AttachParserDataSourceResponse;
class BatchAddDataForApiSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiId: 'ApiId',
            contentList: 'ContentList',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            apiId: 'string',
            contentList: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchAddDataForApiSourceRequest = BatchAddDataForApiSourceRequest;
class BatchAddDataForApiSourceShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiId: 'ApiId',
            contentListShrink: 'ContentList',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            apiId: 'string',
            contentListShrink: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.BatchAddDataForApiSourceShrinkRequest = BatchAddDataForApiSourceShrinkRequest;
class BatchAddDataForApiSourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchAddDataForApiSourceResponseBody = BatchAddDataForApiSourceResponseBody;
class BatchAddDataForApiSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchAddDataForApiSourceResponseBody,
        };
    }
}
exports.BatchAddDataForApiSourceResponse = BatchAddDataForApiSourceResponse;
class BatchAddDeviceGroupRelationsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            device: 'Device',
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            device: { 'type': 'array', 'itemType': BatchAddDeviceGroupRelationsRequestDevice },
            groupId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.BatchAddDeviceGroupRelationsRequest = BatchAddDeviceGroupRelationsRequest;
class BatchAddDeviceGroupRelationsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alreadyRelatedGroupDeviceCount: 'AlreadyRelatedGroupDeviceCount',
            code: 'Code',
            errorMessage: 'ErrorMessage',
            exceedTenGroupDeviceCount: 'ExceedTenGroupDeviceCount',
            requestId: 'RequestId',
            success: 'Success',
            successAddedDeviceCount: 'SuccessAddedDeviceCount',
            validDeviceCount: 'ValidDeviceCount',
        };
    }
    static types() {
        return {
            alreadyRelatedGroupDeviceCount: 'number',
            code: 'string',
            errorMessage: 'string',
            exceedTenGroupDeviceCount: 'number',
            requestId: 'string',
            success: 'boolean',
            successAddedDeviceCount: 'number',
            validDeviceCount: 'number',
        };
    }
}
exports.BatchAddDeviceGroupRelationsResponseBody = BatchAddDeviceGroupRelationsResponseBody;
class BatchAddDeviceGroupRelationsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchAddDeviceGroupRelationsResponseBody,
        };
    }
}
exports.BatchAddDeviceGroupRelationsResponse = BatchAddDeviceGroupRelationsResponse;
class BatchAddThingTopoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gwDeviceName: 'GwDeviceName',
            gwProductKey: 'GwProductKey',
            iotInstanceId: 'IotInstanceId',
            topoAddItem: 'TopoAddItem',
        };
    }
    static types() {
        return {
            gwDeviceName: 'string',
            gwProductKey: 'string',
            iotInstanceId: 'string',
            topoAddItem: { 'type': 'array', 'itemType': BatchAddThingTopoRequestTopoAddItem },
        };
    }
}
exports.BatchAddThingTopoRequest = BatchAddThingTopoRequest;
class BatchAddThingTopoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchAddThingTopoResponseBody = BatchAddThingTopoResponseBody;
class BatchAddThingTopoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchAddThingTopoResponseBody,
        };
    }
}
exports.BatchAddThingTopoResponse = BatchAddThingTopoResponse;
class BatchBindDeviceToEdgeInstanceWithDriverRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotIds: 'IotIds',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            instanceId: 'string',
            iotIds: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchBindDeviceToEdgeInstanceWithDriverRequest = BatchBindDeviceToEdgeInstanceWithDriverRequest;
class BatchBindDeviceToEdgeInstanceWithDriverResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchBindDeviceToEdgeInstanceWithDriverResponseBody = BatchBindDeviceToEdgeInstanceWithDriverResponseBody;
class BatchBindDeviceToEdgeInstanceWithDriverResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchBindDeviceToEdgeInstanceWithDriverResponseBody,
        };
    }
}
exports.BatchBindDeviceToEdgeInstanceWithDriverResponse = BatchBindDeviceToEdgeInstanceWithDriverResponse;
class BatchBindDevicesIntoProjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            devices: 'Devices',
            iotInstanceId: 'IotInstanceId',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            devices: { 'type': 'array', 'itemType': BatchBindDevicesIntoProjectRequestDevices },
            iotInstanceId: 'string',
            projectId: 'string',
        };
    }
}
exports.BatchBindDevicesIntoProjectRequest = BatchBindDevicesIntoProjectRequest;
class BatchBindDevicesIntoProjectResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchBindDevicesIntoProjectResponseBody = BatchBindDevicesIntoProjectResponseBody;
class BatchBindDevicesIntoProjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchBindDevicesIntoProjectResponseBody,
        };
    }
}
exports.BatchBindDevicesIntoProjectResponse = BatchBindDevicesIntoProjectResponse;
class BatchBindProductsIntoProjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKeys: 'ProductKeys',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKeys: { 'type': 'array', 'itemType': 'string' },
            projectId: 'string',
        };
    }
}
exports.BatchBindProductsIntoProjectRequest = BatchBindProductsIntoProjectRequest;
class BatchBindProductsIntoProjectResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchBindProductsIntoProjectResponseBody = BatchBindProductsIntoProjectResponseBody;
class BatchBindProductsIntoProjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchBindProductsIntoProjectResponseBody,
        };
    }
}
exports.BatchBindProductsIntoProjectResponse = BatchBindProductsIntoProjectResponse;
class BatchCheckDeviceNamesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceNameList: 'DeviceNameList',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: { 'type': 'array', 'itemType': 'string' },
            deviceNameList: { 'type': 'array', 'itemType': BatchCheckDeviceNamesRequestDeviceNameList },
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchCheckDeviceNamesRequest = BatchCheckDeviceNamesRequest;
class BatchCheckDeviceNamesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BatchCheckDeviceNamesResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchCheckDeviceNamesResponseBody = BatchCheckDeviceNamesResponseBody;
class BatchCheckDeviceNamesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchCheckDeviceNamesResponseBody,
        };
    }
}
exports.BatchCheckDeviceNamesResponse = BatchCheckDeviceNamesResponse;
class BatchCheckImportDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceList: 'DeviceList',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceList: { 'type': 'array', 'itemType': BatchCheckImportDeviceRequestDeviceList },
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchCheckImportDeviceRequest = BatchCheckImportDeviceRequest;
class BatchCheckImportDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BatchCheckImportDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchCheckImportDeviceResponseBody = BatchCheckImportDeviceResponseBody;
class BatchCheckImportDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchCheckImportDeviceResponseBody,
        };
    }
}
exports.BatchCheckImportDeviceResponse = BatchCheckImportDeviceResponse;
class BatchCheckVehicleDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceList: 'DeviceList',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceList: { 'type': 'array', 'itemType': BatchCheckVehicleDeviceRequestDeviceList },
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchCheckVehicleDeviceRequest = BatchCheckVehicleDeviceRequest;
class BatchCheckVehicleDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BatchCheckVehicleDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchCheckVehicleDeviceResponseBody = BatchCheckVehicleDeviceResponseBody;
class BatchCheckVehicleDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchCheckVehicleDeviceResponseBody,
        };
    }
}
exports.BatchCheckVehicleDeviceResponse = BatchCheckVehicleDeviceResponse;
class BatchClearEdgeInstanceDeviceConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotIds: 'IotIds',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotIds: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchClearEdgeInstanceDeviceConfigRequest = BatchClearEdgeInstanceDeviceConfigRequest;
class BatchClearEdgeInstanceDeviceConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchClearEdgeInstanceDeviceConfigResponseBody = BatchClearEdgeInstanceDeviceConfigResponseBody;
class BatchClearEdgeInstanceDeviceConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchClearEdgeInstanceDeviceConfigResponseBody,
        };
    }
}
exports.BatchClearEdgeInstanceDeviceConfigResponse = BatchClearEdgeInstanceDeviceConfigResponse;
class BatchCreateSoundCodeLabelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            scheduleCode: 'ScheduleCode',
            total: 'Total',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            scheduleCode: 'string',
            total: 'number',
        };
    }
}
exports.BatchCreateSoundCodeLabelRequest = BatchCreateSoundCodeLabelRequest;
class BatchCreateSoundCodeLabelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchCreateSoundCodeLabelResponseBody = BatchCreateSoundCodeLabelResponseBody;
class BatchCreateSoundCodeLabelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchCreateSoundCodeLabelResponseBody,
        };
    }
}
exports.BatchCreateSoundCodeLabelResponse = BatchCreateSoundCodeLabelResponse;
class BatchCreateSoundCodeLabelWithLabelsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            labels: 'Labels',
            scheduleCode: 'ScheduleCode',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            labels: { 'type': 'array', 'itemType': 'string' },
            scheduleCode: 'string',
        };
    }
}
exports.BatchCreateSoundCodeLabelWithLabelsRequest = BatchCreateSoundCodeLabelWithLabelsRequest;
class BatchCreateSoundCodeLabelWithLabelsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchCreateSoundCodeLabelWithLabelsResponseBody = BatchCreateSoundCodeLabelWithLabelsResponseBody;
class BatchCreateSoundCodeLabelWithLabelsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchCreateSoundCodeLabelWithLabelsResponseBody,
        };
    }
}
exports.BatchCreateSoundCodeLabelWithLabelsResponse = BatchCreateSoundCodeLabelWithLabelsResponse;
class BatchDeleteDeviceGroupRelationsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            device: 'Device',
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            device: { 'type': 'array', 'itemType': BatchDeleteDeviceGroupRelationsRequestDevice },
            groupId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.BatchDeleteDeviceGroupRelationsRequest = BatchDeleteDeviceGroupRelationsRequest;
class BatchDeleteDeviceGroupRelationsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alreadyRelatedGroupDeviceCount: 'AlreadyRelatedGroupDeviceCount',
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
            successDeviceCount: 'SuccessDeviceCount',
            validDeviceCount: 'ValidDeviceCount',
        };
    }
    static types() {
        return {
            alreadyRelatedGroupDeviceCount: 'number',
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
            successDeviceCount: 'number',
            validDeviceCount: 'number',
        };
    }
}
exports.BatchDeleteDeviceGroupRelationsResponseBody = BatchDeleteDeviceGroupRelationsResponseBody;
class BatchDeleteDeviceGroupRelationsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchDeleteDeviceGroupRelationsResponseBody,
        };
    }
}
exports.BatchDeleteDeviceGroupRelationsResponse = BatchDeleteDeviceGroupRelationsResponse;
class BatchDeleteEdgeInstanceChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelIds: 'ChannelIds',
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            channelIds: { 'type': 'array', 'itemType': 'string' },
            driverId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.BatchDeleteEdgeInstanceChannelRequest = BatchDeleteEdgeInstanceChannelRequest;
class BatchDeleteEdgeInstanceChannelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchDeleteEdgeInstanceChannelResponseBody = BatchDeleteEdgeInstanceChannelResponseBody;
class BatchDeleteEdgeInstanceChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchDeleteEdgeInstanceChannelResponseBody,
        };
    }
}
exports.BatchDeleteEdgeInstanceChannelResponse = BatchDeleteEdgeInstanceChannelResponse;
class BatchGetDeviceBindStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotIds: 'IotIds',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            iotIds: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchGetDeviceBindStatusRequest = BatchGetDeviceBindStatusRequest;
class BatchGetDeviceBindStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: { 'type': 'array', 'itemType': BatchGetDeviceBindStatusResponseBodyData },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchGetDeviceBindStatusResponseBody = BatchGetDeviceBindStatusResponseBody;
class BatchGetDeviceBindStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetDeviceBindStatusResponseBody,
        };
    }
}
exports.BatchGetDeviceBindStatusResponse = BatchGetDeviceBindStatusResponse;
class BatchGetDeviceStateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: { 'type': 'array', 'itemType': 'string' },
            iotId: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchGetDeviceStateRequest = BatchGetDeviceStateRequest;
class BatchGetDeviceStateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            deviceStatusList: 'DeviceStatusList',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            deviceStatusList: BatchGetDeviceStateResponseBodyDeviceStatusList,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchGetDeviceStateResponseBody = BatchGetDeviceStateResponseBody;
class BatchGetDeviceStateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetDeviceStateResponseBody,
        };
    }
}
exports.BatchGetDeviceStateResponse = BatchGetDeviceStateResponse;
class BatchGetEdgeDriverRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverIds: 'DriverIds',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            driverIds: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchGetEdgeDriverRequest = BatchGetEdgeDriverRequest;
class BatchGetEdgeDriverResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            driverList: 'DriverList',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            driverList: { 'type': 'array', 'itemType': BatchGetEdgeDriverResponseBodyDriverList },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchGetEdgeDriverResponseBody = BatchGetEdgeDriverResponseBody;
class BatchGetEdgeDriverResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetEdgeDriverResponseBody,
        };
    }
}
exports.BatchGetEdgeDriverResponse = BatchGetEdgeDriverResponse;
class BatchGetEdgeInstanceChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelIds: 'ChannelIds',
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            channelIds: { 'type': 'array', 'itemType': 'string' },
            driverId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceChannelRequest = BatchGetEdgeInstanceChannelRequest;
class BatchGetEdgeInstanceChannelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BatchGetEdgeInstanceChannelResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchGetEdgeInstanceChannelResponseBody = BatchGetEdgeInstanceChannelResponseBody;
class BatchGetEdgeInstanceChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetEdgeInstanceChannelResponseBody,
        };
    }
}
exports.BatchGetEdgeInstanceChannelResponse = BatchGetEdgeInstanceChannelResponse;
class BatchGetEdgeInstanceDeviceChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotIds: 'IotIds',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            instanceId: 'string',
            iotIds: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceDeviceChannelRequest = BatchGetEdgeInstanceDeviceChannelRequest;
class BatchGetEdgeInstanceDeviceChannelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            deviceChannelList: 'DeviceChannelList',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            deviceChannelList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchGetEdgeInstanceDeviceChannelResponseBody = BatchGetEdgeInstanceDeviceChannelResponseBody;
class BatchGetEdgeInstanceDeviceChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetEdgeInstanceDeviceChannelResponseBody,
        };
    }
}
exports.BatchGetEdgeInstanceDeviceChannelResponse = BatchGetEdgeInstanceDeviceChannelResponse;
class BatchGetEdgeInstanceDeviceConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotIds: 'IotIds',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotIds: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceDeviceConfigRequest = BatchGetEdgeInstanceDeviceConfigRequest;
class BatchGetEdgeInstanceDeviceConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            deviceConfigList: 'DeviceConfigList',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            deviceConfigList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchGetEdgeInstanceDeviceConfigResponseBody = BatchGetEdgeInstanceDeviceConfigResponseBody;
class BatchGetEdgeInstanceDeviceConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetEdgeInstanceDeviceConfigResponseBody,
        };
    }
}
exports.BatchGetEdgeInstanceDeviceConfigResponse = BatchGetEdgeInstanceDeviceConfigResponse;
class BatchGetEdgeInstanceDeviceDriverRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotIds: 'IotIds',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotIds: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceDeviceDriverRequest = BatchGetEdgeInstanceDeviceDriverRequest;
class BatchGetEdgeInstanceDeviceDriverResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            deviceDriverList: 'DeviceDriverList',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            deviceDriverList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchGetEdgeInstanceDeviceDriverResponseBody = BatchGetEdgeInstanceDeviceDriverResponseBody;
class BatchGetEdgeInstanceDeviceDriverResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetEdgeInstanceDeviceDriverResponseBody,
        };
    }
}
exports.BatchGetEdgeInstanceDeviceDriverResponse = BatchGetEdgeInstanceDeviceDriverResponse;
class BatchGetEdgeInstanceDriverConfigsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverIds: 'DriverIds',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            driverIds: { 'type': 'array', 'itemType': 'string' },
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceDriverConfigsRequest = BatchGetEdgeInstanceDriverConfigsRequest;
class BatchGetEdgeInstanceDriverConfigsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            driverConfigList: 'DriverConfigList',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            driverConfigList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchGetEdgeInstanceDriverConfigsResponseBody = BatchGetEdgeInstanceDriverConfigsResponseBody;
class BatchGetEdgeInstanceDriverConfigsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetEdgeInstanceDriverConfigsResponseBody,
        };
    }
}
exports.BatchGetEdgeInstanceDriverConfigsResponse = BatchGetEdgeInstanceDriverConfigsResponse;
class BatchGrayMigrationDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceNames: 'DeviceNames',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceNames: { 'type': 'array', 'itemType': 'string' },
            productKey: 'string',
        };
    }
}
exports.BatchGrayMigrationDeviceRequest = BatchGrayMigrationDeviceRequest;
class BatchGrayMigrationDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BatchGrayMigrationDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchGrayMigrationDeviceResponseBody = BatchGrayMigrationDeviceResponseBody;
class BatchGrayMigrationDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGrayMigrationDeviceResponseBody,
        };
    }
}
exports.BatchGrayMigrationDeviceResponse = BatchGrayMigrationDeviceResponse;
class BatchImportDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceList: 'DeviceList',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceList: { 'type': 'array', 'itemType': BatchImportDeviceRequestDeviceList },
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchImportDeviceRequest = BatchImportDeviceRequest;
class BatchImportDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BatchImportDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchImportDeviceResponseBody = BatchImportDeviceResponseBody;
class BatchImportDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchImportDeviceResponseBody,
        };
    }
}
exports.BatchImportDeviceResponse = BatchImportDeviceResponse;
class BatchImportVehicleDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceList: 'DeviceList',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceList: { 'type': 'array', 'itemType': BatchImportVehicleDeviceRequestDeviceList },
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchImportVehicleDeviceRequest = BatchImportVehicleDeviceRequest;
class BatchImportVehicleDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BatchImportVehicleDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchImportVehicleDeviceResponseBody = BatchImportVehicleDeviceResponseBody;
class BatchImportVehicleDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchImportVehicleDeviceResponseBody,
        };
    }
}
exports.BatchImportVehicleDeviceResponse = BatchImportVehicleDeviceResponse;
class BatchPubRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            messageContent: 'MessageContent',
            productKey: 'ProductKey',
            qos: 'Qos',
            topicShortName: 'TopicShortName',
        };
    }
    static types() {
        return {
            deviceName: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            messageContent: 'string',
            productKey: 'string',
            qos: 'number',
            topicShortName: 'string',
        };
    }
}
exports.BatchPubRequest = BatchPubRequest;
class BatchPubResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchPubResponseBody = BatchPubResponseBody;
class BatchPubResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchPubResponseBody,
        };
    }
}
exports.BatchPubResponse = BatchPubResponse;
class BatchQueryDeviceDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchQueryDeviceDetailRequest = BatchQueryDeviceDetailRequest;
class BatchQueryDeviceDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BatchQueryDeviceDetailResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchQueryDeviceDetailResponseBody = BatchQueryDeviceDetailResponseBody;
class BatchQueryDeviceDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchQueryDeviceDetailResponseBody,
        };
    }
}
exports.BatchQueryDeviceDetailResponse = BatchQueryDeviceDetailResponse;
class BatchRegisterDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            count: 'Count',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            count: 'number',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchRegisterDeviceRequest = BatchRegisterDeviceRequest;
class BatchRegisterDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BatchRegisterDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchRegisterDeviceResponseBody = BatchRegisterDeviceResponseBody;
class BatchRegisterDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchRegisterDeviceResponseBody,
        };
    }
}
exports.BatchRegisterDeviceResponse = BatchRegisterDeviceResponse;
class BatchRegisterDeviceWithApplyIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyId: 'ApplyId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            applyId: 'number',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchRegisterDeviceWithApplyIdRequest = BatchRegisterDeviceWithApplyIdRequest;
class BatchRegisterDeviceWithApplyIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BatchRegisterDeviceWithApplyIdResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchRegisterDeviceWithApplyIdResponseBody = BatchRegisterDeviceWithApplyIdResponseBody;
class BatchRegisterDeviceWithApplyIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchRegisterDeviceWithApplyIdResponseBody,
        };
    }
}
exports.BatchRegisterDeviceWithApplyIdResponse = BatchRegisterDeviceWithApplyIdResponse;
class BatchSetEdgeInstanceDeviceChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelId: 'ChannelId',
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotIds: 'IotIds',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            channelId: 'string',
            driverId: 'string',
            instanceId: 'string',
            iotIds: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchSetEdgeInstanceDeviceChannelRequest = BatchSetEdgeInstanceDeviceChannelRequest;
class BatchSetEdgeInstanceDeviceChannelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchSetEdgeInstanceDeviceChannelResponseBody = BatchSetEdgeInstanceDeviceChannelResponseBody;
class BatchSetEdgeInstanceDeviceChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchSetEdgeInstanceDeviceChannelResponseBody,
        };
    }
}
exports.BatchSetEdgeInstanceDeviceChannelResponse = BatchSetEdgeInstanceDeviceChannelResponse;
class BatchSetEdgeInstanceDeviceConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceConfigs: 'DeviceConfigs',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            deviceConfigs: { 'type': 'array', 'itemType': BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs },
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.BatchSetEdgeInstanceDeviceConfigRequest = BatchSetEdgeInstanceDeviceConfigRequest;
class BatchSetEdgeInstanceDeviceConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchSetEdgeInstanceDeviceConfigResponseBody = BatchSetEdgeInstanceDeviceConfigResponseBody;
class BatchSetEdgeInstanceDeviceConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchSetEdgeInstanceDeviceConfigResponseBody,
        };
    }
}
exports.BatchSetEdgeInstanceDeviceConfigResponse = BatchSetEdgeInstanceDeviceConfigResponse;
class BatchUnbindDeviceFromEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotIds: 'IotIds',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotIds: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchUnbindDeviceFromEdgeInstanceRequest = BatchUnbindDeviceFromEdgeInstanceRequest;
class BatchUnbindDeviceFromEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchUnbindDeviceFromEdgeInstanceResponseBody = BatchUnbindDeviceFromEdgeInstanceResponseBody;
class BatchUnbindDeviceFromEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchUnbindDeviceFromEdgeInstanceResponseBody,
        };
    }
}
exports.BatchUnbindDeviceFromEdgeInstanceResponse = BatchUnbindDeviceFromEdgeInstanceResponse;
class BatchUnbindProjectDevicesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            devices: 'Devices',
            iotInstanceId: 'IotInstanceId',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            devices: { 'type': 'array', 'itemType': BatchUnbindProjectDevicesRequestDevices },
            iotInstanceId: 'string',
            projectId: 'string',
        };
    }
}
exports.BatchUnbindProjectDevicesRequest = BatchUnbindProjectDevicesRequest;
class BatchUnbindProjectDevicesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchUnbindProjectDevicesResponseBody = BatchUnbindProjectDevicesResponseBody;
class BatchUnbindProjectDevicesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchUnbindProjectDevicesResponseBody,
        };
    }
}
exports.BatchUnbindProjectDevicesResponse = BatchUnbindProjectDevicesResponse;
class BatchUnbindProjectProductsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKeys: 'ProductKeys',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKeys: { 'type': 'array', 'itemType': 'string' },
            projectId: 'string',
        };
    }
}
exports.BatchUnbindProjectProductsRequest = BatchUnbindProjectProductsRequest;
class BatchUnbindProjectProductsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchUnbindProjectProductsResponseBody = BatchUnbindProjectProductsResponseBody;
class BatchUnbindProjectProductsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchUnbindProjectProductsResponseBody,
        };
    }
}
exports.BatchUnbindProjectProductsResponse = BatchUnbindProjectProductsResponse;
class BatchUpdateDeviceNicknameRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceNicknameInfo: 'DeviceNicknameInfo',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            deviceNicknameInfo: { 'type': 'array', 'itemType': BatchUpdateDeviceNicknameRequestDeviceNicknameInfo },
            iotInstanceId: 'string',
        };
    }
}
exports.BatchUpdateDeviceNicknameRequest = BatchUpdateDeviceNicknameRequest;
class BatchUpdateDeviceNicknameResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchUpdateDeviceNicknameResponseBody = BatchUpdateDeviceNicknameResponseBody;
class BatchUpdateDeviceNicknameResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchUpdateDeviceNicknameResponseBody,
        };
    }
}
exports.BatchUpdateDeviceNicknameResponse = BatchUpdateDeviceNicknameResponse;
class BindApplicationToEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applicationId: 'ApplicationId',
            applicationVersion: 'ApplicationVersion',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            applicationId: 'string',
            applicationVersion: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.BindApplicationToEdgeInstanceRequest = BindApplicationToEdgeInstanceRequest;
class BindApplicationToEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BindApplicationToEdgeInstanceResponseBody = BindApplicationToEdgeInstanceResponseBody;
class BindApplicationToEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BindApplicationToEdgeInstanceResponseBody,
        };
    }
}
exports.BindApplicationToEdgeInstanceResponse = BindApplicationToEdgeInstanceResponse;
class BindDriverToEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            driverVersion: 'DriverVersion',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            driverVersion: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
            orderId: 'string',
        };
    }
}
exports.BindDriverToEdgeInstanceRequest = BindDriverToEdgeInstanceRequest;
class BindDriverToEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BindDriverToEdgeInstanceResponseBody = BindDriverToEdgeInstanceResponseBody;
class BindDriverToEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BindDriverToEdgeInstanceResponseBody,
        };
    }
}
exports.BindDriverToEdgeInstanceResponse = BindDriverToEdgeInstanceResponse;
class BindGatewayToEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            instanceId: 'InstanceId',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            instanceId: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.BindGatewayToEdgeInstanceRequest = BindGatewayToEdgeInstanceRequest;
class BindGatewayToEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BindGatewayToEdgeInstanceResponseBody = BindGatewayToEdgeInstanceResponseBody;
class BindGatewayToEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BindGatewayToEdgeInstanceResponseBody,
        };
    }
}
exports.BindGatewayToEdgeInstanceResponse = BindGatewayToEdgeInstanceResponse;
class BindLicenseDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceNameList: 'DeviceNameList',
            iotIdList: 'IotIdList',
            iotInstanceId: 'IotInstanceId',
            licenseCode: 'LicenseCode',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceNameList: { 'type': 'array', 'itemType': 'string' },
            iotIdList: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            licenseCode: 'string',
            productKey: 'string',
        };
    }
}
exports.BindLicenseDeviceRequest = BindLicenseDeviceRequest;
class BindLicenseDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: BindLicenseDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BindLicenseDeviceResponseBody = BindLicenseDeviceResponseBody;
class BindLicenseDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BindLicenseDeviceResponseBody,
        };
    }
}
exports.BindLicenseDeviceResponse = BindLicenseDeviceResponse;
class BindLicenseProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            licenseCode: 'LicenseCode',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            licenseCode: 'string',
            productKey: 'string',
        };
    }
}
exports.BindLicenseProductRequest = BindLicenseProductRequest;
class BindLicenseProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BindLicenseProductResponseBody = BindLicenseProductResponseBody;
class BindLicenseProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BindLicenseProductResponseBody,
        };
    }
}
exports.BindLicenseProductResponse = BindLicenseProductResponse;
class BindRoleToEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            roleArn: 'RoleArn',
            roleName: 'RoleName',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
            roleArn: 'string',
            roleName: 'string',
        };
    }
}
exports.BindRoleToEdgeInstanceRequest = BindRoleToEdgeInstanceRequest;
class BindRoleToEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BindRoleToEdgeInstanceResponseBody = BindRoleToEdgeInstanceResponseBody;
class BindRoleToEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BindRoleToEdgeInstanceResponseBody,
        };
    }
}
exports.BindRoleToEdgeInstanceResponse = BindRoleToEdgeInstanceResponse;
class BindSceneRuleToEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
            ruleId: 'string',
        };
    }
}
exports.BindSceneRuleToEdgeInstanceRequest = BindSceneRuleToEdgeInstanceRequest;
class BindSceneRuleToEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.BindSceneRuleToEdgeInstanceResponseBody = BindSceneRuleToEdgeInstanceResponseBody;
class BindSceneRuleToEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BindSceneRuleToEdgeInstanceResponseBody,
        };
    }
}
exports.BindSceneRuleToEdgeInstanceResponse = BindSceneRuleToEdgeInstanceResponse;
class CancelJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            jobId: 'string',
        };
    }
}
exports.CancelJobRequest = CancelJobRequest;
class CancelJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CancelJobResponseBody = CancelJobResponseBody;
class CancelJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelJobResponseBody,
        };
    }
}
exports.CancelJobResponse = CancelJobResponse;
class CancelOTAStrategyByJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            jobId: 'string',
        };
    }
}
exports.CancelOTAStrategyByJobRequest = CancelOTAStrategyByJobRequest;
class CancelOTAStrategyByJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CancelOTAStrategyByJobResponseBody = CancelOTAStrategyByJobResponseBody;
class CancelOTAStrategyByJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelOTAStrategyByJobResponseBody,
        };
    }
}
exports.CancelOTAStrategyByJobResponse = CancelOTAStrategyByJobResponse;
class CancelOTATaskByDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            firmwareId: 'FirmwareId',
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: { 'type': 'array', 'itemType': 'string' },
            firmwareId: 'string',
            iotInstanceId: 'string',
            jobId: 'string',
            productKey: 'string',
        };
    }
}
exports.CancelOTATaskByDeviceRequest = CancelOTATaskByDeviceRequest;
class CancelOTATaskByDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CancelOTATaskByDeviceResponseBody = CancelOTATaskByDeviceResponseBody;
class CancelOTATaskByDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelOTATaskByDeviceResponseBody,
        };
    }
}
exports.CancelOTATaskByDeviceResponse = CancelOTATaskByDeviceResponse;
class CancelOTATaskByJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cancelInProgressTask: 'CancelInProgressTask',
            cancelNotifiedTask: 'CancelNotifiedTask',
            cancelQueuedTask: 'CancelQueuedTask',
            cancelScheduledTask: 'CancelScheduledTask',
            cancelUnconfirmedTask: 'CancelUnconfirmedTask',
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            cancelInProgressTask: 'boolean',
            cancelNotifiedTask: 'boolean',
            cancelQueuedTask: 'boolean',
            cancelScheduledTask: 'boolean',
            cancelUnconfirmedTask: 'boolean',
            iotInstanceId: 'string',
            jobId: 'string',
        };
    }
}
exports.CancelOTATaskByJobRequest = CancelOTATaskByJobRequest;
class CancelOTATaskByJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CancelOTATaskByJobResponseBody = CancelOTATaskByJobResponseBody;
class CancelOTATaskByJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelOTATaskByJobResponseBody,
        };
    }
}
exports.CancelOTATaskByJobResponse = CancelOTATaskByJobResponse;
class CancelReleaseProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.CancelReleaseProductRequest = CancelReleaseProductRequest;
class CancelReleaseProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CancelReleaseProductResponseBody = CancelReleaseProductResponseBody;
class CancelReleaseProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelReleaseProductResponseBody,
        };
    }
}
exports.CancelReleaseProductResponse = CancelReleaseProductResponse;
class CheckBindLicenseDeviceProgressRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkProgressId: 'CheckProgressId',
            iotInstanceId: 'IotInstanceId',
            licenseCode: 'LicenseCode',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            checkProgressId: 'string',
            iotInstanceId: 'string',
            licenseCode: 'string',
            productKey: 'string',
        };
    }
}
exports.CheckBindLicenseDeviceProgressRequest = CheckBindLicenseDeviceProgressRequest;
class CheckBindLicenseDeviceProgressResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CheckBindLicenseDeviceProgressResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CheckBindLicenseDeviceProgressResponseBody = CheckBindLicenseDeviceProgressResponseBody;
class CheckBindLicenseDeviceProgressResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckBindLicenseDeviceProgressResponseBody,
        };
    }
}
exports.CheckBindLicenseDeviceProgressResponse = CheckBindLicenseDeviceProgressResponse;
class ClearDeviceDesiredPropertyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            identifies: 'Identifies',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            identifies: { 'type': 'array', 'itemType': 'string' },
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.ClearDeviceDesiredPropertyRequest = ClearDeviceDesiredPropertyRequest;
class ClearDeviceDesiredPropertyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ClearDeviceDesiredPropertyResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ClearDeviceDesiredPropertyResponseBody = ClearDeviceDesiredPropertyResponseBody;
class ClearDeviceDesiredPropertyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ClearDeviceDesiredPropertyResponseBody,
        };
    }
}
exports.ClearDeviceDesiredPropertyResponse = ClearDeviceDesiredPropertyResponse;
class ClearEdgeInstanceDriverConfigsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.ClearEdgeInstanceDriverConfigsRequest = ClearEdgeInstanceDriverConfigsRequest;
class ClearEdgeInstanceDriverConfigsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ClearEdgeInstanceDriverConfigsResponseBody = ClearEdgeInstanceDriverConfigsResponseBody;
class ClearEdgeInstanceDriverConfigsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ClearEdgeInstanceDriverConfigsResponseBody,
        };
    }
}
exports.ClearEdgeInstanceDriverConfigsResponse = ClearEdgeInstanceDriverConfigsResponse;
class CloseDeviceTunnelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            tunnelId: 'TunnelId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            tunnelId: 'string',
        };
    }
}
exports.CloseDeviceTunnelRequest = CloseDeviceTunnelRequest;
class CloseDeviceTunnelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CloseDeviceTunnelResponseBody = CloseDeviceTunnelResponseBody;
class CloseDeviceTunnelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CloseDeviceTunnelResponseBody,
        };
    }
}
exports.CloseDeviceTunnelResponse = CloseDeviceTunnelResponse;
class CloseEdgeInstanceDeploymentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.CloseEdgeInstanceDeploymentRequest = CloseEdgeInstanceDeploymentRequest;
class CloseEdgeInstanceDeploymentResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CloseEdgeInstanceDeploymentResponseBody = CloseEdgeInstanceDeploymentResponseBody;
class CloseEdgeInstanceDeploymentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CloseEdgeInstanceDeploymentResponseBody,
        };
    }
}
exports.CloseEdgeInstanceDeploymentResponse = CloseEdgeInstanceDeploymentResponse;
class ConfirmOTATaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            taskId: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ConfirmOTATaskRequest = ConfirmOTATaskRequest;
class ConfirmOTATaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ConfirmOTATaskResponseBody = ConfirmOTATaskResponseBody;
class ConfirmOTATaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ConfirmOTATaskResponseBody,
        };
    }
}
exports.ConfirmOTATaskResponse = ConfirmOTATaskResponse;
class CopyThingModelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            resourceGroupId: 'ResourceGroupId',
            sourceModelVersion: 'SourceModelVersion',
            sourceProductKey: 'SourceProductKey',
            targetProductKey: 'TargetProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            resourceGroupId: 'string',
            sourceModelVersion: 'string',
            sourceProductKey: 'string',
            targetProductKey: 'string',
        };
    }
}
exports.CopyThingModelRequest = CopyThingModelRequest;
class CopyThingModelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CopyThingModelResponseBody = CopyThingModelResponseBody;
class CopyThingModelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CopyThingModelResponseBody,
        };
    }
}
exports.CopyThingModelResponse = CopyThingModelResponse;
class CountSpeechBroadcastHourRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            queryDateTimeHour: 'QueryDateTimeHour',
            shareTaskCode: 'ShareTaskCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            queryDateTimeHour: 'string',
            shareTaskCode: 'string',
        };
    }
}
exports.CountSpeechBroadcastHourRequest = CountSpeechBroadcastHourRequest;
class CountSpeechBroadcastHourResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'number',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CountSpeechBroadcastHourResponseBody = CountSpeechBroadcastHourResponseBody;
class CountSpeechBroadcastHourResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CountSpeechBroadcastHourResponseBody,
        };
    }
}
exports.CountSpeechBroadcastHourResponse = CountSpeechBroadcastHourResponse;
class CreateConsumerGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupName: 'GroupName',
            iotInstanceId: 'IotInstanceId',
            subBizCode: 'SubBizCode',
            type: 'Type',
        };
    }
    static types() {
        return {
            groupName: 'string',
            iotInstanceId: 'string',
            subBizCode: 'string',
            type: 'string',
        };
    }
}
exports.CreateConsumerGroupRequest = CreateConsumerGroupRequest;
class CreateConsumerGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            groupId: 'GroupId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            groupId: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateConsumerGroupResponseBody = CreateConsumerGroupResponseBody;
class CreateConsumerGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateConsumerGroupResponseBody,
        };
    }
}
exports.CreateConsumerGroupResponse = CreateConsumerGroupResponse;
class CreateConsumerGroupSubscribeRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            consumerGroupId: 'ConsumerGroupId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            consumerGroupId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.CreateConsumerGroupSubscribeRelationRequest = CreateConsumerGroupSubscribeRelationRequest;
class CreateConsumerGroupSubscribeRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateConsumerGroupSubscribeRelationResponseBody = CreateConsumerGroupSubscribeRelationResponseBody;
class CreateConsumerGroupSubscribeRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateConsumerGroupSubscribeRelationResponseBody,
        };
    }
}
exports.CreateConsumerGroupSubscribeRelationResponse = CreateConsumerGroupSubscribeRelationResponse;
class CreateDataAPIServiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiPath: 'ApiPath',
            desc: 'Desc',
            displayName: 'DisplayName',
            iotInstanceId: 'IotInstanceId',
            originSql: 'OriginSql',
            requestParam: 'RequestParam',
            responseParam: 'ResponseParam',
            templateSql: 'TemplateSql',
        };
    }
    static types() {
        return {
            apiPath: 'string',
            desc: 'string',
            displayName: 'string',
            iotInstanceId: 'string',
            originSql: 'string',
            requestParam: { 'type': 'array', 'itemType': CreateDataAPIServiceRequestRequestParam },
            responseParam: { 'type': 'array', 'itemType': CreateDataAPIServiceRequestResponseParam },
            templateSql: 'string',
        };
    }
}
exports.CreateDataAPIServiceRequest = CreateDataAPIServiceRequest;
class CreateDataAPIServiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateDataAPIServiceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateDataAPIServiceResponseBody = CreateDataAPIServiceResponseBody;
class CreateDataAPIServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDataAPIServiceResponseBody,
        };
    }
}
exports.CreateDataAPIServiceResponse = CreateDataAPIServiceResponse;
class CreateDataSourceItemRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            scopeType: 'ScopeType',
            topic: 'Topic',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            scopeType: 'string',
            topic: 'string',
        };
    }
}
exports.CreateDataSourceItemRequest = CreateDataSourceItemRequest;
class CreateDataSourceItemResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateDataSourceItemResponseBody = CreateDataSourceItemResponseBody;
class CreateDataSourceItemResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDataSourceItemResponseBody,
        };
    }
}
exports.CreateDataSourceItemResponse = CreateDataSourceItemResponse;
class CreateDestinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            type: 'Type',
        };
    }
    static types() {
        return {
            configuration: 'string',
            description: 'string',
            iotInstanceId: 'string',
            name: 'string',
            type: 'string',
        };
    }
}
exports.CreateDestinationRequest = CreateDestinationRequest;
class CreateDestinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            destination: 'Destination',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            destination: CreateDestinationResponseBodyDestination,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateDestinationResponseBody = CreateDestinationResponseBody;
class CreateDestinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDestinationResponseBody,
        };
    }
}
exports.CreateDestinationResponse = CreateDestinationResponse;
class CreateDeviceDistributeJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            productKey: 'ProductKey',
            sourceInstanceId: 'SourceInstanceId',
            strategy: 'Strategy',
            targetAliyunId: 'TargetAliyunId',
            targetInstanceConfig: 'TargetInstanceConfig',
            targetUid: 'TargetUid',
        };
    }
    static types() {
        return {
            deviceName: { 'type': 'array', 'itemType': 'string' },
            productKey: 'string',
            sourceInstanceId: 'string',
            strategy: 'number',
            targetAliyunId: 'string',
            targetInstanceConfig: { 'type': 'array', 'itemType': CreateDeviceDistributeJobRequestTargetInstanceConfig },
            targetUid: 'string',
        };
    }
}
exports.CreateDeviceDistributeJobRequest = CreateDeviceDistributeJobRequest;
class CreateDeviceDistributeJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            jobId: 'JobId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            jobId: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateDeviceDistributeJobResponseBody = CreateDeviceDistributeJobResponseBody;
class CreateDeviceDistributeJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDeviceDistributeJobResponseBody,
        };
    }
}
exports.CreateDeviceDistributeJobResponse = CreateDeviceDistributeJobResponse;
class CreateDeviceDynamicGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dynamicGroupExpression: 'DynamicGroupExpression',
            groupDesc: 'GroupDesc',
            groupName: 'GroupName',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            dynamicGroupExpression: 'string',
            groupDesc: 'string',
            groupName: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.CreateDeviceDynamicGroupRequest = CreateDeviceDynamicGroupRequest;
class CreateDeviceDynamicGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateDeviceDynamicGroupResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateDeviceDynamicGroupResponseBody = CreateDeviceDynamicGroupResponseBody;
class CreateDeviceDynamicGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDeviceDynamicGroupResponseBody,
        };
    }
}
exports.CreateDeviceDynamicGroupResponse = CreateDeviceDynamicGroupResponse;
class CreateDeviceGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupDesc: 'GroupDesc',
            groupName: 'GroupName',
            iotInstanceId: 'IotInstanceId',
            superGroupId: 'SuperGroupId',
        };
    }
    static types() {
        return {
            groupDesc: 'string',
            groupName: 'string',
            iotInstanceId: 'string',
            superGroupId: 'string',
        };
    }
}
exports.CreateDeviceGroupRequest = CreateDeviceGroupRequest;
class CreateDeviceGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateDeviceGroupResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateDeviceGroupResponseBody = CreateDeviceGroupResponseBody;
class CreateDeviceGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDeviceGroupResponseBody,
        };
    }
}
exports.CreateDeviceGroupResponse = CreateDeviceGroupResponse;
class CreateDeviceTunnelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            udi: 'Udi',
        };
    }
    static types() {
        return {
            description: 'string',
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            udi: 'string',
        };
    }
}
exports.CreateDeviceTunnelRequest = CreateDeviceTunnelRequest;
class CreateDeviceTunnelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateDeviceTunnelResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateDeviceTunnelResponseBody = CreateDeviceTunnelResponseBody;
class CreateDeviceTunnelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDeviceTunnelResponseBody,
        };
    }
}
exports.CreateDeviceTunnelResponse = CreateDeviceTunnelResponse;
class CreateDownloadDataJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadDataType: 'DownloadDataType',
            endTime: 'EndTime',
            fileConfig: 'FileConfig',
            iotInstanceId: 'IotInstanceId',
            startTime: 'StartTime',
            tableName: 'TableName',
        };
    }
    static types() {
        return {
            downloadDataType: 'string',
            endTime: 'number',
            fileConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            iotInstanceId: 'string',
            startTime: 'number',
            tableName: 'string',
        };
    }
}
exports.CreateDownloadDataJobRequest = CreateDownloadDataJobRequest;
class CreateDownloadDataJobShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadDataType: 'DownloadDataType',
            endTime: 'EndTime',
            fileConfigShrink: 'FileConfig',
            iotInstanceId: 'IotInstanceId',
            startTime: 'StartTime',
            tableName: 'TableName',
        };
    }
    static types() {
        return {
            downloadDataType: 'string',
            endTime: 'number',
            fileConfigShrink: 'string',
            iotInstanceId: 'string',
            startTime: 'number',
            tableName: 'string',
        };
    }
}
exports.CreateDownloadDataJobShrinkRequest = CreateDownloadDataJobShrinkRequest;
class CreateDownloadDataJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateDownloadDataJobResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateDownloadDataJobResponseBody = CreateDownloadDataJobResponseBody;
class CreateDownloadDataJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDownloadDataJobResponseBody,
        };
    }
}
exports.CreateDownloadDataJobResponse = CreateDownloadDataJobResponse;
class CreateEdgeDriverRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cpuArch: 'CpuArch',
            driverName: 'DriverName',
            driverProtocol: 'DriverProtocol',
            iotInstanceId: 'IotInstanceId',
            isBuiltIn: 'IsBuiltIn',
            runtime: 'Runtime',
        };
    }
    static types() {
        return {
            cpuArch: 'string',
            driverName: 'string',
            driverProtocol: 'string',
            iotInstanceId: 'string',
            isBuiltIn: 'boolean',
            runtime: 'string',
        };
    }
}
exports.CreateEdgeDriverRequest = CreateEdgeDriverRequest;
class CreateEdgeDriverResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            driverId: 'DriverId',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            driverId: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateEdgeDriverResponseBody = CreateEdgeDriverResponseBody;
class CreateEdgeDriverResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateEdgeDriverResponseBody,
        };
    }
}
exports.CreateEdgeDriverResponse = CreateEdgeDriverResponse;
class CreateEdgeDriverVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            argument: 'Argument',
            configCheckRule: 'ConfigCheckRule',
            containerConfig: 'ContainerConfig',
            description: 'Description',
            driverConfig: 'DriverConfig',
            driverId: 'DriverId',
            driverVersion: 'DriverVersion',
            edgeVersion: 'EdgeVersion',
            iotInstanceId: 'IotInstanceId',
            sourceConfig: 'SourceConfig',
        };
    }
    static types() {
        return {
            argument: 'string',
            configCheckRule: 'string',
            containerConfig: 'string',
            description: 'string',
            driverConfig: 'string',
            driverId: 'string',
            driverVersion: 'string',
            edgeVersion: 'string',
            iotInstanceId: 'string',
            sourceConfig: 'string',
        };
    }
}
exports.CreateEdgeDriverVersionRequest = CreateEdgeDriverVersionRequest;
class CreateEdgeDriverVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateEdgeDriverVersionResponseBody = CreateEdgeDriverVersionResponseBody;
class CreateEdgeDriverVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateEdgeDriverVersionResponseBody,
        };
    }
}
exports.CreateEdgeDriverVersionResponse = CreateEdgeDriverVersionResponse;
class CreateEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            spec: 'Spec',
            tags: 'Tags',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            name: 'string',
            spec: 'number',
            tags: 'string',
        };
    }
}
exports.CreateEdgeInstanceRequest = CreateEdgeInstanceRequest;
class CreateEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            instanceId: 'InstanceId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            instanceId: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateEdgeInstanceResponseBody = CreateEdgeInstanceResponseBody;
class CreateEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateEdgeInstanceResponseBody,
        };
    }
}
exports.CreateEdgeInstanceResponse = CreateEdgeInstanceResponse;
class CreateEdgeInstanceChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelName: 'ChannelName',
            configs: 'Configs',
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            channelName: 'string',
            configs: { 'type': 'array', 'itemType': CreateEdgeInstanceChannelRequestConfigs },
            driverId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.CreateEdgeInstanceChannelRequest = CreateEdgeInstanceChannelRequest;
class CreateEdgeInstanceChannelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateEdgeInstanceChannelResponseBody = CreateEdgeInstanceChannelResponseBody;
class CreateEdgeInstanceChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateEdgeInstanceChannelResponseBody,
        };
    }
}
exports.CreateEdgeInstanceChannelResponse = CreateEdgeInstanceChannelResponse;
class CreateEdgeInstanceDeploymentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            type: 'Type',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
            type: 'string',
        };
    }
}
exports.CreateEdgeInstanceDeploymentRequest = CreateEdgeInstanceDeploymentRequest;
class CreateEdgeInstanceDeploymentResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            deploymentId: 'DeploymentId',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            deploymentId: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateEdgeInstanceDeploymentResponseBody = CreateEdgeInstanceDeploymentResponseBody;
class CreateEdgeInstanceDeploymentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateEdgeInstanceDeploymentResponseBody,
        };
    }
}
exports.CreateEdgeInstanceDeploymentResponse = CreateEdgeInstanceDeploymentResponse;
class CreateEdgeInstanceMessageRoutingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            sourceData: 'SourceData',
            sourceType: 'SourceType',
            targetData: 'TargetData',
            targetIotHubQos: 'TargetIotHubQos',
            targetType: 'TargetType',
            topicFilter: 'TopicFilter',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
            name: 'string',
            sourceData: 'string',
            sourceType: 'string',
            targetData: 'string',
            targetIotHubQos: 'number',
            targetType: 'string',
            topicFilter: 'string',
        };
    }
}
exports.CreateEdgeInstanceMessageRoutingRequest = CreateEdgeInstanceMessageRoutingRequest;
class CreateEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            routeId: 'RouteId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            routeId: 'number',
            success: 'boolean',
        };
    }
}
exports.CreateEdgeInstanceMessageRoutingResponseBody = CreateEdgeInstanceMessageRoutingResponseBody;
class CreateEdgeInstanceMessageRoutingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateEdgeInstanceMessageRoutingResponseBody,
        };
    }
}
exports.CreateEdgeInstanceMessageRoutingResponse = CreateEdgeInstanceMessageRoutingResponse;
class CreateEdgeOssPreSignedAddressRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileName: 'FileName',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            resourceId: 'ResourceId',
            resourceVersion: 'ResourceVersion',
            type: 'Type',
        };
    }
    static types() {
        return {
            fileName: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
            resourceId: 'string',
            resourceVersion: 'string',
            type: 'string',
        };
    }
}
exports.CreateEdgeOssPreSignedAddressRequest = CreateEdgeOssPreSignedAddressRequest;
class CreateEdgeOssPreSignedAddressResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateEdgeOssPreSignedAddressResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateEdgeOssPreSignedAddressResponseBody = CreateEdgeOssPreSignedAddressResponseBody;
class CreateEdgeOssPreSignedAddressResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateEdgeOssPreSignedAddressResponseBody,
        };
    }
}
exports.CreateEdgeOssPreSignedAddressResponse = CreateEdgeOssPreSignedAddressResponse;
class CreateJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            jobDocument: 'JobDocument',
            jobFile: 'JobFile',
            jobName: 'JobName',
            rolloutConfig: 'RolloutConfig',
            scheduledTime: 'ScheduledTime',
            targetConfig: 'TargetConfig',
            timeoutConfig: 'TimeoutConfig',
            type: 'Type',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            jobDocument: 'string',
            jobFile: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            jobName: 'string',
            rolloutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            scheduledTime: 'number',
            targetConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            timeoutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            type: 'string',
        };
    }
}
exports.CreateJobRequest = CreateJobRequest;
class CreateJobShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            jobDocument: 'JobDocument',
            jobFileShrink: 'JobFile',
            jobName: 'JobName',
            rolloutConfigShrink: 'RolloutConfig',
            scheduledTime: 'ScheduledTime',
            targetConfigShrink: 'TargetConfig',
            timeoutConfigShrink: 'TimeoutConfig',
            type: 'Type',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            jobDocument: 'string',
            jobFileShrink: 'string',
            jobName: 'string',
            rolloutConfigShrink: 'string',
            scheduledTime: 'number',
            targetConfigShrink: 'string',
            timeoutConfigShrink: 'string',
            type: 'string',
        };
    }
}
exports.CreateJobShrinkRequest = CreateJobShrinkRequest;
class CreateJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            jobId: 'JobId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            jobId: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateJobResponseBody = CreateJobResponseBody;
class CreateJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateJobResponseBody,
        };
    }
}
exports.CreateJobResponse = CreateJobResponse;
class CreateLoRaNodesTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceInfo: 'DeviceInfo',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceInfo: { 'type': 'array', 'itemType': CreateLoRaNodesTaskRequestDeviceInfo },
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.CreateLoRaNodesTaskRequest = CreateLoRaNodesTaskRequest;
class CreateLoRaNodesTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
            taskId: 'string',
        };
    }
}
exports.CreateLoRaNodesTaskResponseBody = CreateLoRaNodesTaskResponseBody;
class CreateLoRaNodesTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateLoRaNodesTaskResponseBody,
        };
    }
}
exports.CreateLoRaNodesTaskResponse = CreateLoRaNodesTaskResponse;
class CreateOTADynamicUpgradeJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadProtocol: 'DownloadProtocol',
            dynamicMode: 'DynamicMode',
            firmwareId: 'FirmwareId',
            groupId: 'GroupId',
            groupType: 'GroupType',
            iotInstanceId: 'IotInstanceId',
            maximumPerMinute: 'MaximumPerMinute',
            multiModuleMode: 'MultiModuleMode',
            needConfirm: 'NeedConfirm',
            needPush: 'NeedPush',
            overwriteMode: 'OverwriteMode',
            productKey: 'ProductKey',
            retryCount: 'RetryCount',
            retryInterval: 'RetryInterval',
            srcVersion: 'SrcVersion',
            tag: 'Tag',
            timeoutInMinutes: 'TimeoutInMinutes',
        };
    }
    static types() {
        return {
            downloadProtocol: 'string',
            dynamicMode: 'number',
            firmwareId: 'string',
            groupId: 'string',
            groupType: 'string',
            iotInstanceId: 'string',
            maximumPerMinute: 'number',
            multiModuleMode: 'boolean',
            needConfirm: 'boolean',
            needPush: 'boolean',
            overwriteMode: 'number',
            productKey: 'string',
            retryCount: 'number',
            retryInterval: 'number',
            srcVersion: { 'type': 'array', 'itemType': 'string' },
            tag: { 'type': 'array', 'itemType': CreateOTADynamicUpgradeJobRequestTag },
            timeoutInMinutes: 'number',
        };
    }
}
exports.CreateOTADynamicUpgradeJobRequest = CreateOTADynamicUpgradeJobRequest;
class CreateOTADynamicUpgradeJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateOTADynamicUpgradeJobResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateOTADynamicUpgradeJobResponseBody = CreateOTADynamicUpgradeJobResponseBody;
class CreateOTADynamicUpgradeJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateOTADynamicUpgradeJobResponseBody,
        };
    }
}
exports.CreateOTADynamicUpgradeJobResponse = CreateOTADynamicUpgradeJobResponse;
class CreateOTAFirmwareRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destVersion: 'DestVersion',
            firmwareDesc: 'FirmwareDesc',
            firmwareName: 'FirmwareName',
            firmwareSign: 'FirmwareSign',
            firmwareSize: 'FirmwareSize',
            firmwareUrl: 'FirmwareUrl',
            iotInstanceId: 'IotInstanceId',
            moduleName: 'ModuleName',
            multiFiles: 'MultiFiles',
            needToVerify: 'NeedToVerify',
            productKey: 'ProductKey',
            signMethod: 'SignMethod',
            srcVersion: 'SrcVersion',
            type: 'Type',
            udi: 'Udi',
        };
    }
    static types() {
        return {
            destVersion: 'string',
            firmwareDesc: 'string',
            firmwareName: 'string',
            firmwareSign: 'string',
            firmwareSize: 'number',
            firmwareUrl: 'string',
            iotInstanceId: 'string',
            moduleName: 'string',
            multiFiles: { 'type': 'array', 'itemType': CreateOTAFirmwareRequestMultiFiles },
            needToVerify: 'boolean',
            productKey: 'string',
            signMethod: 'string',
            srcVersion: 'string',
            type: 'number',
            udi: 'string',
        };
    }
}
exports.CreateOTAFirmwareRequest = CreateOTAFirmwareRequest;
class CreateOTAFirmwareResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateOTAFirmwareResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateOTAFirmwareResponseBody = CreateOTAFirmwareResponseBody;
class CreateOTAFirmwareResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateOTAFirmwareResponseBody,
        };
    }
}
exports.CreateOTAFirmwareResponse = CreateOTAFirmwareResponse;
class CreateOTAModuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliasName: 'AliasName',
            desc: 'Desc',
            iotInstanceId: 'IotInstanceId',
            moduleName: 'ModuleName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            aliasName: 'string',
            desc: 'string',
            iotInstanceId: 'string',
            moduleName: 'string',
            productKey: 'string',
        };
    }
}
exports.CreateOTAModuleRequest = CreateOTAModuleRequest;
class CreateOTAModuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateOTAModuleResponseBody = CreateOTAModuleResponseBody;
class CreateOTAModuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateOTAModuleResponseBody,
        };
    }
}
exports.CreateOTAModuleResponse = CreateOTAModuleResponse;
class CreateOTAStaticUpgradeJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dnListFileUrl: 'DnListFileUrl',
            downloadProtocol: 'DownloadProtocol',
            firmwareId: 'FirmwareId',
            grayPercent: 'GrayPercent',
            groupId: 'GroupId',
            groupType: 'GroupType',
            iotInstanceId: 'IotInstanceId',
            maximumPerMinute: 'MaximumPerMinute',
            multiModuleMode: 'MultiModuleMode',
            needConfirm: 'NeedConfirm',
            needPush: 'NeedPush',
            overwriteMode: 'OverwriteMode',
            productKey: 'ProductKey',
            retryCount: 'RetryCount',
            retryInterval: 'RetryInterval',
            scheduleFinishTime: 'ScheduleFinishTime',
            scheduleTime: 'ScheduleTime',
            srcVersion: 'SrcVersion',
            tag: 'Tag',
            targetDeviceName: 'TargetDeviceName',
            targetSelection: 'TargetSelection',
            timeoutInMinutes: 'TimeoutInMinutes',
        };
    }
    static types() {
        return {
            dnListFileUrl: 'string',
            downloadProtocol: 'string',
            firmwareId: 'string',
            grayPercent: 'string',
            groupId: 'string',
            groupType: 'string',
            iotInstanceId: 'string',
            maximumPerMinute: 'number',
            multiModuleMode: 'boolean',
            needConfirm: 'boolean',
            needPush: 'boolean',
            overwriteMode: 'number',
            productKey: 'string',
            retryCount: 'number',
            retryInterval: 'number',
            scheduleFinishTime: 'number',
            scheduleTime: 'number',
            srcVersion: { 'type': 'array', 'itemType': 'string' },
            tag: { 'type': 'array', 'itemType': CreateOTAStaticUpgradeJobRequestTag },
            targetDeviceName: { 'type': 'array', 'itemType': 'string' },
            targetSelection: 'string',
            timeoutInMinutes: 'number',
        };
    }
}
exports.CreateOTAStaticUpgradeJobRequest = CreateOTAStaticUpgradeJobRequest;
class CreateOTAStaticUpgradeJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateOTAStaticUpgradeJobResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateOTAStaticUpgradeJobResponseBody = CreateOTAStaticUpgradeJobResponseBody;
class CreateOTAStaticUpgradeJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateOTAStaticUpgradeJobResponseBody,
        };
    }
}
exports.CreateOTAStaticUpgradeJobResponse = CreateOTAStaticUpgradeJobResponse;
class CreateOTAVerifyJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadProtocol: 'DownloadProtocol',
            firmwareId: 'FirmwareId',
            iotInstanceId: 'IotInstanceId',
            needConfirm: 'NeedConfirm',
            needPush: 'NeedPush',
            productKey: 'ProductKey',
            tag: 'Tag',
            targetDeviceName: 'TargetDeviceName',
            timeoutInMinutes: 'TimeoutInMinutes',
        };
    }
    static types() {
        return {
            downloadProtocol: 'string',
            firmwareId: 'string',
            iotInstanceId: 'string',
            needConfirm: 'boolean',
            needPush: 'boolean',
            productKey: 'string',
            tag: { 'type': 'array', 'itemType': CreateOTAVerifyJobRequestTag },
            targetDeviceName: { 'type': 'array', 'itemType': 'string' },
            timeoutInMinutes: 'number',
        };
    }
}
exports.CreateOTAVerifyJobRequest = CreateOTAVerifyJobRequest;
class CreateOTAVerifyJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateOTAVerifyJobResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateOTAVerifyJobResponseBody = CreateOTAVerifyJobResponseBody;
class CreateOTAVerifyJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateOTAVerifyJobResponseBody,
        };
    }
}
exports.CreateOTAVerifyJobResponse = CreateOTAVerifyJobResponse;
class CreateParserRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            name: 'string',
        };
    }
}
exports.CreateParserRequest = CreateParserRequest;
class CreateParserResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            parserId: 'ParserId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            parserId: 'number',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateParserResponseBody = CreateParserResponseBody;
class CreateParserResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateParserResponseBody,
        };
    }
}
exports.CreateParserResponse = CreateParserResponse;
class CreateParserDataSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            name: 'string',
        };
    }
}
exports.CreateParserDataSourceRequest = CreateParserDataSourceRequest;
class CreateParserDataSourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            dataSource: 'DataSource',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            dataSource: CreateParserDataSourceResponseBodyDataSource,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateParserDataSourceResponseBody = CreateParserDataSourceResponseBody;
class CreateParserDataSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateParserDataSourceResponseBody,
        };
    }
}
exports.CreateParserDataSourceResponse = CreateParserDataSourceResponse;
class CreateProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliyunCommodityCode: 'AliyunCommodityCode',
            authType: 'AuthType',
            categoryKey: 'CategoryKey',
            dataFormat: 'DataFormat',
            description: 'Description',
            id2: 'Id2',
            iotInstanceId: 'IotInstanceId',
            joinPermissionId: 'JoinPermissionId',
            netType: 'NetType',
            nodeType: 'NodeType',
            productName: 'ProductName',
            protocolType: 'ProtocolType',
            publishAuto: 'PublishAuto',
            resourceGroupId: 'ResourceGroupId',
            validateType: 'ValidateType',
        };
    }
    static types() {
        return {
            aliyunCommodityCode: 'string',
            authType: 'string',
            categoryKey: 'string',
            dataFormat: 'number',
            description: 'string',
            id2: 'boolean',
            iotInstanceId: 'string',
            joinPermissionId: 'string',
            netType: 'string',
            nodeType: 'number',
            productName: 'string',
            protocolType: 'string',
            publishAuto: 'boolean',
            resourceGroupId: 'string',
            validateType: 'number',
        };
    }
}
exports.CreateProductRequest = CreateProductRequest;
class CreateProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            productKey: 'ProductKey',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateProductResponseBodyData,
            errorMessage: 'string',
            productKey: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateProductResponseBody = CreateProductResponseBody;
class CreateProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateProductResponseBody,
        };
    }
}
exports.CreateProductResponse = CreateProductResponse;
class CreateProductDistributeJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            productKey: 'ProductKey',
            sourceInstanceId: 'SourceInstanceId',
            targetAliyunId: 'TargetAliyunId',
            targetInstanceId: 'TargetInstanceId',
            targetUid: 'TargetUid',
        };
    }
    static types() {
        return {
            productKey: 'string',
            sourceInstanceId: 'string',
            targetAliyunId: 'string',
            targetInstanceId: 'string',
            targetUid: 'string',
        };
    }
}
exports.CreateProductDistributeJobRequest = CreateProductDistributeJobRequest;
class CreateProductDistributeJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            jobId: 'JobId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            jobId: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateProductDistributeJobResponseBody = CreateProductDistributeJobResponseBody;
class CreateProductDistributeJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateProductDistributeJobResponseBody,
        };
    }
}
exports.CreateProductDistributeJobResponse = CreateProductDistributeJobResponse;
class CreateProductTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            productTag: 'ProductTag',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
            productTag: { 'type': 'array', 'itemType': CreateProductTagsRequestProductTag },
        };
    }
}
exports.CreateProductTagsRequest = CreateProductTagsRequest;
class CreateProductTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            invalidProductTags: 'InvalidProductTags',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            invalidProductTags: CreateProductTagsResponseBodyInvalidProductTags,
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateProductTagsResponseBody = CreateProductTagsResponseBody;
class CreateProductTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateProductTagsResponseBody,
        };
    }
}
exports.CreateProductTagsResponse = CreateProductTagsResponse;
class CreateProductTopicRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            codec: 'Codec',
            desc: 'Desc',
            enableProxySubscribe: 'EnableProxySubscribe',
            iotInstanceId: 'IotInstanceId',
            operation: 'Operation',
            productKey: 'ProductKey',
            topicShortName: 'TopicShortName',
        };
    }
    static types() {
        return {
            codec: 'string',
            desc: 'string',
            enableProxySubscribe: 'boolean',
            iotInstanceId: 'string',
            operation: 'string',
            productKey: 'string',
            topicShortName: 'string',
        };
    }
}
exports.CreateProductTopicRequest = CreateProductTopicRequest;
class CreateProductTopicResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
            topicId: 'TopicId',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
            topicId: 'number',
        };
    }
}
exports.CreateProductTopicResponseBody = CreateProductTopicResponseBody;
class CreateProductTopicResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateProductTopicResponseBody,
        };
    }
}
exports.CreateProductTopicResponse = CreateProductTopicResponse;
class CreateRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataType: 'DataType',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            productKey: 'ProductKey',
            resourceGroupId: 'ResourceGroupId',
            ruleDesc: 'RuleDesc',
            select: 'Select',
            shortTopic: 'ShortTopic',
            topic: 'Topic',
            topicType: 'TopicType',
            where: 'Where',
        };
    }
    static types() {
        return {
            dataType: 'string',
            iotInstanceId: 'string',
            name: 'string',
            productKey: 'string',
            resourceGroupId: 'string',
            ruleDesc: 'string',
            select: 'string',
            shortTopic: 'string',
            topic: 'string',
            topicType: 'number',
            where: 'string',
        };
    }
}
exports.CreateRuleRequest = CreateRuleRequest;
class CreateRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            ruleId: 'RuleId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            ruleId: 'number',
            success: 'boolean',
        };
    }
}
exports.CreateRuleResponseBody = CreateRuleResponseBody;
class CreateRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateRuleResponseBody,
        };
    }
}
exports.CreateRuleResponse = CreateRuleResponse;
class CreateRuleActionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
            errorActionFlag: 'ErrorActionFlag',
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
            type: 'Type',
        };
    }
    static types() {
        return {
            configuration: 'string',
            errorActionFlag: 'boolean',
            iotInstanceId: 'string',
            ruleId: 'number',
            type: 'string',
        };
    }
}
exports.CreateRuleActionRequest = CreateRuleActionRequest;
class CreateRuleActionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionId: 'ActionId',
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            actionId: 'number',
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateRuleActionResponseBody = CreateRuleActionResponseBody;
class CreateRuleActionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateRuleActionResponseBody,
        };
    }
}
exports.CreateRuleActionResponse = CreateRuleActionResponse;
class CreateSceneRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleContent: 'RuleContent',
            ruleDescription: 'RuleDescription',
            ruleName: 'RuleName',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleContent: 'string',
            ruleDescription: 'string',
            ruleName: 'string',
        };
    }
}
exports.CreateSceneRuleRequest = CreateSceneRuleRequest;
class CreateSceneRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            ruleId: 'RuleId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            ruleId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateSceneRuleResponseBody = CreateSceneRuleResponseBody;
class CreateSceneRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSceneRuleResponseBody,
        };
    }
}
exports.CreateSceneRuleResponse = CreateSceneRuleResponse;
class CreateSchedulePeriodRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            endTime: 'EndTime',
            iotInstanceId: 'IotInstanceId',
            scheduleCode: 'ScheduleCode',
            soundCodeContent: 'SoundCodeContent',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            description: 'string',
            endTime: 'string',
            iotInstanceId: 'string',
            scheduleCode: 'string',
            soundCodeContent: 'string',
            startTime: 'string',
        };
    }
}
exports.CreateSchedulePeriodRequest = CreateSchedulePeriodRequest;
class CreateSchedulePeriodResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateSchedulePeriodResponseBody = CreateSchedulePeriodResponseBody;
class CreateSchedulePeriodResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSchedulePeriodResponseBody,
        };
    }
}
exports.CreateSchedulePeriodResponse = CreateSchedulePeriodResponse;
class CreateSoundCodeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'Duration',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            openType: 'OpenType',
            soundCodeContent: 'SoundCodeContent',
        };
    }
    static types() {
        return {
            duration: 'number',
            iotInstanceId: 'string',
            name: 'string',
            openType: 'string',
            soundCodeContent: 'string',
        };
    }
}
exports.CreateSoundCodeRequest = CreateSoundCodeRequest;
class CreateSoundCodeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateSoundCodeResponseBody = CreateSoundCodeResponseBody;
class CreateSoundCodeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSoundCodeResponseBody,
        };
    }
}
exports.CreateSoundCodeResponse = CreateSoundCodeResponse;
class CreateSoundCodeLabelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            label: 'Label',
            scheduleCode: 'ScheduleCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            label: 'string',
            scheduleCode: 'string',
        };
    }
}
exports.CreateSoundCodeLabelRequest = CreateSoundCodeLabelRequest;
class CreateSoundCodeLabelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateSoundCodeLabelResponseBody = CreateSoundCodeLabelResponseBody;
class CreateSoundCodeLabelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSoundCodeLabelResponseBody,
        };
    }
}
exports.CreateSoundCodeLabelResponse = CreateSoundCodeLabelResponse;
class CreateSoundCodeScheduleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            endDate: 'EndDate',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            openType: 'OpenType',
            startDate: 'StartDate',
        };
    }
    static types() {
        return {
            description: 'string',
            endDate: 'string',
            iotInstanceId: 'string',
            name: 'string',
            openType: 'string',
            startDate: 'string',
        };
    }
}
exports.CreateSoundCodeScheduleRequest = CreateSoundCodeScheduleRequest;
class CreateSoundCodeScheduleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateSoundCodeScheduleResponseBody = CreateSoundCodeScheduleResponseBody;
class CreateSoundCodeScheduleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSoundCodeScheduleResponseBody,
        };
    }
}
exports.CreateSoundCodeScheduleResponse = CreateSoundCodeScheduleResponse;
class CreateSpeechRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            bizCode: 'BizCode',
            enableSoundCode: 'EnableSoundCode',
            iotInstanceId: 'IotInstanceId',
            projectCode: 'ProjectCode',
            soundCodeConfig: 'SoundCodeConfig',
            speechRate: 'SpeechRate',
            speechType: 'SpeechType',
            text: 'Text',
            voice: 'Voice',
            volume: 'Volume',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            bizCode: 'string',
            enableSoundCode: 'boolean',
            iotInstanceId: 'string',
            projectCode: 'string',
            soundCodeConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            speechRate: 'number',
            speechType: 'string',
            text: 'string',
            voice: 'string',
            volume: 'number',
        };
    }
}
exports.CreateSpeechRequest = CreateSpeechRequest;
class CreateSpeechShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            bizCode: 'BizCode',
            enableSoundCode: 'EnableSoundCode',
            iotInstanceId: 'IotInstanceId',
            projectCode: 'ProjectCode',
            soundCodeConfigShrink: 'SoundCodeConfig',
            speechRate: 'SpeechRate',
            speechType: 'SpeechType',
            text: 'Text',
            voice: 'Voice',
            volume: 'Volume',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            bizCode: 'string',
            enableSoundCode: 'boolean',
            iotInstanceId: 'string',
            projectCode: 'string',
            soundCodeConfigShrink: 'string',
            speechRate: 'number',
            speechType: 'string',
            text: 'string',
            voice: 'string',
            volume: 'number',
        };
    }
}
exports.CreateSpeechShrinkRequest = CreateSpeechShrinkRequest;
class CreateSpeechResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateSpeechResponseBody = CreateSpeechResponseBody;
class CreateSpeechResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSpeechResponseBody,
        };
    }
}
exports.CreateSpeechResponse = CreateSpeechResponse;
class CreateStudioAppDomainOpenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            host: 'Host',
            iotInstanceId: 'IotInstanceId',
            projectId: 'ProjectId',
            protocol: 'Protocol',
        };
    }
    static types() {
        return {
            appId: 'string',
            host: 'string',
            iotInstanceId: 'string',
            projectId: 'string',
            protocol: 'string',
        };
    }
}
exports.CreateStudioAppDomainOpenRequest = CreateStudioAppDomainOpenRequest;
class CreateStudioAppDomainOpenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateStudioAppDomainOpenResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateStudioAppDomainOpenResponseBody = CreateStudioAppDomainOpenResponseBody;
class CreateStudioAppDomainOpenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateStudioAppDomainOpenResponseBody,
        };
    }
}
exports.CreateStudioAppDomainOpenResponse = CreateStudioAppDomainOpenResponse;
class CreateSubscribeRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            consumerGroupIds: 'ConsumerGroupIds',
            deviceDataFlag: 'DeviceDataFlag',
            deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
            deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
            deviceTagFlag: 'DeviceTagFlag',
            deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
            foundDeviceListFlag: 'FoundDeviceListFlag',
            iotInstanceId: 'IotInstanceId',
            mnsConfiguration: 'MnsConfiguration',
            otaEventFlag: 'OtaEventFlag',
            otaJobFlag: 'OtaJobFlag',
            otaVersionFlag: 'OtaVersionFlag',
            productKey: 'ProductKey',
            subscribeFlags: 'SubscribeFlags',
            thingHistoryFlag: 'ThingHistoryFlag',
            type: 'Type',
        };
    }
    static types() {
        return {
            consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
            deviceDataFlag: 'boolean',
            deviceLifeCycleFlag: 'boolean',
            deviceStatusChangeFlag: 'boolean',
            deviceTagFlag: 'boolean',
            deviceTopoLifeCycleFlag: 'boolean',
            foundDeviceListFlag: 'boolean',
            iotInstanceId: 'string',
            mnsConfiguration: 'string',
            otaEventFlag: 'boolean',
            otaJobFlag: 'boolean',
            otaVersionFlag: 'boolean',
            productKey: 'string',
            subscribeFlags: 'string',
            thingHistoryFlag: 'boolean',
            type: 'string',
        };
    }
}
exports.CreateSubscribeRelationRequest = CreateSubscribeRelationRequest;
class CreateSubscribeRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateSubscribeRelationResponseBody = CreateSubscribeRelationResponseBody;
class CreateSubscribeRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSubscribeRelationResponseBody,
        };
    }
}
exports.CreateSubscribeRelationResponse = CreateSubscribeRelationResponse;
class CreateThingModelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionBlockId: 'FunctionBlockId',
            functionBlockName: 'FunctionBlockName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            thingModelJson: 'ThingModelJson',
        };
    }
    static types() {
        return {
            functionBlockId: 'string',
            functionBlockName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            thingModelJson: 'string',
        };
    }
}
exports.CreateThingModelRequest = CreateThingModelRequest;
class CreateThingModelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateThingModelResponseBody = CreateThingModelResponseBody;
class CreateThingModelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateThingModelResponseBody,
        };
    }
}
exports.CreateThingModelResponse = CreateThingModelResponse;
class CreateThingScriptRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            scriptContent: 'ScriptContent',
            scriptType: 'ScriptType',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
            scriptContent: 'string',
            scriptType: 'string',
        };
    }
}
exports.CreateThingScriptRequest = CreateThingScriptRequest;
class CreateThingScriptResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateThingScriptResponseBody = CreateThingScriptResponseBody;
class CreateThingScriptResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateThingScriptResponseBody,
        };
    }
}
exports.CreateThingScriptResponse = CreateThingScriptResponse;
class CreateTopicConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            codec: 'Codec',
            description: 'Description',
            enableBroadcast: 'EnableBroadcast',
            enableProxySubscribe: 'EnableProxySubscribe',
            iotInstanceId: 'IotInstanceId',
            operation: 'Operation',
            productKey: 'ProductKey',
            topicFullName: 'TopicFullName',
        };
    }
    static types() {
        return {
            codec: 'string',
            description: 'string',
            enableBroadcast: 'boolean',
            enableProxySubscribe: 'boolean',
            iotInstanceId: 'string',
            operation: 'string',
            productKey: 'string',
            topicFullName: 'string',
        };
    }
}
exports.CreateTopicConfigRequest = CreateTopicConfigRequest;
class CreateTopicConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateTopicConfigResponseBody = CreateTopicConfigResponseBody;
class CreateTopicConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateTopicConfigResponseBody,
        };
    }
}
exports.CreateTopicConfigResponse = CreateTopicConfigResponse;
class CreateTopicRouteTableRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dstTopic: 'DstTopic',
            iotInstanceId: 'IotInstanceId',
            srcTopic: 'SrcTopic',
        };
    }
    static types() {
        return {
            dstTopic: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            srcTopic: 'string',
        };
    }
}
exports.CreateTopicRouteTableRequest = CreateTopicRouteTableRequest;
class CreateTopicRouteTableResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            failureTopics: 'FailureTopics',
            isAllSucceed: 'IsAllSucceed',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            failureTopics: CreateTopicRouteTableResponseBodyFailureTopics,
            isAllSucceed: 'boolean',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateTopicRouteTableResponseBody = CreateTopicRouteTableResponseBody;
class CreateTopicRouteTableResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateTopicRouteTableResponseBody,
        };
    }
}
exports.CreateTopicRouteTableResponse = CreateTopicRouteTableResponse;
class DeleteClientIdsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            iotId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteClientIdsRequest = DeleteClientIdsRequest;
class DeleteClientIdsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteClientIdsResponseBody = DeleteClientIdsResponseBody;
class DeleteClientIdsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteClientIdsResponseBody,
        };
    }
}
exports.DeleteClientIdsResponse = DeleteClientIdsResponse;
class DeleteConsumerGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            groupId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteConsumerGroupRequest = DeleteConsumerGroupRequest;
class DeleteConsumerGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteConsumerGroupResponseBody = DeleteConsumerGroupResponseBody;
class DeleteConsumerGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteConsumerGroupResponseBody,
        };
    }
}
exports.DeleteConsumerGroupResponse = DeleteConsumerGroupResponse;
class DeleteConsumerGroupSubscribeRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            consumerGroupId: 'ConsumerGroupId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            consumerGroupId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.DeleteConsumerGroupSubscribeRelationRequest = DeleteConsumerGroupSubscribeRelationRequest;
class DeleteConsumerGroupSubscribeRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteConsumerGroupSubscribeRelationResponseBody = DeleteConsumerGroupSubscribeRelationResponseBody;
class DeleteConsumerGroupSubscribeRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteConsumerGroupSubscribeRelationResponseBody,
        };
    }
}
exports.DeleteConsumerGroupSubscribeRelationResponse = DeleteConsumerGroupSubscribeRelationResponse;
class DeleteDataSourceItemRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            dataSourceItemId: 'DataSourceItemId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            dataSourceItemId: 'number',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteDataSourceItemRequest = DeleteDataSourceItemRequest;
class DeleteDataSourceItemResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteDataSourceItemResponseBody = DeleteDataSourceItemResponseBody;
class DeleteDataSourceItemResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDataSourceItemResponseBody,
        };
    }
}
exports.DeleteDataSourceItemResponse = DeleteDataSourceItemResponse;
class DeleteDestinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destinationId: 'DestinationId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            destinationId: 'number',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteDestinationRequest = DeleteDestinationRequest;
class DeleteDestinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteDestinationResponseBody = DeleteDestinationResponseBody;
class DeleteDestinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDestinationResponseBody,
        };
    }
}
exports.DeleteDestinationResponse = DeleteDestinationResponse;
class DeleteDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.DeleteDeviceRequest = DeleteDeviceRequest;
class DeleteDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteDeviceResponseBody = DeleteDeviceResponseBody;
class DeleteDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDeviceResponseBody,
        };
    }
}
exports.DeleteDeviceResponse = DeleteDeviceResponse;
class DeleteDeviceDistributeJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            jobId: 'string',
        };
    }
}
exports.DeleteDeviceDistributeJobRequest = DeleteDeviceDistributeJobRequest;
class DeleteDeviceDistributeJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteDeviceDistributeJobResponseBody = DeleteDeviceDistributeJobResponseBody;
class DeleteDeviceDistributeJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDeviceDistributeJobResponseBody,
        };
    }
}
exports.DeleteDeviceDistributeJobResponse = DeleteDeviceDistributeJobResponse;
class DeleteDeviceDynamicGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            groupId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteDeviceDynamicGroupRequest = DeleteDeviceDynamicGroupRequest;
class DeleteDeviceDynamicGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteDeviceDynamicGroupResponseBody = DeleteDeviceDynamicGroupResponseBody;
class DeleteDeviceDynamicGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDeviceDynamicGroupResponseBody,
        };
    }
}
exports.DeleteDeviceDynamicGroupResponse = DeleteDeviceDynamicGroupResponse;
class DeleteDeviceFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            fileId: 'FileId',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            fileId: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.DeleteDeviceFileRequest = DeleteDeviceFileRequest;
class DeleteDeviceFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteDeviceFileResponseBody = DeleteDeviceFileResponseBody;
class DeleteDeviceFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDeviceFileResponseBody,
        };
    }
}
exports.DeleteDeviceFileResponse = DeleteDeviceFileResponse;
class DeleteDeviceGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            groupId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteDeviceGroupRequest = DeleteDeviceGroupRequest;
class DeleteDeviceGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteDeviceGroupResponseBody = DeleteDeviceGroupResponseBody;
class DeleteDeviceGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDeviceGroupResponseBody,
        };
    }
}
exports.DeleteDeviceGroupResponse = DeleteDeviceGroupResponse;
class DeleteDevicePropRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            propKey: 'PropKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            propKey: 'string',
        };
    }
}
exports.DeleteDevicePropRequest = DeleteDevicePropRequest;
class DeleteDevicePropResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteDevicePropResponseBody = DeleteDevicePropResponseBody;
class DeleteDevicePropResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDevicePropResponseBody,
        };
    }
}
exports.DeleteDevicePropResponse = DeleteDevicePropResponse;
class DeleteDeviceSpeechRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceSpeechList: 'DeviceSpeechList',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            deviceSpeechList: { 'type': 'array', 'itemType': DeleteDeviceSpeechRequestDeviceSpeechList },
            iotId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteDeviceSpeechRequest = DeleteDeviceSpeechRequest;
class DeleteDeviceSpeechResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteDeviceSpeechResponseBody = DeleteDeviceSpeechResponseBody;
class DeleteDeviceSpeechResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDeviceSpeechResponseBody,
        };
    }
}
exports.DeleteDeviceSpeechResponse = DeleteDeviceSpeechResponse;
class DeleteDeviceTunnelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            tunnelId: 'TunnelId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            tunnelId: 'string',
        };
    }
}
exports.DeleteDeviceTunnelRequest = DeleteDeviceTunnelRequest;
class DeleteDeviceTunnelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteDeviceTunnelResponseBody = DeleteDeviceTunnelResponseBody;
class DeleteDeviceTunnelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDeviceTunnelResponseBody,
        };
    }
}
exports.DeleteDeviceTunnelResponse = DeleteDeviceTunnelResponse;
class DeleteEdgeDriverRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteEdgeDriverRequest = DeleteEdgeDriverRequest;
class DeleteEdgeDriverResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteEdgeDriverResponseBody = DeleteEdgeDriverResponseBody;
class DeleteEdgeDriverResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteEdgeDriverResponseBody,
        };
    }
}
exports.DeleteEdgeDriverResponse = DeleteEdgeDriverResponse;
class DeleteEdgeDriverVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            driverVersion: 'DriverVersion',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            driverVersion: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteEdgeDriverVersionRequest = DeleteEdgeDriverVersionRequest;
class DeleteEdgeDriverVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteEdgeDriverVersionResponseBody = DeleteEdgeDriverVersionResponseBody;
class DeleteEdgeDriverVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteEdgeDriverVersionResponseBody,
        };
    }
}
exports.DeleteEdgeDriverVersionResponse = DeleteEdgeDriverVersionResponse;
class DeleteEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteEdgeInstanceRequest = DeleteEdgeInstanceRequest;
class DeleteEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteEdgeInstanceResponseBody = DeleteEdgeInstanceResponseBody;
class DeleteEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteEdgeInstanceResponseBody,
        };
    }
}
exports.DeleteEdgeInstanceResponse = DeleteEdgeInstanceResponse;
class DeleteEdgeInstanceMessageRoutingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            routeId: 'RouteId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
            routeId: 'number',
        };
    }
}
exports.DeleteEdgeInstanceMessageRoutingRequest = DeleteEdgeInstanceMessageRoutingRequest;
class DeleteEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteEdgeInstanceMessageRoutingResponseBody = DeleteEdgeInstanceMessageRoutingResponseBody;
class DeleteEdgeInstanceMessageRoutingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteEdgeInstanceMessageRoutingResponseBody,
        };
    }
}
exports.DeleteEdgeInstanceMessageRoutingResponse = DeleteEdgeInstanceMessageRoutingResponse;
class DeleteJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            jobId: 'string',
        };
    }
}
exports.DeleteJobRequest = DeleteJobRequest;
class DeleteJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteJobResponseBody = DeleteJobResponseBody;
class DeleteJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteJobResponseBody,
        };
    }
}
exports.DeleteJobResponse = DeleteJobResponse;
class DeleteOTAFirmwareRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            firmwareId: 'FirmwareId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            firmwareId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteOTAFirmwareRequest = DeleteOTAFirmwareRequest;
class DeleteOTAFirmwareResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteOTAFirmwareResponseBody = DeleteOTAFirmwareResponseBody;
class DeleteOTAFirmwareResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteOTAFirmwareResponseBody,
        };
    }
}
exports.DeleteOTAFirmwareResponse = DeleteOTAFirmwareResponse;
class DeleteOTAModuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            moduleName: 'ModuleName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            moduleName: 'string',
            productKey: 'string',
        };
    }
}
exports.DeleteOTAModuleRequest = DeleteOTAModuleRequest;
class DeleteOTAModuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteOTAModuleResponseBody = DeleteOTAModuleResponseBody;
class DeleteOTAModuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteOTAModuleResponseBody,
        };
    }
}
exports.DeleteOTAModuleResponse = DeleteOTAModuleResponse;
class DeleteParserRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            parserId: 'number',
        };
    }
}
exports.DeleteParserRequest = DeleteParserRequest;
class DeleteParserResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteParserResponseBody = DeleteParserResponseBody;
class DeleteParserResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteParserResponseBody,
        };
    }
}
exports.DeleteParserResponse = DeleteParserResponse;
class DeleteParserDataSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteParserDataSourceRequest = DeleteParserDataSourceRequest;
class DeleteParserDataSourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteParserDataSourceResponseBody = DeleteParserDataSourceResponseBody;
class DeleteParserDataSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteParserDataSourceResponseBody,
        };
    }
}
exports.DeleteParserDataSourceResponse = DeleteParserDataSourceResponse;
class DeleteProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.DeleteProductRequest = DeleteProductRequest;
class DeleteProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteProductResponseBody = DeleteProductResponseBody;
class DeleteProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteProductResponseBody,
        };
    }
}
exports.DeleteProductResponse = DeleteProductResponse;
class DeleteProductTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            productTagKey: 'ProductTagKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
            productTagKey: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DeleteProductTagsRequest = DeleteProductTagsRequest;
class DeleteProductTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteProductTagsResponseBody = DeleteProductTagsResponseBody;
class DeleteProductTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteProductTagsResponseBody,
        };
    }
}
exports.DeleteProductTagsResponse = DeleteProductTagsResponse;
class DeleteProductTopicRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            topicId: 'TopicId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            topicId: 'string',
        };
    }
}
exports.DeleteProductTopicRequest = DeleteProductTopicRequest;
class DeleteProductTopicResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteProductTopicResponseBody = DeleteProductTopicResponseBody;
class DeleteProductTopicResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteProductTopicResponseBody,
        };
    }
}
exports.DeleteProductTopicResponse = DeleteProductTopicResponse;
class DeleteRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleId: 'number',
        };
    }
}
exports.DeleteRuleRequest = DeleteRuleRequest;
class DeleteRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteRuleResponseBody = DeleteRuleResponseBody;
class DeleteRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteRuleResponseBody,
        };
    }
}
exports.DeleteRuleResponse = DeleteRuleResponse;
class DeleteRuleActionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionId: 'ActionId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            actionId: 'number',
            iotInstanceId: 'string',
        };
    }
}
exports.DeleteRuleActionRequest = DeleteRuleActionRequest;
class DeleteRuleActionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteRuleActionResponseBody = DeleteRuleActionResponseBody;
class DeleteRuleActionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteRuleActionResponseBody,
        };
    }
}
exports.DeleteRuleActionResponse = DeleteRuleActionResponse;
class DeleteSceneRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleId: 'string',
        };
    }
}
exports.DeleteSceneRuleRequest = DeleteSceneRuleRequest;
class DeleteSceneRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteSceneRuleResponseBody = DeleteSceneRuleResponseBody;
class DeleteSceneRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSceneRuleResponseBody,
        };
    }
}
exports.DeleteSceneRuleResponse = DeleteSceneRuleResponse;
class DeleteSchedulePeriodRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            periodCode: 'PeriodCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            periodCode: 'string',
        };
    }
}
exports.DeleteSchedulePeriodRequest = DeleteSchedulePeriodRequest;
class DeleteSchedulePeriodResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteSchedulePeriodResponseBody = DeleteSchedulePeriodResponseBody;
class DeleteSchedulePeriodResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSchedulePeriodResponseBody,
        };
    }
}
exports.DeleteSchedulePeriodResponse = DeleteSchedulePeriodResponse;
class DeleteShareTaskDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotIdList: 'IotIdList',
            iotInstanceId: 'IotInstanceId',
            shareTaskId: 'ShareTaskId',
        };
    }
    static types() {
        return {
            iotIdList: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            shareTaskId: 'string',
        };
    }
}
exports.DeleteShareTaskDeviceRequest = DeleteShareTaskDeviceRequest;
class DeleteShareTaskDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DeleteShareTaskDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteShareTaskDeviceResponseBody = DeleteShareTaskDeviceResponseBody;
class DeleteShareTaskDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteShareTaskDeviceResponseBody,
        };
    }
}
exports.DeleteShareTaskDeviceResponse = DeleteShareTaskDeviceResponse;
class DeleteSoundCodeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            soundCode: 'SoundCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            soundCode: 'string',
        };
    }
}
exports.DeleteSoundCodeRequest = DeleteSoundCodeRequest;
class DeleteSoundCodeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteSoundCodeResponseBody = DeleteSoundCodeResponseBody;
class DeleteSoundCodeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSoundCodeResponseBody,
        };
    }
}
exports.DeleteSoundCodeResponse = DeleteSoundCodeResponse;
class DeleteSoundCodeLabelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            soundCode: 'SoundCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            soundCode: 'string',
        };
    }
}
exports.DeleteSoundCodeLabelRequest = DeleteSoundCodeLabelRequest;
class DeleteSoundCodeLabelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteSoundCodeLabelResponseBody = DeleteSoundCodeLabelResponseBody;
class DeleteSoundCodeLabelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSoundCodeLabelResponseBody,
        };
    }
}
exports.DeleteSoundCodeLabelResponse = DeleteSoundCodeLabelResponse;
class DeleteSoundCodeScheduleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            scheduleCode: 'ScheduleCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            scheduleCode: 'string',
        };
    }
}
exports.DeleteSoundCodeScheduleRequest = DeleteSoundCodeScheduleRequest;
class DeleteSoundCodeScheduleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteSoundCodeScheduleResponseBody = DeleteSoundCodeScheduleResponseBody;
class DeleteSoundCodeScheduleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSoundCodeScheduleResponseBody,
        };
    }
}
exports.DeleteSoundCodeScheduleResponse = DeleteSoundCodeScheduleResponse;
class DeleteSpeechRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            speechCodeList: 'SpeechCodeList',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            speechCodeList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DeleteSpeechRequest = DeleteSpeechRequest;
class DeleteSpeechResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteSpeechResponseBody = DeleteSpeechResponseBody;
class DeleteSpeechResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSpeechResponseBody,
        };
    }
}
exports.DeleteSpeechResponse = DeleteSpeechResponse;
class DeleteStudioAppDomainOpenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            domainId: 'DomainId',
            iotInstanceId: 'IotInstanceId',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            appId: 'string',
            domainId: 'number',
            iotInstanceId: 'string',
            projectId: 'string',
        };
    }
}
exports.DeleteStudioAppDomainOpenRequest = DeleteStudioAppDomainOpenRequest;
class DeleteStudioAppDomainOpenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteStudioAppDomainOpenResponseBody = DeleteStudioAppDomainOpenResponseBody;
class DeleteStudioAppDomainOpenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteStudioAppDomainOpenResponseBody,
        };
    }
}
exports.DeleteStudioAppDomainOpenResponse = DeleteStudioAppDomainOpenResponse;
class DeleteSubscribeRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            type: 'Type',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
            type: 'string',
        };
    }
}
exports.DeleteSubscribeRelationRequest = DeleteSubscribeRelationRequest;
class DeleteSubscribeRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteSubscribeRelationResponseBody = DeleteSubscribeRelationResponseBody;
class DeleteSubscribeRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSubscribeRelationResponseBody,
        };
    }
}
exports.DeleteSubscribeRelationResponse = DeleteSubscribeRelationResponse;
class DeleteThingModelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventIdentifier: 'EventIdentifier',
            functionBlockId: 'FunctionBlockId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            propertyIdentifier: 'PropertyIdentifier',
            resourceGroupId: 'ResourceGroupId',
            serviceIdentifier: 'ServiceIdentifier',
        };
    }
    static types() {
        return {
            eventIdentifier: { 'type': 'array', 'itemType': 'string' },
            functionBlockId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            propertyIdentifier: { 'type': 'array', 'itemType': 'string' },
            resourceGroupId: 'string',
            serviceIdentifier: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DeleteThingModelRequest = DeleteThingModelRequest;
class DeleteThingModelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteThingModelResponseBody = DeleteThingModelResponseBody;
class DeleteThingModelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteThingModelResponseBody,
        };
    }
}
exports.DeleteThingModelResponse = DeleteThingModelResponse;
class DeleteTopicConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            topicFullName: 'TopicFullName',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
            topicFullName: 'string',
        };
    }
}
exports.DeleteTopicConfigRequest = DeleteTopicConfigRequest;
class DeleteTopicConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteTopicConfigResponseBody = DeleteTopicConfigResponseBody;
class DeleteTopicConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteTopicConfigResponseBody,
        };
    }
}
exports.DeleteTopicConfigResponse = DeleteTopicConfigResponse;
class DeleteTopicRouteTableRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dstTopic: 'DstTopic',
            iotInstanceId: 'IotInstanceId',
            srcTopic: 'SrcTopic',
        };
    }
    static types() {
        return {
            dstTopic: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            srcTopic: 'string',
        };
    }
}
exports.DeleteTopicRouteTableRequest = DeleteTopicRouteTableRequest;
class DeleteTopicRouteTableResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            failureTopics: 'FailureTopics',
            isAllSucceed: 'IsAllSucceed',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            failureTopics: DeleteTopicRouteTableResponseBodyFailureTopics,
            isAllSucceed: 'boolean',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteTopicRouteTableResponseBody = DeleteTopicRouteTableResponseBody;
class DeleteTopicRouteTableResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteTopicRouteTableResponseBody,
        };
    }
}
exports.DeleteTopicRouteTableResponse = DeleteTopicRouteTableResponse;
class DetachDestinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destinationId: 'DestinationId',
            iotInstanceId: 'IotInstanceId',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            destinationId: 'number',
            iotInstanceId: 'string',
            parserId: 'number',
        };
    }
}
exports.DetachDestinationRequest = DetachDestinationRequest;
class DetachDestinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DetachDestinationResponseBody = DetachDestinationResponseBody;
class DetachDestinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DetachDestinationResponseBody,
        };
    }
}
exports.DetachDestinationResponse = DetachDestinationResponse;
class DetachParserDataSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            iotInstanceId: 'IotInstanceId',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            iotInstanceId: 'string',
            parserId: 'number',
        };
    }
}
exports.DetachParserDataSourceRequest = DetachParserDataSourceRequest;
class DetachParserDataSourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DetachParserDataSourceResponseBody = DetachParserDataSourceResponseBody;
class DetachParserDataSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DetachParserDataSourceResponseBody,
        };
    }
}
exports.DetachParserDataSourceResponse = DetachParserDataSourceResponse;
class DisableDeviceTunnelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.DisableDeviceTunnelRequest = DisableDeviceTunnelRequest;
class DisableDeviceTunnelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DisableDeviceTunnelResponseBody = DisableDeviceTunnelResponseBody;
class DisableDeviceTunnelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DisableDeviceTunnelResponseBody,
        };
    }
}
exports.DisableDeviceTunnelResponse = DisableDeviceTunnelResponse;
class DisableDeviceTunnelShareRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.DisableDeviceTunnelShareRequest = DisableDeviceTunnelShareRequest;
class DisableDeviceTunnelShareResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DisableDeviceTunnelShareResponseBody = DisableDeviceTunnelShareResponseBody;
class DisableDeviceTunnelShareResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DisableDeviceTunnelShareResponseBody,
        };
    }
}
exports.DisableDeviceTunnelShareResponse = DisableDeviceTunnelShareResponse;
class DisableSceneRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleId: 'string',
        };
    }
}
exports.DisableSceneRuleRequest = DisableSceneRuleRequest;
class DisableSceneRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DisableSceneRuleResponseBody = DisableSceneRuleResponseBody;
class DisableSceneRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DisableSceneRuleResponseBody,
        };
    }
}
exports.DisableSceneRuleResponse = DisableSceneRuleResponse;
class DisableThingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.DisableThingRequest = DisableThingRequest;
class DisableThingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DisableThingResponseBody = DisableThingResponseBody;
class DisableThingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DisableThingResponseBody,
        };
    }
}
exports.DisableThingResponse = DisableThingResponse;
class EnableDeviceTunnelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.EnableDeviceTunnelRequest = EnableDeviceTunnelRequest;
class EnableDeviceTunnelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.EnableDeviceTunnelResponseBody = EnableDeviceTunnelResponseBody;
class EnableDeviceTunnelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EnableDeviceTunnelResponseBody,
        };
    }
}
exports.EnableDeviceTunnelResponse = EnableDeviceTunnelResponse;
class EnableDeviceTunnelShareRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.EnableDeviceTunnelShareRequest = EnableDeviceTunnelShareRequest;
class EnableDeviceTunnelShareResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.EnableDeviceTunnelShareResponseBody = EnableDeviceTunnelShareResponseBody;
class EnableDeviceTunnelShareResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EnableDeviceTunnelShareResponseBody,
        };
    }
}
exports.EnableDeviceTunnelShareResponse = EnableDeviceTunnelShareResponse;
class EnableSceneRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleId: 'string',
        };
    }
}
exports.EnableSceneRuleRequest = EnableSceneRuleRequest;
class EnableSceneRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.EnableSceneRuleResponseBody = EnableSceneRuleResponseBody;
class EnableSceneRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EnableSceneRuleResponseBody,
        };
    }
}
exports.EnableSceneRuleResponse = EnableSceneRuleResponse;
class EnableThingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.EnableThingRequest = EnableThingRequest;
class EnableThingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.EnableThingResponseBody = EnableThingResponseBody;
class EnableThingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EnableThingResponseBody,
        };
    }
}
exports.EnableThingResponse = EnableThingResponse;
class GenerateDeviceNameListURLRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
        };
    }
}
exports.GenerateDeviceNameListURLRequest = GenerateDeviceNameListURLRequest;
class GenerateDeviceNameListURLResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GenerateDeviceNameListURLResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GenerateDeviceNameListURLResponseBody = GenerateDeviceNameListURLResponseBody;
class GenerateDeviceNameListURLResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GenerateDeviceNameListURLResponseBody,
        };
    }
}
exports.GenerateDeviceNameListURLResponse = GenerateDeviceNameListURLResponse;
class GenerateFileUploadURLRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'BizCode',
            fileName: 'FileName',
            fileSuffix: 'FileSuffix',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            fileName: 'string',
            fileSuffix: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.GenerateFileUploadURLRequest = GenerateFileUploadURLRequest;
class GenerateFileUploadURLResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GenerateFileUploadURLResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GenerateFileUploadURLResponseBody = GenerateFileUploadURLResponseBody;
class GenerateFileUploadURLResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GenerateFileUploadURLResponseBody,
        };
    }
}
exports.GenerateFileUploadURLResponse = GenerateFileUploadURLResponse;
class GenerateOTAUploadURLRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileSuffix: 'FileSuffix',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            fileSuffix: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.GenerateOTAUploadURLRequest = GenerateOTAUploadURLRequest;
class GenerateOTAUploadURLResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GenerateOTAUploadURLResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GenerateOTAUploadURLResponseBody = GenerateOTAUploadURLResponseBody;
class GenerateOTAUploadURLResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GenerateOTAUploadURLResponseBody,
        };
    }
}
exports.GenerateOTAUploadURLResponse = GenerateOTAUploadURLResponse;
class GetDataAPIServiceDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiSrn: 'ApiSrn',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            apiSrn: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.GetDataAPIServiceDetailRequest = GetDataAPIServiceDetailRequest;
class GetDataAPIServiceDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetDataAPIServiceDetailResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetDataAPIServiceDetailResponseBody = GetDataAPIServiceDetailResponseBody;
class GetDataAPIServiceDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDataAPIServiceDetailResponseBody,
        };
    }
}
exports.GetDataAPIServiceDetailResponse = GetDataAPIServiceDetailResponse;
class GetDestinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destinationId: 'DestinationId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            destinationId: 'number',
            iotInstanceId: 'string',
        };
    }
}
exports.GetDestinationRequest = GetDestinationRequest;
class GetDestinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            destination: 'Destination',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            destination: GetDestinationResponseBodyDestination,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetDestinationResponseBody = GetDestinationResponseBody;
class GetDestinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDestinationResponseBody,
        };
    }
}
exports.GetDestinationResponse = GetDestinationResponse;
class GetDeviceShadowRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.GetDeviceShadowRequest = GetDeviceShadowRequest;
class GetDeviceShadowResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            shadowMessage: 'ShadowMessage',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            shadowMessage: 'string',
            success: 'boolean',
        };
    }
}
exports.GetDeviceShadowResponseBody = GetDeviceShadowResponseBody;
class GetDeviceShadowResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDeviceShadowResponseBody,
        };
    }
}
exports.GetDeviceShadowResponse = GetDeviceShadowResponse;
class GetDeviceStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.GetDeviceStatusRequest = GetDeviceStatusRequest;
class GetDeviceStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetDeviceStatusResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetDeviceStatusResponseBody = GetDeviceStatusResponseBody;
class GetDeviceStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDeviceStatusResponseBody,
        };
    }
}
exports.GetDeviceStatusResponse = GetDeviceStatusResponse;
class GetDeviceTunnelShareStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.GetDeviceTunnelShareStatusRequest = GetDeviceTunnelShareStatusRequest;
class GetDeviceTunnelShareStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetDeviceTunnelShareStatusResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetDeviceTunnelShareStatusResponseBody = GetDeviceTunnelShareStatusResponseBody;
class GetDeviceTunnelShareStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDeviceTunnelShareStatusResponseBody,
        };
    }
}
exports.GetDeviceTunnelShareStatusResponse = GetDeviceTunnelShareStatusResponse;
class GetDeviceTunnelStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.GetDeviceTunnelStatusRequest = GetDeviceTunnelStatusRequest;
class GetDeviceTunnelStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetDeviceTunnelStatusResponseBody = GetDeviceTunnelStatusResponseBody;
class GetDeviceTunnelStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDeviceTunnelStatusResponseBody,
        };
    }
}
exports.GetDeviceTunnelStatusResponse = GetDeviceTunnelStatusResponse;
class GetDownloadFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            context: 'Context',
            iotInstanceId: 'IotInstanceId',
            longJobId: 'LongJobId',
        };
    }
    static types() {
        return {
            context: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            iotInstanceId: 'string',
            longJobId: 'string',
        };
    }
}
exports.GetDownloadFileRequest = GetDownloadFileRequest;
class GetDownloadFileShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contextShrink: 'Context',
            iotInstanceId: 'IotInstanceId',
            longJobId: 'LongJobId',
        };
    }
    static types() {
        return {
            contextShrink: 'string',
            iotInstanceId: 'string',
            longJobId: 'string',
        };
    }
}
exports.GetDownloadFileShrinkRequest = GetDownloadFileShrinkRequest;
class GetDownloadFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetDownloadFileResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetDownloadFileResponseBody = GetDownloadFileResponseBody;
class GetDownloadFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDownloadFileResponseBody,
        };
    }
}
exports.GetDownloadFileResponse = GetDownloadFileResponse;
class GetEdgeDriverVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            driverVersion: 'DriverVersion',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            driverVersion: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.GetEdgeDriverVersionRequest = GetEdgeDriverVersionRequest;
class GetEdgeDriverVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetEdgeDriverVersionResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetEdgeDriverVersionResponseBody = GetEdgeDriverVersionResponseBody;
class GetEdgeDriverVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetEdgeDriverVersionResponseBody,
        };
    }
}
exports.GetEdgeDriverVersionResponse = GetEdgeDriverVersionResponse;
class GetEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.GetEdgeInstanceRequest = GetEdgeInstanceRequest;
class GetEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetEdgeInstanceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetEdgeInstanceResponseBody = GetEdgeInstanceResponseBody;
class GetEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetEdgeInstanceResponseBody,
        };
    }
}
exports.GetEdgeInstanceResponse = GetEdgeInstanceResponse;
class GetEdgeInstanceDeploymentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deploymentId: 'DeploymentId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            deploymentId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.GetEdgeInstanceDeploymentRequest = GetEdgeInstanceDeploymentRequest;
class GetEdgeInstanceDeploymentResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetEdgeInstanceDeploymentResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetEdgeInstanceDeploymentResponseBody = GetEdgeInstanceDeploymentResponseBody;
class GetEdgeInstanceDeploymentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetEdgeInstanceDeploymentResponseBody,
        };
    }
}
exports.GetEdgeInstanceDeploymentResponse = GetEdgeInstanceDeploymentResponse;
class GetEdgeInstanceMessageRoutingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            routeId: 'RouteId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
            routeId: 'number',
        };
    }
}
exports.GetEdgeInstanceMessageRoutingRequest = GetEdgeInstanceMessageRoutingRequest;
class GetEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetEdgeInstanceMessageRoutingResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetEdgeInstanceMessageRoutingResponseBody = GetEdgeInstanceMessageRoutingResponseBody;
class GetEdgeInstanceMessageRoutingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetEdgeInstanceMessageRoutingResponseBody,
        };
    }
}
exports.GetEdgeInstanceMessageRoutingResponse = GetEdgeInstanceMessageRoutingResponse;
class GetGatewayBySubDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.GetGatewayBySubDeviceRequest = GetGatewayBySubDeviceRequest;
class GetGatewayBySubDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetGatewayBySubDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetGatewayBySubDeviceResponseBody = GetGatewayBySubDeviceResponseBody;
class GetGatewayBySubDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetGatewayBySubDeviceResponseBody,
        };
    }
}
exports.GetGatewayBySubDeviceResponse = GetGatewayBySubDeviceResponse;
class GetLoraNodesTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            taskId: 'string',
        };
    }
}
exports.GetLoraNodesTaskRequest = GetLoraNodesTaskRequest;
class GetLoraNodesTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
            successCount: 'SuccessCount',
            successDevEuis: 'SuccessDevEuis',
            taskId: 'TaskId',
            taskState: 'TaskState',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
            successCount: 'number',
            successDevEuis: GetLoraNodesTaskResponseBodySuccessDevEuis,
            taskId: 'string',
            taskState: 'string',
            totalCount: 'number',
        };
    }
}
exports.GetLoraNodesTaskResponseBody = GetLoraNodesTaskResponseBody;
class GetLoraNodesTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetLoraNodesTaskResponseBody,
        };
    }
}
exports.GetLoraNodesTaskResponse = GetLoraNodesTaskResponse;
class GetParserRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            parserId: 'number',
        };
    }
}
exports.GetParserRequest = GetParserRequest;
class GetParserResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetParserResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetParserResponseBody = GetParserResponseBody;
class GetParserResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetParserResponseBody,
        };
    }
}
exports.GetParserResponse = GetParserResponse;
class GetParserDataSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            iotInstanceId: 'string',
        };
    }
}
exports.GetParserDataSourceRequest = GetParserDataSourceRequest;
class GetParserDataSourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            dataSource: 'DataSource',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            dataSource: GetParserDataSourceResponseBodyDataSource,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetParserDataSourceResponseBody = GetParserDataSourceResponseBody;
class GetParserDataSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetParserDataSourceResponseBody,
        };
    }
}
exports.GetParserDataSourceResponse = GetParserDataSourceResponse;
class GetRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleId: 'number',
        };
    }
}
exports.GetRuleRequest = GetRuleRequest;
class GetRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            ruleInfo: 'RuleInfo',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            ruleInfo: GetRuleResponseBodyRuleInfo,
            success: 'boolean',
        };
    }
}
exports.GetRuleResponseBody = GetRuleResponseBody;
class GetRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetRuleResponseBody,
        };
    }
}
exports.GetRuleResponse = GetRuleResponse;
class GetRuleActionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionId: 'ActionId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            actionId: 'number',
            iotInstanceId: 'string',
        };
    }
}
exports.GetRuleActionRequest = GetRuleActionRequest;
class GetRuleActionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            ruleActionInfo: 'RuleActionInfo',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            ruleActionInfo: GetRuleActionResponseBodyRuleActionInfo,
            success: 'boolean',
        };
    }
}
exports.GetRuleActionResponseBody = GetRuleActionResponseBody;
class GetRuleActionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetRuleActionResponseBody,
        };
    }
}
exports.GetRuleActionResponse = GetRuleActionResponse;
class GetSceneRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleId: 'string',
        };
    }
}
exports.GetSceneRuleRequest = GetSceneRuleRequest;
class GetSceneRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetSceneRuleResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetSceneRuleResponseBody = GetSceneRuleResponseBody;
class GetSceneRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSceneRuleResponseBody,
        };
    }
}
exports.GetSceneRuleResponse = GetSceneRuleResponse;
class GetShareSpeechModelAudioRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            shareTaskId: 'ShareTaskId',
            speechModelCodeList: 'SpeechModelCodeList',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            shareTaskId: 'string',
            speechModelCodeList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetShareSpeechModelAudioRequest = GetShareSpeechModelAudioRequest;
class GetShareSpeechModelAudioResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetShareSpeechModelAudioResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetShareSpeechModelAudioResponseBody = GetShareSpeechModelAudioResponseBody;
class GetShareSpeechModelAudioResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetShareSpeechModelAudioResponseBody,
        };
    }
}
exports.GetShareSpeechModelAudioResponse = GetShareSpeechModelAudioResponse;
class GetShareTaskByDeviceOpenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.GetShareTaskByDeviceOpenRequest = GetShareTaskByDeviceOpenRequest;
class GetShareTaskByDeviceOpenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetShareTaskByDeviceOpenResponseBody = GetShareTaskByDeviceOpenResponseBody;
class GetShareTaskByDeviceOpenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetShareTaskByDeviceOpenResponseBody,
        };
    }
}
exports.GetShareTaskByDeviceOpenResponse = GetShareTaskByDeviceOpenResponse;
class GetSoundCodeAudioRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            soundCodeList: 'SoundCodeList',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            soundCodeList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetSoundCodeAudioRequest = GetSoundCodeAudioRequest;
class GetSoundCodeAudioResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetSoundCodeAudioResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetSoundCodeAudioResponseBody = GetSoundCodeAudioResponseBody;
class GetSoundCodeAudioResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSoundCodeAudioResponseBody,
        };
    }
}
exports.GetSoundCodeAudioResponse = GetSoundCodeAudioResponse;
class GetSoundCodeScheduleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            scheduleCode: 'ScheduleCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            scheduleCode: 'string',
        };
    }
}
exports.GetSoundCodeScheduleRequest = GetSoundCodeScheduleRequest;
class GetSoundCodeScheduleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetSoundCodeScheduleResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetSoundCodeScheduleResponseBody = GetSoundCodeScheduleResponseBody;
class GetSoundCodeScheduleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSoundCodeScheduleResponseBody,
        };
    }
}
exports.GetSoundCodeScheduleResponse = GetSoundCodeScheduleResponse;
class GetSpeechDeviceDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            iotId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.GetSpeechDeviceDetailRequest = GetSpeechDeviceDetailRequest;
class GetSpeechDeviceDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetSpeechDeviceDetailResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetSpeechDeviceDetailResponseBody = GetSpeechDeviceDetailResponseBody;
class GetSpeechDeviceDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSpeechDeviceDetailResponseBody,
        };
    }
}
exports.GetSpeechDeviceDetailResponse = GetSpeechDeviceDetailResponse;
class GetSpeechLicenseDeviceStatisticsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
        };
    }
}
exports.GetSpeechLicenseDeviceStatisticsRequest = GetSpeechLicenseDeviceStatisticsRequest;
class GetSpeechLicenseDeviceStatisticsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetSpeechLicenseDeviceStatisticsResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetSpeechLicenseDeviceStatisticsResponseBody = GetSpeechLicenseDeviceStatisticsResponseBody;
class GetSpeechLicenseDeviceStatisticsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSpeechLicenseDeviceStatisticsResponseBody,
        };
    }
}
exports.GetSpeechLicenseDeviceStatisticsResponse = GetSpeechLicenseDeviceStatisticsResponse;
class GetSpeechVoiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetSpeechVoiceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetSpeechVoiceResponseBody = GetSpeechVoiceResponseBody;
class GetSpeechVoiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSpeechVoiceResponseBody,
        };
    }
}
exports.GetSpeechVoiceResponse = GetSpeechVoiceResponse;
class GetStudioAppTokenOpenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            iotInstanceId: 'IotInstanceId',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            appId: 'string',
            iotInstanceId: 'string',
            projectId: 'string',
        };
    }
}
exports.GetStudioAppTokenOpenRequest = GetStudioAppTokenOpenRequest;
class GetStudioAppTokenOpenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetStudioAppTokenOpenResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetStudioAppTokenOpenResponseBody = GetStudioAppTokenOpenResponseBody;
class GetStudioAppTokenOpenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetStudioAppTokenOpenResponseBody,
        };
    }
}
exports.GetStudioAppTokenOpenResponse = GetStudioAppTokenOpenResponse;
class GetThingModelTslRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionBlockId: 'FunctionBlockId',
            iotInstanceId: 'IotInstanceId',
            modelVersion: 'ModelVersion',
            productKey: 'ProductKey',
            simple: 'Simple',
        };
    }
    static types() {
        return {
            functionBlockId: 'string',
            iotInstanceId: 'string',
            modelVersion: 'string',
            productKey: 'string',
            simple: 'boolean',
        };
    }
}
exports.GetThingModelTslRequest = GetThingModelTslRequest;
class GetThingModelTslResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetThingModelTslResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetThingModelTslResponseBody = GetThingModelTslResponseBody;
class GetThingModelTslResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetThingModelTslResponseBody,
        };
    }
}
exports.GetThingModelTslResponse = GetThingModelTslResponse;
class GetThingModelTslPublishedRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionBlockId: 'FunctionBlockId',
            iotInstanceId: 'IotInstanceId',
            modelVersion: 'ModelVersion',
            productKey: 'ProductKey',
            resourceGroupId: 'ResourceGroupId',
            simple: 'Simple',
        };
    }
    static types() {
        return {
            functionBlockId: 'string',
            iotInstanceId: 'string',
            modelVersion: 'string',
            productKey: 'string',
            resourceGroupId: 'string',
            simple: 'boolean',
        };
    }
}
exports.GetThingModelTslPublishedRequest = GetThingModelTslPublishedRequest;
class GetThingModelTslPublishedResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetThingModelTslPublishedResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetThingModelTslPublishedResponseBody = GetThingModelTslPublishedResponseBody;
class GetThingModelTslPublishedResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetThingModelTslPublishedResponseBody,
        };
    }
}
exports.GetThingModelTslPublishedResponse = GetThingModelTslPublishedResponse;
class GetThingScriptRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.GetThingScriptRequest = GetThingScriptRequest;
class GetThingScriptResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetThingScriptResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetThingScriptResponseBody = GetThingScriptResponseBody;
class GetThingScriptResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetThingScriptResponseBody,
        };
    }
}
exports.GetThingScriptResponse = GetThingScriptResponse;
class GetThingTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            categoryKey: 'CategoryKey',
            iotInstanceId: 'IotInstanceId',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            categoryKey: 'string',
            iotInstanceId: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.GetThingTemplateRequest = GetThingTemplateRequest;
class GetThingTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
            thingModelJSON: 'ThingModelJSON',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
            thingModelJSON: 'string',
        };
    }
}
exports.GetThingTemplateResponseBody = GetThingTemplateResponseBody;
class GetThingTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetThingTemplateResponseBody,
        };
    }
}
exports.GetThingTemplateResponse = GetThingTemplateResponse;
class GetThingTopoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            pageNo: 'number',
            pageSize: 'number',
            productKey: 'string',
        };
    }
}
exports.GetThingTopoRequest = GetThingTopoRequest;
class GetThingTopoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetThingTopoResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetThingTopoResponseBody = GetThingTopoResponseBody;
class GetThingTopoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetThingTopoResponseBody,
        };
    }
}
exports.GetThingTopoResponse = GetThingTopoResponse;
class GisQueryDeviceLocationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            thingList: 'ThingList',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            thingList: { 'type': 'array', 'itemType': GisQueryDeviceLocationRequestThingList },
        };
    }
}
exports.GisQueryDeviceLocationRequest = GisQueryDeviceLocationRequest;
class GisQueryDeviceLocationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: { 'type': 'array', 'itemType': GisQueryDeviceLocationResponseBodyData },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GisQueryDeviceLocationResponseBody = GisQueryDeviceLocationResponseBody;
class GisQueryDeviceLocationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GisQueryDeviceLocationResponseBody,
        };
    }
}
exports.GisQueryDeviceLocationResponse = GisQueryDeviceLocationResponse;
class GisSearchDeviceTraceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            endTime: 'EndTime',
            iotInstanceId: 'IotInstanceId',
            mapMatch: 'MapMatch',
            productKey: 'ProductKey',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            endTime: 'number',
            iotInstanceId: 'string',
            mapMatch: 'number',
            productKey: 'string',
            startTime: 'number',
        };
    }
}
exports.GisSearchDeviceTraceRequest = GisSearchDeviceTraceRequest;
class GisSearchDeviceTraceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GisSearchDeviceTraceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GisSearchDeviceTraceResponseBody = GisSearchDeviceTraceResponseBody;
class GisSearchDeviceTraceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GisSearchDeviceTraceResponseBody,
        };
    }
}
exports.GisSearchDeviceTraceResponse = GisSearchDeviceTraceResponse;
class ImportDTDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DTInstanceId: 'DTInstanceId',
            iotInstanceId: 'IotInstanceId',
            items: 'Items',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            DTInstanceId: 'string',
            iotInstanceId: 'string',
            items: { 'type': 'array', 'itemType': ImportDTDataRequestItems },
            productKey: 'string',
        };
    }
}
exports.ImportDTDataRequest = ImportDTDataRequest;
class ImportDTDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ImportDTDataResponseBody = ImportDTDataResponseBody;
class ImportDTDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ImportDTDataResponseBody,
        };
    }
}
exports.ImportDTDataResponse = ImportDTDataResponse;
class ImportDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            iotInstanceId: 'IotInstanceId',
            nickname: 'Nickname',
            productKey: 'ProductKey',
            sn: 'Sn',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            iotInstanceId: 'string',
            nickname: 'string',
            productKey: 'string',
            sn: 'string',
        };
    }
}
exports.ImportDeviceRequest = ImportDeviceRequest;
class ImportDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ImportDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ImportDeviceResponseBody = ImportDeviceResponseBody;
class ImportDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ImportDeviceResponseBody,
        };
    }
}
exports.ImportDeviceResponse = ImportDeviceResponse;
class ImportThingModelTslRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionBlockId: 'FunctionBlockId',
            functionBlockName: 'FunctionBlockName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            resourceGroupId: 'ResourceGroupId',
            tslStr: 'TslStr',
            tslUrl: 'TslUrl',
        };
    }
    static types() {
        return {
            functionBlockId: 'string',
            functionBlockName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            resourceGroupId: 'string',
            tslStr: 'string',
            tslUrl: 'string',
        };
    }
}
exports.ImportThingModelTslRequest = ImportThingModelTslRequest;
class ImportThingModelTslResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ImportThingModelTslResponseBody = ImportThingModelTslResponseBody;
class ImportThingModelTslResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ImportThingModelTslResponseBody,
        };
    }
}
exports.ImportThingModelTslResponse = ImportThingModelTslResponse;
class InvokeDataAPIServiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiSrn: 'ApiSrn',
            iotInstanceId: 'IotInstanceId',
            param: 'Param',
        };
    }
    static types() {
        return {
            apiSrn: 'string',
            iotInstanceId: 'string',
            param: { 'type': 'array', 'itemType': InvokeDataAPIServiceRequestParam },
        };
    }
}
exports.InvokeDataAPIServiceRequest = InvokeDataAPIServiceRequest;
class InvokeDataAPIServiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: InvokeDataAPIServiceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.InvokeDataAPIServiceResponseBody = InvokeDataAPIServiceResponseBody;
class InvokeDataAPIServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InvokeDataAPIServiceResponseBody,
        };
    }
}
exports.InvokeDataAPIServiceResponse = InvokeDataAPIServiceResponse;
class InvokeThingServiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            args: 'Args',
            deviceName: 'DeviceName',
            identifier: 'Identifier',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            args: 'string',
            deviceName: 'string',
            identifier: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.InvokeThingServiceRequest = InvokeThingServiceRequest;
class InvokeThingServiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: InvokeThingServiceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.InvokeThingServiceResponseBody = InvokeThingServiceResponseBody;
class InvokeThingServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InvokeThingServiceResponseBody,
        };
    }
}
exports.InvokeThingServiceResponse = InvokeThingServiceResponse;
class InvokeThingsServiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            args: 'Args',
            deviceName: 'DeviceName',
            identifier: 'Identifier',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            args: 'string',
            deviceName: { 'type': 'array', 'itemType': 'string' },
            identifier: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.InvokeThingsServiceRequest = InvokeThingsServiceRequest;
class InvokeThingsServiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.InvokeThingsServiceResponseBody = InvokeThingsServiceResponseBody;
class InvokeThingsServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InvokeThingsServiceResponseBody,
        };
    }
}
exports.InvokeThingsServiceResponse = InvokeThingsServiceResponse;
class ListAnalyticsDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiPath: 'ApiPath',
            condition: 'Condition',
            iotInstanceId: 'IotInstanceId',
            isoId: 'IsoId',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            apiPath: 'string',
            condition: { 'type': 'array', 'itemType': ListAnalyticsDataRequestCondition },
            iotInstanceId: 'string',
            isoId: 'string',
            pageNum: 'number',
            pageSize: 'number',
        };
    }
}
exports.ListAnalyticsDataRequest = ListAnalyticsDataRequest;
class ListAnalyticsDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListAnalyticsDataResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListAnalyticsDataResponseBody = ListAnalyticsDataResponseBody;
class ListAnalyticsDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListAnalyticsDataResponseBody,
        };
    }
}
exports.ListAnalyticsDataResponse = ListAnalyticsDataResponse;
class ListDataSourceItemRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            iotInstanceId: 'IotInstanceId',
            page: 'Page',
            pageSize: 'PageSize',
            searchName: 'SearchName',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            iotInstanceId: 'string',
            page: 'number',
            pageSize: 'number',
            searchName: 'string',
        };
    }
}
exports.ListDataSourceItemRequest = ListDataSourceItemRequest;
class ListDataSourceItemResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            dataSourceItems: 'DataSourceItems',
            errorMessage: 'ErrorMessage',
            page: 'Page',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            dataSourceItems: ListDataSourceItemResponseBodyDataSourceItems,
            errorMessage: 'string',
            page: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListDataSourceItemResponseBody = ListDataSourceItemResponseBody;
class ListDataSourceItemResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListDataSourceItemResponseBody,
        };
    }
}
exports.ListDataSourceItemResponse = ListDataSourceItemResponse;
class ListDestinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            page: 'Page',
            pageSize: 'PageSize',
            searchName: 'SearchName',
            types: 'Types',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            page: 'number',
            pageSize: 'number',
            searchName: 'string',
            types: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ListDestinationRequest = ListDestinationRequest;
class ListDestinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            destinations: 'Destinations',
            errorMessage: 'ErrorMessage',
            page: 'Page',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            destinations: ListDestinationResponseBodyDestinations,
            errorMessage: 'string',
            page: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListDestinationResponseBody = ListDestinationResponseBody;
class ListDestinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListDestinationResponseBody,
        };
    }
}
exports.ListDestinationResponse = ListDestinationResponse;
class ListDeviceDistributeJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            jobId: 'JobId',
            nextToken: 'NextToken',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            status: 'Status',
            targetUid: 'TargetUid',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            jobId: 'string',
            nextToken: 'string',
            pageSize: 'number',
            productKey: 'string',
            status: 'number',
            targetUid: 'string',
        };
    }
}
exports.ListDeviceDistributeJobRequest = ListDeviceDistributeJobRequest;
class ListDeviceDistributeJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListDeviceDistributeJobResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListDeviceDistributeJobResponseBody = ListDeviceDistributeJobResponseBody;
class ListDeviceDistributeJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListDeviceDistributeJobResponseBody,
        };
    }
}
exports.ListDeviceDistributeJobResponse = ListDeviceDistributeJobResponse;
class ListDistributedDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            deviceName: 'DeviceName',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            sourceInstanceId: 'SourceInstanceId',
            targetUid: 'TargetUid',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            deviceName: 'string',
            pageSize: 'number',
            productKey: 'string',
            sourceInstanceId: 'string',
            targetUid: 'string',
        };
    }
}
exports.ListDistributedDeviceRequest = ListDistributedDeviceRequest;
class ListDistributedDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListDistributedDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListDistributedDeviceResponseBody = ListDistributedDeviceResponseBody;
class ListDistributedDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListDistributedDeviceResponseBody,
        };
    }
}
exports.ListDistributedDeviceResponse = ListDistributedDeviceResponse;
class ListDistributedProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            sourceInstanceId: 'SourceInstanceId',
            targetInstanceId: 'TargetInstanceId',
            targetUid: 'TargetUid',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            pageSize: 'number',
            productKey: 'string',
            sourceInstanceId: 'string',
            targetInstanceId: 'string',
            targetUid: 'string',
        };
    }
}
exports.ListDistributedProductRequest = ListDistributedProductRequest;
class ListDistributedProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListDistributedProductResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListDistributedProductResponseBody = ListDistributedProductResponseBody;
class ListDistributedProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListDistributedProductResponseBody,
        };
    }
}
exports.ListDistributedProductResponse = ListDistributedProductResponse;
class ListJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            status: 'Status',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            status: 'string',
        };
    }
}
exports.ListJobRequest = ListJobRequest;
class ListJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            page: 'Page',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListJobResponseBodyData,
            errorMessage: 'string',
            page: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListJobResponseBody = ListJobResponseBody;
class ListJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListJobResponseBody,
        };
    }
}
exports.ListJobResponse = ListJobResponse;
class ListOTAFirmwareRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            destVersion: 'DestVersion',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            destVersion: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            productKey: 'string',
        };
    }
}
exports.ListOTAFirmwareRequest = ListOTAFirmwareRequest;
class ListOTAFirmwareResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            currentPage: 'CurrentPage',
            errorMessage: 'ErrorMessage',
            firmwareInfo: 'FirmwareInfo',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            currentPage: 'number',
            errorMessage: 'string',
            firmwareInfo: ListOTAFirmwareResponseBodyFirmwareInfo,
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListOTAFirmwareResponseBody = ListOTAFirmwareResponseBody;
class ListOTAFirmwareResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListOTAFirmwareResponseBody,
        };
    }
}
exports.ListOTAFirmwareResponse = ListOTAFirmwareResponse;
class ListOTAJobByDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            deviceName: 'DeviceName',
            firmwareId: 'FirmwareId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            deviceName: 'string',
            firmwareId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            productKey: 'string',
        };
    }
}
exports.ListOTAJobByDeviceRequest = ListOTAJobByDeviceRequest;
class ListOTAJobByDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            currentPage: 'CurrentPage',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            currentPage: 'number',
            data: ListOTAJobByDeviceResponseBodyData,
            errorMessage: 'string',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListOTAJobByDeviceResponseBody = ListOTAJobByDeviceResponseBody;
class ListOTAJobByDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListOTAJobByDeviceResponseBody,
        };
    }
}
exports.ListOTAJobByDeviceResponse = ListOTAJobByDeviceResponse;
class ListOTAJobByFirmwareRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            firmwareId: 'FirmwareId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            firmwareId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
        };
    }
}
exports.ListOTAJobByFirmwareRequest = ListOTAJobByFirmwareRequest;
class ListOTAJobByFirmwareResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            currentPage: 'CurrentPage',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            currentPage: 'number',
            data: ListOTAJobByFirmwareResponseBodyData,
            errorMessage: 'string',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListOTAJobByFirmwareResponseBody = ListOTAJobByFirmwareResponseBody;
class ListOTAJobByFirmwareResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListOTAJobByFirmwareResponseBody,
        };
    }
}
exports.ListOTAJobByFirmwareResponse = ListOTAJobByFirmwareResponse;
class ListOTAModuleByProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.ListOTAModuleByProductRequest = ListOTAModuleByProductRequest;
class ListOTAModuleByProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: { 'type': 'array', 'itemType': ListOTAModuleByProductResponseBodyData },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListOTAModuleByProductResponseBody = ListOTAModuleByProductResponseBody;
class ListOTAModuleByProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListOTAModuleByProductResponseBody,
        };
    }
}
exports.ListOTAModuleByProductResponse = ListOTAModuleByProductResponse;
class ListOTAModuleVersionsByDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            productKey: 'string',
        };
    }
}
exports.ListOTAModuleVersionsByDeviceRequest = ListOTAModuleVersionsByDeviceRequest;
class ListOTAModuleVersionsByDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            currentPage: 'CurrentPage',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            currentPage: 'number',
            data: ListOTAModuleVersionsByDeviceResponseBodyData,
            errorMessage: 'string',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListOTAModuleVersionsByDeviceResponseBody = ListOTAModuleVersionsByDeviceResponseBody;
class ListOTAModuleVersionsByDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListOTAModuleVersionsByDeviceResponseBody,
        };
    }
}
exports.ListOTAModuleVersionsByDeviceResponse = ListOTAModuleVersionsByDeviceResponse;
class ListOTATaskByJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            deviceNames: 'DeviceNames',
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
            pageSize: 'PageSize',
            taskStatus: 'TaskStatus',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            deviceNames: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            jobId: 'string',
            pageSize: 'number',
            taskStatus: 'string',
        };
    }
}
exports.ListOTATaskByJobRequest = ListOTATaskByJobRequest;
class ListOTATaskByJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            currentPage: 'CurrentPage',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            currentPage: 'number',
            data: ListOTATaskByJobResponseBodyData,
            errorMessage: 'string',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListOTATaskByJobResponseBody = ListOTATaskByJobResponseBody;
class ListOTATaskByJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListOTATaskByJobResponseBody,
        };
    }
}
exports.ListOTATaskByJobResponse = ListOTATaskByJobResponse;
class ListOTAUnfinishedTaskByDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            moduleName: 'ModuleName',
            productKey: 'ProductKey',
            taskStatus: 'TaskStatus',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            moduleName: 'string',
            productKey: 'string',
            taskStatus: 'string',
        };
    }
}
exports.ListOTAUnfinishedTaskByDeviceRequest = ListOTAUnfinishedTaskByDeviceRequest;
class ListOTAUnfinishedTaskByDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListOTAUnfinishedTaskByDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListOTAUnfinishedTaskByDeviceResponseBody = ListOTAUnfinishedTaskByDeviceResponseBody;
class ListOTAUnfinishedTaskByDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListOTAUnfinishedTaskByDeviceResponseBody,
        };
    }
}
exports.ListOTAUnfinishedTaskByDeviceResponse = ListOTAUnfinishedTaskByDeviceResponse;
class ListParserRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            searchName: 'SearchName',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            searchName: 'string',
        };
    }
}
exports.ListParserRequest = ListParserRequest;
class ListParserResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListParserResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListParserResponseBody = ListParserResponseBody;
class ListParserResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListParserResponseBody,
        };
    }
}
exports.ListParserResponse = ListParserResponse;
class ListParserDataSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            page: 'Page',
            pageSize: 'PageSize',
            searchName: 'SearchName',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            page: 'number',
            pageSize: 'number',
            searchName: 'string',
        };
    }
}
exports.ListParserDataSourceRequest = ListParserDataSourceRequest;
class ListParserDataSourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            page: 'Page',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListParserDataSourceResponseBodyData,
            errorMessage: 'string',
            page: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListParserDataSourceResponseBody = ListParserDataSourceResponseBody;
class ListParserDataSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListParserDataSourceResponseBody,
        };
    }
}
exports.ListParserDataSourceResponse = ListParserDataSourceResponse;
class ListParserDestinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            isFailover: 'IsFailover',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            isFailover: 'boolean',
            parserId: 'number',
        };
    }
}
exports.ListParserDestinationRequest = ListParserDestinationRequest;
class ListParserDestinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListParserDestinationResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListParserDestinationResponseBody = ListParserDestinationResponseBody;
class ListParserDestinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListParserDestinationResponseBody,
        };
    }
}
exports.ListParserDestinationResponse = ListParserDestinationResponse;
class ListProductByTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            productTag: 'ProductTag',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            productTag: { 'type': 'array', 'itemType': ListProductByTagsRequestProductTag },
        };
    }
}
exports.ListProductByTagsRequest = ListProductByTagsRequest;
class ListProductByTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            productInfos: 'ProductInfos',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            productInfos: ListProductByTagsResponseBodyProductInfos,
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListProductByTagsResponseBody = ListProductByTagsResponseBody;
class ListProductByTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListProductByTagsResponseBody,
        };
    }
}
exports.ListProductByTagsResponse = ListProductByTagsResponse;
class ListProductTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.ListProductTagsRequest = ListProductTagsRequest;
class ListProductTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListProductTagsResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListProductTagsResponseBody = ListProductTagsResponseBody;
class ListProductTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListProductTagsResponseBody,
        };
    }
}
exports.ListProductTagsResponse = ListProductTagsResponse;
class ListRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            resourceGroupId: 'string',
        };
    }
}
exports.ListRuleRequest = ListRuleRequest;
class ListRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            page: 'Page',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListRuleResponseBodyData,
            errorMessage: 'string',
            page: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.ListRuleResponseBody = ListRuleResponseBody;
class ListRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListRuleResponseBody,
        };
    }
}
exports.ListRuleResponse = ListRuleResponse;
class ListRuleActionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleId: 'number',
        };
    }
}
exports.ListRuleActionsRequest = ListRuleActionsRequest;
class ListRuleActionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            ruleActionList: 'RuleActionList',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            ruleActionList: ListRuleActionsResponseBodyRuleActionList,
            success: 'boolean',
        };
    }
}
exports.ListRuleActionsResponseBody = ListRuleActionsResponseBody;
class ListRuleActionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListRuleActionsResponseBody,
        };
    }
}
exports.ListRuleActionsResponse = ListRuleActionsResponse;
class ListTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            device: 'Device',
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
            limit: 'Limit',
            nextToken: 'NextToken',
            status: 'Status',
        };
    }
    static types() {
        return {
            device: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            iotInstanceId: 'string',
            jobId: 'string',
            limit: 'number',
            nextToken: 'string',
            status: 'string',
        };
    }
}
exports.ListTaskRequest = ListTaskRequest;
class ListTaskShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceShrink: 'Device',
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
            limit: 'Limit',
            nextToken: 'NextToken',
            status: 'Status',
        };
    }
    static types() {
        return {
            deviceShrink: 'string',
            iotInstanceId: 'string',
            jobId: 'string',
            limit: 'number',
            nextToken: 'string',
            status: 'string',
        };
    }
}
exports.ListTaskShrinkRequest = ListTaskShrinkRequest;
class ListTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            nextToken: 'NextToken',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListTaskResponseBodyData,
            errorMessage: 'string',
            nextToken: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListTaskResponseBody = ListTaskResponseBody;
class ListTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListTaskResponseBody,
        };
    }
}
exports.ListTaskResponse = ListTaskResponse;
class ListThingModelVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.ListThingModelVersionRequest = ListThingModelVersionRequest;
class ListThingModelVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListThingModelVersionResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListThingModelVersionResponseBody = ListThingModelVersionResponseBody;
class ListThingModelVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListThingModelVersionResponseBody,
        };
    }
}
exports.ListThingModelVersionResponse = ListThingModelVersionResponse;
class ListThingTemplatesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
        };
    }
}
exports.ListThingTemplatesRequest = ListThingTemplatesRequest;
class ListThingTemplatesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: { 'type': 'array', 'itemType': ListThingTemplatesResponseBodyData },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ListThingTemplatesResponseBody = ListThingTemplatesResponseBody;
class ListThingTemplatesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListThingTemplatesResponseBody,
        };
    }
}
exports.ListThingTemplatesResponse = ListThingTemplatesResponse;
class NotifyAddThingTopoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceListStr: 'DeviceListStr',
            gwDeviceName: 'GwDeviceName',
            gwIotId: 'GwIotId',
            gwProductKey: 'GwProductKey',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            deviceListStr: 'string',
            gwDeviceName: 'string',
            gwIotId: 'string',
            gwProductKey: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.NotifyAddThingTopoRequest = NotifyAddThingTopoRequest;
class NotifyAddThingTopoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: NotifyAddThingTopoResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.NotifyAddThingTopoResponseBody = NotifyAddThingTopoResponseBody;
class NotifyAddThingTopoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: NotifyAddThingTopoResponseBody,
        };
    }
}
exports.NotifyAddThingTopoResponse = NotifyAddThingTopoResponse;
class OpenIotServiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
        };
    }
}
exports.OpenIotServiceRequest = OpenIotServiceRequest;
class OpenIotServiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            orderId: 'string',
            requestId: 'string',
        };
    }
}
exports.OpenIotServiceResponseBody = OpenIotServiceResponseBody;
class OpenIotServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OpenIotServiceResponseBody,
        };
    }
}
exports.OpenIotServiceResponse = OpenIotServiceResponse;
class PackageSoundCodeLabelBatchAudioRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            batchCode: 'BatchCode',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            batchCode: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.PackageSoundCodeLabelBatchAudioRequest = PackageSoundCodeLabelBatchAudioRequest;
class PackageSoundCodeLabelBatchAudioResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.PackageSoundCodeLabelBatchAudioResponseBody = PackageSoundCodeLabelBatchAudioResponseBody;
class PackageSoundCodeLabelBatchAudioResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PackageSoundCodeLabelBatchAudioResponseBody,
        };
    }
}
exports.PackageSoundCodeLabelBatchAudioResponse = PackageSoundCodeLabelBatchAudioResponse;
class PageQuerySharedSpeechOpenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            shareTaskCode: 'ShareTaskCode',
            status: 'Status',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
            productKey: 'string',
            shareTaskCode: 'string',
            status: 'number',
        };
    }
}
exports.PageQuerySharedSpeechOpenRequest = PageQuerySharedSpeechOpenRequest;
class PageQuerySharedSpeechOpenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: PageQuerySharedSpeechOpenResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.PageQuerySharedSpeechOpenResponseBody = PageQuerySharedSpeechOpenResponseBody;
class PageQuerySharedSpeechOpenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PageQuerySharedSpeechOpenResponseBody,
        };
    }
}
exports.PageQuerySharedSpeechOpenResponse = PageQuerySharedSpeechOpenResponse;
class PageQuerySpeechBroadcastHourRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            pageToken: 'PageToken',
            queryDateTimeHour: 'QueryDateTimeHour',
            shareTaskCode: 'ShareTaskCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            pageSize: 'number',
            pageToken: 'string',
            queryDateTimeHour: 'string',
            shareTaskCode: 'string',
        };
    }
}
exports.PageQuerySpeechBroadcastHourRequest = PageQuerySpeechBroadcastHourRequest;
class PageQuerySpeechBroadcastHourResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: PageQuerySpeechBroadcastHourResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.PageQuerySpeechBroadcastHourResponseBody = PageQuerySpeechBroadcastHourResponseBody;
class PageQuerySpeechBroadcastHourResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PageQuerySpeechBroadcastHourResponseBody,
        };
    }
}
exports.PageQuerySpeechBroadcastHourResponse = PageQuerySpeechBroadcastHourResponse;
class PrintByTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            historyPrintTopic: 'HistoryPrintTopic',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            paramsJsonString: 'ParamsJsonString',
            productKey: 'ProductKey',
            templateBizCode: 'TemplateBizCode',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            historyPrintTopic: 'boolean',
            iotId: 'string',
            iotInstanceId: 'string',
            paramsJsonString: 'string',
            productKey: 'string',
            templateBizCode: 'string',
        };
    }
}
exports.PrintByTemplateRequest = PrintByTemplateRequest;
class PrintByTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: PrintByTemplateResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.PrintByTemplateResponseBody = PrintByTemplateResponseBody;
class PrintByTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PrintByTemplateResponseBody,
        };
    }
}
exports.PrintByTemplateResponse = PrintByTemplateResponse;
class PubRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'ContentType',
            correlationData: 'CorrelationData',
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            messageContent: 'MessageContent',
            messageExpiryInterval: 'MessageExpiryInterval',
            payloadFormatIndicator: 'PayloadFormatIndicator',
            productKey: 'ProductKey',
            qos: 'Qos',
            responseTopic: 'ResponseTopic',
            retained: 'Retained',
            topicFullName: 'TopicFullName',
            userProp: 'UserProp',
        };
    }
    static types() {
        return {
            contentType: 'string',
            correlationData: 'string',
            deviceName: 'string',
            iotInstanceId: 'string',
            messageContent: 'string',
            messageExpiryInterval: 'number',
            payloadFormatIndicator: 'number',
            productKey: 'string',
            qos: 'number',
            responseTopic: 'string',
            retained: 'boolean',
            topicFullName: 'string',
            userProp: { 'type': 'array', 'itemType': PubRequestUserProp },
        };
    }
}
exports.PubRequest = PubRequest;
class PubResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            messageId: 'MessageId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            messageId: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.PubResponseBody = PubResponseBody;
class PubResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PubResponseBody,
        };
    }
}
exports.PubResponse = PubResponse;
class PubBroadcastRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            messageContent: 'MessageContent',
            productKey: 'ProductKey',
            topicFullName: 'TopicFullName',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            messageContent: 'string',
            productKey: 'string',
            topicFullName: 'string',
        };
    }
}
exports.PubBroadcastRequest = PubBroadcastRequest;
class PubBroadcastResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            messageId: 'MessageId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            messageId: 'number',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.PubBroadcastResponseBody = PubBroadcastResponseBody;
class PubBroadcastResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PubBroadcastResponseBody,
        };
    }
}
exports.PubBroadcastResponse = PubBroadcastResponse;
class PublishScriptRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            parserId: 'number',
        };
    }
}
exports.PublishScriptRequest = PublishScriptRequest;
class PublishScriptResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
            syntaxErrorMsg: 'SyntaxErrorMsg',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
            syntaxErrorMsg: 'string',
        };
    }
}
exports.PublishScriptResponseBody = PublishScriptResponseBody;
class PublishScriptResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PublishScriptResponseBody,
        };
    }
}
exports.PublishScriptResponse = PublishScriptResponse;
class PublishStudioAppRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            appId: 'string',
            description: 'string',
            iotInstanceId: 'string',
            projectId: 'string',
        };
    }
}
exports.PublishStudioAppRequest = PublishStudioAppRequest;
class PublishStudioAppResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.PublishStudioAppResponseBody = PublishStudioAppResponseBody;
class PublishStudioAppResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PublishStudioAppResponseBody,
        };
    }
}
exports.PublishStudioAppResponse = PublishStudioAppResponse;
class PublishThingModelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            modelVersion: 'ModelVersion',
            productKey: 'ProductKey',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            modelVersion: 'string',
            productKey: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.PublishThingModelRequest = PublishThingModelRequest;
class PublishThingModelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.PublishThingModelResponseBody = PublishThingModelResponseBody;
class PublishThingModelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PublishThingModelResponseBody,
        };
    }
}
exports.PublishThingModelResponse = PublishThingModelResponse;
class PushSpeechRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            groupId: 'GroupId',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            projectCode: 'ProjectCode',
            pushMode: 'PushMode',
            speechCodeList: 'SpeechCodeList',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            groupId: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            projectCode: 'string',
            pushMode: 'string',
            speechCodeList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.PushSpeechRequest = PushSpeechRequest;
class PushSpeechResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.PushSpeechResponseBody = PushSpeechResponseBody;
class PushSpeechResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PushSpeechResponseBody,
        };
    }
}
exports.PushSpeechResponse = PushSpeechResponse;
class QueryBatchRegisterDeviceStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyId: 'ApplyId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            applyId: 'number',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryBatchRegisterDeviceStatusRequest = QueryBatchRegisterDeviceStatusRequest;
class QueryBatchRegisterDeviceStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryBatchRegisterDeviceStatusResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryBatchRegisterDeviceStatusResponseBody = QueryBatchRegisterDeviceStatusResponseBody;
class QueryBatchRegisterDeviceStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryBatchRegisterDeviceStatusResponseBody,
        };
    }
}
exports.QueryBatchRegisterDeviceStatusResponse = QueryBatchRegisterDeviceStatusResponse;
class QueryCertUrlByApplyIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyId: 'ApplyId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            applyId: 'number',
            iotInstanceId: 'string',
        };
    }
}
exports.QueryCertUrlByApplyIdRequest = QueryCertUrlByApplyIdRequest;
class QueryCertUrlByApplyIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            certUrl: 'CertUrl',
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            certUrl: 'string',
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryCertUrlByApplyIdResponseBody = QueryCertUrlByApplyIdResponseBody;
class QueryCertUrlByApplyIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCertUrlByApplyIdResponseBody,
        };
    }
}
exports.QueryCertUrlByApplyIdResponse = QueryCertUrlByApplyIdResponse;
class QueryClientIdsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            iotId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.QueryClientIdsRequest = QueryClientIdsRequest;
class QueryClientIdsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryClientIdsResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryClientIdsResponseBody = QueryClientIdsResponseBody;
class QueryClientIdsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryClientIdsResponseBody,
        };
    }
}
exports.QueryClientIdsResponse = QueryClientIdsResponse;
class QueryConsumerGroupByGroupIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            groupId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.QueryConsumerGroupByGroupIdRequest = QueryConsumerGroupByGroupIdRequest;
class QueryConsumerGroupByGroupIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryConsumerGroupByGroupIdResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryConsumerGroupByGroupIdResponseBody = QueryConsumerGroupByGroupIdResponseBody;
class QueryConsumerGroupByGroupIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConsumerGroupByGroupIdResponseBody,
        };
    }
}
exports.QueryConsumerGroupByGroupIdResponse = QueryConsumerGroupByGroupIdResponse;
class QueryConsumerGroupListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            fuzzy: 'Fuzzy',
            groupName: 'GroupName',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            subBizCode: 'SubBizCode',
            type: 'Type',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            fuzzy: 'boolean',
            groupName: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            subBizCode: 'string',
            type: 'string',
        };
    }
}
exports.QueryConsumerGroupListRequest = QueryConsumerGroupListRequest;
class QueryConsumerGroupListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            currentPage: 'CurrentPage',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            currentPage: 'number',
            data: QueryConsumerGroupListResponseBodyData,
            errorMessage: 'string',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryConsumerGroupListResponseBody = QueryConsumerGroupListResponseBody;
class QueryConsumerGroupListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConsumerGroupListResponseBody,
        };
    }
}
exports.QueryConsumerGroupListResponse = QueryConsumerGroupListResponse;
class QueryConsumerGroupStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            groupId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.QueryConsumerGroupStatusRequest = QueryConsumerGroupStatusRequest;
class QueryConsumerGroupStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accumulatedConsumeCountPerMinute: 'AccumulatedConsumeCountPerMinute',
            accumulationCount: 'AccumulationCount',
            clientConnectionStatusList: 'ClientConnectionStatusList',
            code: 'Code',
            consumerSpeed: 'ConsumerSpeed',
            errorMessage: 'ErrorMessage',
            lastConsumerTime: 'LastConsumerTime',
            realTimeConsumeCountPerMinute: 'RealTimeConsumeCountPerMinute',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            accumulatedConsumeCountPerMinute: 'number',
            accumulationCount: 'number',
            clientConnectionStatusList: QueryConsumerGroupStatusResponseBodyClientConnectionStatusList,
            code: 'string',
            consumerSpeed: 'number',
            errorMessage: 'string',
            lastConsumerTime: 'string',
            realTimeConsumeCountPerMinute: 'number',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryConsumerGroupStatusResponseBody = QueryConsumerGroupStatusResponseBody;
class QueryConsumerGroupStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConsumerGroupStatusResponseBody,
        };
    }
}
exports.QueryConsumerGroupStatusResponse = QueryConsumerGroupStatusResponse;
class QueryDetailSceneRuleLogRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            endTime: 'EndTime',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            ruleId: 'RuleId',
            startTime: 'StartTime',
            traceId: 'TraceId',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            endTime: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            ruleId: 'string',
            startTime: 'number',
            traceId: 'string',
        };
    }
}
exports.QueryDetailSceneRuleLogRequest = QueryDetailSceneRuleLogRequest;
class QueryDetailSceneRuleLogResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDetailSceneRuleLogResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDetailSceneRuleLogResponseBody = QueryDetailSceneRuleLogResponseBody;
class QueryDetailSceneRuleLogResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDetailSceneRuleLogResponseBody,
        };
    }
}
exports.QueryDetailSceneRuleLogResponse = QueryDetailSceneRuleLogResponse;
class QueryDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            nextToken: 'NextToken',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            iotInstanceId: 'string',
            nextToken: 'string',
            pageSize: 'number',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceRequest = QueryDeviceRequest;
class QueryDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            nextToken: 'NextToken',
            page: 'Page',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceResponseBodyData,
            errorMessage: 'string',
            nextToken: 'string',
            page: 'number',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryDeviceResponseBody = QueryDeviceResponseBody;
class QueryDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceResponseBody,
        };
    }
}
exports.QueryDeviceResponse = QueryDeviceResponse;
class QueryDeviceBySQLRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            SQL: 'SQL',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            SQL: 'string',
        };
    }
}
exports.QueryDeviceBySQLRequest = QueryDeviceBySQLRequest;
class QueryDeviceBySQLResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            code: 'string',
            data: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyData },
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
            totalCount: 'number',
        };
    }
}
exports.QueryDeviceBySQLResponseBody = QueryDeviceBySQLResponseBody;
class QueryDeviceBySQLResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceBySQLResponseBody,
        };
    }
}
exports.QueryDeviceBySQLResponse = QueryDeviceBySQLResponse;
class QueryDeviceByStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            resourceGroupId: 'ResourceGroupId',
            status: 'Status',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            productKey: 'string',
            resourceGroupId: 'string',
            status: 'number',
        };
    }
}
exports.QueryDeviceByStatusRequest = QueryDeviceByStatusRequest;
class QueryDeviceByStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            page: 'Page',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceByStatusResponseBodyData,
            errorMessage: 'string',
            page: 'number',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryDeviceByStatusResponseBody = QueryDeviceByStatusResponseBody;
class QueryDeviceByStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceByStatusResponseBody,
        };
    }
}
exports.QueryDeviceByStatusResponse = QueryDeviceByStatusResponse;
class QueryDeviceByTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            tag: { 'type': 'array', 'itemType': QueryDeviceByTagsRequestTag },
        };
    }
}
exports.QueryDeviceByTagsRequest = QueryDeviceByTagsRequest;
class QueryDeviceByTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            page: 'Page',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceByTagsResponseBodyData,
            errorMessage: 'string',
            page: 'number',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryDeviceByTagsResponseBody = QueryDeviceByTagsResponseBody;
class QueryDeviceByTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceByTagsResponseBody,
        };
    }
}
exports.QueryDeviceByTagsResponse = QueryDeviceByTagsResponse;
class QueryDeviceCertRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceCertRequest = QueryDeviceCertRequest;
class QueryDeviceCertResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            deviceCertInfo: 'DeviceCertInfo',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            deviceCertInfo: QueryDeviceCertResponseBodyDeviceCertInfo,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceCertResponseBody = QueryDeviceCertResponseBody;
class QueryDeviceCertResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceCertResponseBody,
        };
    }
}
exports.QueryDeviceCertResponse = QueryDeviceCertResponse;
class QueryDeviceDesiredPropertyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            functionBlockId: 'FunctionBlockId',
            identifier: 'Identifier',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            functionBlockId: 'string',
            identifier: { 'type': 'array', 'itemType': 'string' },
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceDesiredPropertyRequest = QueryDeviceDesiredPropertyRequest;
class QueryDeviceDesiredPropertyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceDesiredPropertyResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceDesiredPropertyResponseBody = QueryDeviceDesiredPropertyResponseBody;
class QueryDeviceDesiredPropertyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceDesiredPropertyResponseBody,
        };
    }
}
exports.QueryDeviceDesiredPropertyResponse = QueryDeviceDesiredPropertyResponse;
class QueryDeviceDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceDetailRequest = QueryDeviceDetailRequest;
class QueryDeviceDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceDetailResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceDetailResponseBody = QueryDeviceDetailResponseBody;
class QueryDeviceDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceDetailResponseBody,
        };
    }
}
exports.QueryDeviceDetailResponse = QueryDeviceDetailResponse;
class QueryDeviceDistributeDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            jobId: 'string',
        };
    }
}
exports.QueryDeviceDistributeDetailRequest = QueryDeviceDistributeDetailRequest;
class QueryDeviceDistributeDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            file: 'File',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            file: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceDistributeDetailResponseBody = QueryDeviceDistributeDetailResponseBody;
class QueryDeviceDistributeDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceDistributeDetailResponseBody,
        };
    }
}
exports.QueryDeviceDistributeDetailResponse = QueryDeviceDistributeDetailResponse;
class QueryDeviceDistributeJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            jobId: 'string',
        };
    }
}
exports.QueryDeviceDistributeJobRequest = QueryDeviceDistributeJobRequest;
class QueryDeviceDistributeJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceDistributeJobResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceDistributeJobResponseBody = QueryDeviceDistributeJobResponseBody;
class QueryDeviceDistributeJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceDistributeJobResponseBody,
        };
    }
}
exports.QueryDeviceDistributeJobResponse = QueryDeviceDistributeJobResponse;
class QueryDeviceEventDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asc: 'Asc',
            deviceName: 'DeviceName',
            endTime: 'EndTime',
            eventType: 'EventType',
            identifier: 'Identifier',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            asc: 'number',
            deviceName: 'string',
            endTime: 'number',
            eventType: 'string',
            identifier: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            productKey: 'string',
            startTime: 'number',
        };
    }
}
exports.QueryDeviceEventDataRequest = QueryDeviceEventDataRequest;
class QueryDeviceEventDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceEventDataResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceEventDataResponseBody = QueryDeviceEventDataResponseBody;
class QueryDeviceEventDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceEventDataResponseBody,
        };
    }
}
exports.QueryDeviceEventDataResponse = QueryDeviceEventDataResponse;
class QueryDeviceFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            fileId: 'FileId',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            fileId: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceFileRequest = QueryDeviceFileRequest;
class QueryDeviceFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceFileResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceFileResponseBody = QueryDeviceFileResponseBody;
class QueryDeviceFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceFileResponseBody,
        };
    }
}
exports.QueryDeviceFileResponse = QueryDeviceFileResponse;
class QueryDeviceFileListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceFileListRequest = QueryDeviceFileListRequest;
class QueryDeviceFileListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            currentPage: 'CurrentPage',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            currentPage: 'number',
            data: QueryDeviceFileListResponseBodyData,
            errorMessage: 'string',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryDeviceFileListResponseBody = QueryDeviceFileListResponseBody;
class QueryDeviceFileListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceFileListResponseBody,
        };
    }
}
exports.QueryDeviceFileListResponse = QueryDeviceFileListResponse;
class QueryDeviceGroupByDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceGroupByDeviceRequest = QueryDeviceGroupByDeviceRequest;
class QueryDeviceGroupByDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            groupInfos: 'GroupInfos',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            groupInfos: QueryDeviceGroupByDeviceResponseBodyGroupInfos,
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceGroupByDeviceResponseBody = QueryDeviceGroupByDeviceResponseBody;
class QueryDeviceGroupByDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceGroupByDeviceResponseBody,
        };
    }
}
exports.QueryDeviceGroupByDeviceResponse = QueryDeviceGroupByDeviceResponse;
class QueryDeviceGroupByTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            tag: { 'type': 'array', 'itemType': QueryDeviceGroupByTagsRequestTag },
        };
    }
}
exports.QueryDeviceGroupByTagsRequest = QueryDeviceGroupByTagsRequest;
class QueryDeviceGroupByTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            page: 'Page',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceGroupByTagsResponseBodyData,
            errorMessage: 'string',
            page: 'number',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryDeviceGroupByTagsResponseBody = QueryDeviceGroupByTagsResponseBody;
class QueryDeviceGroupByTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceGroupByTagsResponseBody,
        };
    }
}
exports.QueryDeviceGroupByTagsResponse = QueryDeviceGroupByTagsResponse;
class QueryDeviceGroupInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            groupType: 'GroupType',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            groupId: 'string',
            groupType: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.QueryDeviceGroupInfoRequest = QueryDeviceGroupInfoRequest;
class QueryDeviceGroupInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceGroupInfoResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceGroupInfoResponseBody = QueryDeviceGroupInfoResponseBody;
class QueryDeviceGroupInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceGroupInfoResponseBody,
        };
    }
}
exports.QueryDeviceGroupInfoResponse = QueryDeviceGroupInfoResponse;
class QueryDeviceGroupListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            groupName: 'GroupName',
            groupTypes: 'GroupTypes',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            superGroupId: 'SuperGroupId',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            groupName: 'string',
            groupTypes: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            pageSize: 'number',
            superGroupId: 'string',
        };
    }
}
exports.QueryDeviceGroupListRequest = QueryDeviceGroupListRequest;
class QueryDeviceGroupListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            currentPage: 'CurrentPage',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            currentPage: 'number',
            data: QueryDeviceGroupListResponseBodyData,
            errorMessage: 'string',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryDeviceGroupListResponseBody = QueryDeviceGroupListResponseBody;
class QueryDeviceGroupListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceGroupListResponseBody,
        };
    }
}
exports.QueryDeviceGroupListResponse = QueryDeviceGroupListResponse;
class QueryDeviceGroupTagListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            groupType: 'GroupType',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            groupId: 'string',
            groupType: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.QueryDeviceGroupTagListRequest = QueryDeviceGroupTagListRequest;
class QueryDeviceGroupTagListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceGroupTagListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceGroupTagListResponseBody = QueryDeviceGroupTagListResponseBody;
class QueryDeviceGroupTagListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceGroupTagListResponseBody,
        };
    }
}
exports.QueryDeviceGroupTagListResponse = QueryDeviceGroupTagListResponse;
class QueryDeviceInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceInfoRequest = QueryDeviceInfoRequest;
class QueryDeviceInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceInfoResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceInfoResponseBody = QueryDeviceInfoResponseBody;
class QueryDeviceInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceInfoResponseBody,
        };
    }
}
exports.QueryDeviceInfoResponse = QueryDeviceInfoResponse;
class QueryDeviceListByDeviceGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            groupId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
        };
    }
}
exports.QueryDeviceListByDeviceGroupRequest = QueryDeviceListByDeviceGroupRequest;
class QueryDeviceListByDeviceGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            page: 'Page',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceListByDeviceGroupResponseBodyData,
            errorMessage: 'string',
            page: 'number',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryDeviceListByDeviceGroupResponseBody = QueryDeviceListByDeviceGroupResponseBody;
class QueryDeviceListByDeviceGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceListByDeviceGroupResponseBody,
        };
    }
}
exports.QueryDeviceListByDeviceGroupResponse = QueryDeviceListByDeviceGroupResponse;
class QueryDeviceOriginalEventDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asc: 'Asc',
            deviceName: 'DeviceName',
            endTime: 'EndTime',
            identifier: 'Identifier',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            nextPageToken: 'NextPageToken',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            asc: 'number',
            deviceName: 'string',
            endTime: 'number',
            identifier: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            nextPageToken: 'string',
            pageSize: 'number',
            productKey: 'string',
            startTime: 'number',
        };
    }
}
exports.QueryDeviceOriginalEventDataRequest = QueryDeviceOriginalEventDataRequest;
class QueryDeviceOriginalEventDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceOriginalEventDataResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceOriginalEventDataResponseBody = QueryDeviceOriginalEventDataResponseBody;
class QueryDeviceOriginalEventDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceOriginalEventDataResponseBody,
        };
    }
}
exports.QueryDeviceOriginalEventDataResponse = QueryDeviceOriginalEventDataResponse;
class QueryDeviceOriginalPropertyDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asc: 'Asc',
            deviceName: 'DeviceName',
            endTime: 'EndTime',
            identifier: 'Identifier',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            nextPageToken: 'NextPageToken',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            asc: 'number',
            deviceName: 'string',
            endTime: 'number',
            identifier: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            nextPageToken: 'string',
            pageSize: 'number',
            productKey: 'string',
            startTime: 'number',
        };
    }
}
exports.QueryDeviceOriginalPropertyDataRequest = QueryDeviceOriginalPropertyDataRequest;
class QueryDeviceOriginalPropertyDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceOriginalPropertyDataResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceOriginalPropertyDataResponseBody = QueryDeviceOriginalPropertyDataResponseBody;
class QueryDeviceOriginalPropertyDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceOriginalPropertyDataResponseBody,
        };
    }
}
exports.QueryDeviceOriginalPropertyDataResponse = QueryDeviceOriginalPropertyDataResponse;
class QueryDeviceOriginalPropertyStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asc: 'Asc',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            nextPageToken: 'NextPageToken',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            asc: 'number',
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            nextPageToken: 'string',
            pageSize: 'number',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceOriginalPropertyStatusRequest = QueryDeviceOriginalPropertyStatusRequest;
class QueryDeviceOriginalPropertyStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceOriginalPropertyStatusResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceOriginalPropertyStatusResponseBody = QueryDeviceOriginalPropertyStatusResponseBody;
class QueryDeviceOriginalPropertyStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceOriginalPropertyStatusResponseBody,
        };
    }
}
exports.QueryDeviceOriginalPropertyStatusResponse = QueryDeviceOriginalPropertyStatusResponse;
class QueryDeviceOriginalServiceDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asc: 'Asc',
            deviceName: 'DeviceName',
            endTime: 'EndTime',
            identifier: 'Identifier',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            nextPageToken: 'NextPageToken',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            asc: 'number',
            deviceName: 'string',
            endTime: 'number',
            identifier: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            nextPageToken: 'string',
            pageSize: 'number',
            productKey: 'string',
            startTime: 'number',
        };
    }
}
exports.QueryDeviceOriginalServiceDataRequest = QueryDeviceOriginalServiceDataRequest;
class QueryDeviceOriginalServiceDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceOriginalServiceDataResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceOriginalServiceDataResponseBody = QueryDeviceOriginalServiceDataResponseBody;
class QueryDeviceOriginalServiceDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceOriginalServiceDataResponseBody,
        };
    }
}
exports.QueryDeviceOriginalServiceDataResponse = QueryDeviceOriginalServiceDataResponse;
class QueryDevicePropRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDevicePropRequest = QueryDevicePropRequest;
class QueryDevicePropResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            props: 'Props',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            props: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDevicePropResponseBody = QueryDevicePropResponseBody;
class QueryDevicePropResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDevicePropResponseBody,
        };
    }
}
exports.QueryDevicePropResponse = QueryDevicePropResponse;
class QueryDevicePropertiesDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asc: 'Asc',
            deviceName: 'DeviceName',
            endTime: 'EndTime',
            identifier: 'Identifier',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            asc: 'number',
            deviceName: 'string',
            endTime: 'number',
            identifier: { 'type': 'array', 'itemType': 'string' },
            iotId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            productKey: 'string',
            startTime: 'number',
        };
    }
}
exports.QueryDevicePropertiesDataRequest = QueryDevicePropertiesDataRequest;
class QueryDevicePropertiesDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            nextTime: 'NextTime',
            nextValid: 'NextValid',
            propertyDataInfos: 'PropertyDataInfos',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            nextTime: 'number',
            nextValid: 'boolean',
            propertyDataInfos: QueryDevicePropertiesDataResponseBodyPropertyDataInfos,
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDevicePropertiesDataResponseBody = QueryDevicePropertiesDataResponseBody;
class QueryDevicePropertiesDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDevicePropertiesDataResponseBody,
        };
    }
}
exports.QueryDevicePropertiesDataResponse = QueryDevicePropertiesDataResponse;
class QueryDevicePropertyDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asc: 'Asc',
            deviceName: 'DeviceName',
            endTime: 'EndTime',
            identifier: 'Identifier',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            asc: 'number',
            deviceName: 'string',
            endTime: 'number',
            identifier: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            productKey: 'string',
            startTime: 'number',
        };
    }
}
exports.QueryDevicePropertyDataRequest = QueryDevicePropertyDataRequest;
class QueryDevicePropertyDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDevicePropertyDataResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDevicePropertyDataResponseBody = QueryDevicePropertyDataResponseBody;
class QueryDevicePropertyDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDevicePropertyDataResponseBody,
        };
    }
}
exports.QueryDevicePropertyDataResponse = QueryDevicePropertyDataResponse;
class QueryDevicePropertyStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            functionBlockId: 'FunctionBlockId',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            functionBlockId: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDevicePropertyStatusRequest = QueryDevicePropertyStatusRequest;
class QueryDevicePropertyStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDevicePropertyStatusResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDevicePropertyStatusResponseBody = QueryDevicePropertyStatusResponseBody;
class QueryDevicePropertyStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDevicePropertyStatusResponseBody,
        };
    }
}
exports.QueryDevicePropertyStatusResponse = QueryDevicePropertyStatusResponse;
class QueryDeviceProvisioningRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceProvisioningRequest = QueryDeviceProvisioningRequest;
class QueryDeviceProvisioningResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceProvisioningResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceProvisioningResponseBody = QueryDeviceProvisioningResponseBody;
class QueryDeviceProvisioningResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceProvisioningResponseBody,
        };
    }
}
exports.QueryDeviceProvisioningResponse = QueryDeviceProvisioningResponse;
class QueryDeviceServiceDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asc: 'Asc',
            deviceName: 'DeviceName',
            endTime: 'EndTime',
            identifier: 'Identifier',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            asc: 'number',
            deviceName: 'string',
            endTime: 'number',
            identifier: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            productKey: 'string',
            startTime: 'number',
        };
    }
}
exports.QueryDeviceServiceDataRequest = QueryDeviceServiceDataRequest;
class QueryDeviceServiceDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceServiceDataResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceServiceDataResponseBody = QueryDeviceServiceDataResponseBody;
class QueryDeviceServiceDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceServiceDataResponseBody,
        };
    }
}
exports.QueryDeviceServiceDataResponse = QueryDeviceServiceDataResponse;
class QueryDeviceSpeechRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            iotId: 'string',
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
        };
    }
}
exports.QueryDeviceSpeechRequest = QueryDeviceSpeechRequest;
class QueryDeviceSpeechResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceSpeechResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceSpeechResponseBody = QueryDeviceSpeechResponseBody;
class QueryDeviceSpeechResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceSpeechResponseBody,
        };
    }
}
exports.QueryDeviceSpeechResponse = QueryDeviceSpeechResponse;
class QueryDeviceStatisticsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            groupId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceStatisticsRequest = QueryDeviceStatisticsRequest;
class QueryDeviceStatisticsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceStatisticsResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceStatisticsResponseBody = QueryDeviceStatisticsResponseBody;
class QueryDeviceStatisticsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceStatisticsResponseBody,
        };
    }
}
exports.QueryDeviceStatisticsResponse = QueryDeviceStatisticsResponse;
class QueryDeviceSubTopicRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceSubTopicRequest = QueryDeviceSubTopicRequest;
class QueryDeviceSubTopicResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
            topicList: 'TopicList',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
            topicList: { 'type': 'array', 'itemType': QueryDeviceSubTopicResponseBodyTopicList },
        };
    }
}
exports.QueryDeviceSubTopicResponseBody = QueryDeviceSubTopicResponseBody;
class QueryDeviceSubTopicResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceSubTopicResponseBody,
        };
    }
}
exports.QueryDeviceSubTopicResponse = QueryDeviceSubTopicResponse;
class QueryDeviceTunnelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            tunnelId: 'TunnelId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            tunnelId: 'string',
        };
    }
}
exports.QueryDeviceTunnelRequest = QueryDeviceTunnelRequest;
class QueryDeviceTunnelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDeviceTunnelResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDeviceTunnelResponseBody = QueryDeviceTunnelResponseBody;
class QueryDeviceTunnelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDeviceTunnelResponseBody,
        };
    }
}
exports.QueryDeviceTunnelResponse = QueryDeviceTunnelResponse;
class QueryDevicesHotStorageDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asc: 'Asc',
            deviceName: 'DeviceName',
            endTime: 'EndTime',
            identifier: 'Identifier',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            nextPageToken: 'NextPageToken',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            startTime: 'StartTime',
            userTopic: 'UserTopic',
        };
    }
    static types() {
        return {
            asc: 'number',
            deviceName: 'string',
            endTime: 'number',
            identifier: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            nextPageToken: 'string',
            pageSize: 'number',
            productKey: 'string',
            startTime: 'number',
            userTopic: 'string',
        };
    }
}
exports.QueryDevicesHotStorageDataRequest = QueryDevicesHotStorageDataRequest;
class QueryDevicesHotStorageDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDevicesHotStorageDataResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDevicesHotStorageDataResponseBody = QueryDevicesHotStorageDataResponseBody;
class QueryDevicesHotStorageDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDevicesHotStorageDataResponseBody,
        };
    }
}
exports.QueryDevicesHotStorageDataResponse = QueryDevicesHotStorageDataResponse;
class QueryDevicesHotStorageDataStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asc: 'Asc',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            nextPageToken: 'NextPageToken',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            userTopic: 'UserTopic',
        };
    }
    static types() {
        return {
            asc: 'number',
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            nextPageToken: 'string',
            pageSize: 'number',
            productKey: 'string',
            userTopic: 'string',
        };
    }
}
exports.QueryDevicesHotStorageDataStatusRequest = QueryDevicesHotStorageDataStatusRequest;
class QueryDevicesHotStorageDataStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDevicesHotStorageDataStatusResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDevicesHotStorageDataStatusResponseBody = QueryDevicesHotStorageDataStatusResponseBody;
class QueryDevicesHotStorageDataStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDevicesHotStorageDataStatusResponseBody,
        };
    }
}
exports.QueryDevicesHotStorageDataStatusResponse = QueryDevicesHotStorageDataStatusResponse;
class QueryDynamicGroupDevicesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            deviceName: 'DeviceName',
            fuzzyName: 'FuzzyName',
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
            nextToken: 'NextToken',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            status: 'Status',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            deviceName: 'string',
            fuzzyName: 'boolean',
            groupId: 'string',
            iotInstanceId: 'string',
            nextToken: 'string',
            pageSize: 'number',
            productKey: 'string',
            status: 'string',
        };
    }
}
exports.QueryDynamicGroupDevicesRequest = QueryDynamicGroupDevicesRequest;
class QueryDynamicGroupDevicesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            nextToken: 'NextToken',
            page: 'Page',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDynamicGroupDevicesResponseBodyData,
            errorMessage: 'string',
            nextToken: 'string',
            page: 'number',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryDynamicGroupDevicesResponseBody = QueryDynamicGroupDevicesResponseBody;
class QueryDynamicGroupDevicesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDynamicGroupDevicesResponseBody,
        };
    }
}
exports.QueryDynamicGroupDevicesResponse = QueryDynamicGroupDevicesResponse;
class QueryEdgeDriverRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            driverName: 'DriverName',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            type: 'Type',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            driverName: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            type: 'number',
        };
    }
}
exports.QueryEdgeDriverRequest = QueryEdgeDriverRequest;
class QueryEdgeDriverResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEdgeDriverResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeDriverResponseBody = QueryEdgeDriverResponseBody;
class QueryEdgeDriverResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeDriverResponseBody,
        };
    }
}
exports.QueryEdgeDriverResponse = QueryEdgeDriverResponse;
class QueryEdgeDriverVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            driverId: 'DriverId',
            driverVersion: 'DriverVersion',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            versionState: 'VersionState',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            driverId: 'string',
            driverVersion: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            versionState: 'number',
        };
    }
}
exports.QueryEdgeDriverVersionRequest = QueryEdgeDriverVersionRequest;
class QueryEdgeDriverVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEdgeDriverVersionResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeDriverVersionResponseBody = QueryEdgeDriverVersionResponseBody;
class QueryEdgeDriverVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeDriverVersionResponseBody,
        };
    }
}
exports.QueryEdgeDriverVersionResponse = QueryEdgeDriverVersionResponse;
class QueryEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            iotInstanceId: 'string',
            name: 'string',
            pageSize: 'number',
        };
    }
}
exports.QueryEdgeInstanceRequest = QueryEdgeInstanceRequest;
class QueryEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEdgeInstanceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeInstanceResponseBody = QueryEdgeInstanceResponseBody;
class QueryEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeInstanceResponseBody,
        };
    }
}
exports.QueryEdgeInstanceResponse = QueryEdgeInstanceResponse;
class QueryEdgeInstanceChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelName: 'ChannelName',
            currentPage: 'CurrentPage',
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            channelName: 'string',
            currentPage: 'number',
            driverId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
        };
    }
}
exports.QueryEdgeInstanceChannelRequest = QueryEdgeInstanceChannelRequest;
class QueryEdgeInstanceChannelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEdgeInstanceChannelResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeInstanceChannelResponseBody = QueryEdgeInstanceChannelResponseBody;
class QueryEdgeInstanceChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeInstanceChannelResponseBody,
        };
    }
}
exports.QueryEdgeInstanceChannelResponse = QueryEdgeInstanceChannelResponse;
class QueryEdgeInstanceDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            instanceId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
        };
    }
}
exports.QueryEdgeInstanceDeviceRequest = QueryEdgeInstanceDeviceRequest;
class QueryEdgeInstanceDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEdgeInstanceDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeInstanceDeviceResponseBody = QueryEdgeInstanceDeviceResponseBody;
class QueryEdgeInstanceDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeInstanceDeviceResponseBody,
        };
    }
}
exports.QueryEdgeInstanceDeviceResponse = QueryEdgeInstanceDeviceResponse;
class QueryEdgeInstanceDeviceByDriverRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelId: 'ChannelId',
            currentPage: 'CurrentPage',
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            channelId: 'string',
            currentPage: 'number',
            driverId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
        };
    }
}
exports.QueryEdgeInstanceDeviceByDriverRequest = QueryEdgeInstanceDeviceByDriverRequest;
class QueryEdgeInstanceDeviceByDriverResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEdgeInstanceDeviceByDriverResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeInstanceDeviceByDriverResponseBody = QueryEdgeInstanceDeviceByDriverResponseBody;
class QueryEdgeInstanceDeviceByDriverResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeInstanceDeviceByDriverResponseBody,
        };
    }
}
exports.QueryEdgeInstanceDeviceByDriverResponse = QueryEdgeInstanceDeviceByDriverResponse;
class QueryEdgeInstanceDriverRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            instanceId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
        };
    }
}
exports.QueryEdgeInstanceDriverRequest = QueryEdgeInstanceDriverRequest;
class QueryEdgeInstanceDriverResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEdgeInstanceDriverResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeInstanceDriverResponseBody = QueryEdgeInstanceDriverResponseBody;
class QueryEdgeInstanceDriverResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeInstanceDriverResponseBody,
        };
    }
}
exports.QueryEdgeInstanceDriverResponse = QueryEdgeInstanceDriverResponse;
class QueryEdgeInstanceGatewayRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.QueryEdgeInstanceGatewayRequest = QueryEdgeInstanceGatewayRequest;
class QueryEdgeInstanceGatewayResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            gatewayList: 'GatewayList',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            gatewayList: { 'type': 'array', 'itemType': QueryEdgeInstanceGatewayResponseBodyGatewayList },
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeInstanceGatewayResponseBody = QueryEdgeInstanceGatewayResponseBody;
class QueryEdgeInstanceGatewayResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeInstanceGatewayResponseBody,
        };
    }
}
exports.QueryEdgeInstanceGatewayResponse = QueryEdgeInstanceGatewayResponse;
class QueryEdgeInstanceHistoricDeploymentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            endTime: 'EndTime',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            endTime: 'number',
            instanceId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
            startTime: 'number',
        };
    }
}
exports.QueryEdgeInstanceHistoricDeploymentRequest = QueryEdgeInstanceHistoricDeploymentRequest;
class QueryEdgeInstanceHistoricDeploymentResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEdgeInstanceHistoricDeploymentResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeInstanceHistoricDeploymentResponseBody = QueryEdgeInstanceHistoricDeploymentResponseBody;
class QueryEdgeInstanceHistoricDeploymentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeInstanceHistoricDeploymentResponseBody,
        };
    }
}
exports.QueryEdgeInstanceHistoricDeploymentResponse = QueryEdgeInstanceHistoricDeploymentResponse;
class QueryEdgeInstanceMessageRoutingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            instanceId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
        };
    }
}
exports.QueryEdgeInstanceMessageRoutingRequest = QueryEdgeInstanceMessageRoutingRequest;
class QueryEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEdgeInstanceMessageRoutingResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeInstanceMessageRoutingResponseBody = QueryEdgeInstanceMessageRoutingResponseBody;
class QueryEdgeInstanceMessageRoutingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeInstanceMessageRoutingResponseBody,
        };
    }
}
exports.QueryEdgeInstanceMessageRoutingResponse = QueryEdgeInstanceMessageRoutingResponse;
class QueryEdgeInstanceSceneRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            instanceId: 'string',
            iotInstanceId: 'string',
            pageSize: 'number',
        };
    }
}
exports.QueryEdgeInstanceSceneRuleRequest = QueryEdgeInstanceSceneRuleRequest;
class QueryEdgeInstanceSceneRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEdgeInstanceSceneRuleResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEdgeInstanceSceneRuleResponseBody = QueryEdgeInstanceSceneRuleResponseBody;
class QueryEdgeInstanceSceneRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEdgeInstanceSceneRuleResponseBody,
        };
    }
}
exports.QueryEdgeInstanceSceneRuleResponse = QueryEdgeInstanceSceneRuleResponse;
class QueryImportedDeviceByApplyIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyId: 'ApplyId',
            iotInstanceId: 'IotInstanceId',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            applyId: 'number',
            iotInstanceId: 'string',
            pageNo: 'number',
            pageSize: 'number',
        };
    }
}
exports.QueryImportedDeviceByApplyIdRequest = QueryImportedDeviceByApplyIdRequest;
class QueryImportedDeviceByApplyIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            deviceList: 'DeviceList',
            errorMessage: 'ErrorMessage',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            requestId: 'RequestId',
            success: 'Success',
            totalPage: 'TotalPage',
        };
    }
    static types() {
        return {
            code: 'string',
            deviceList: QueryImportedDeviceByApplyIdResponseBodyDeviceList,
            errorMessage: 'string',
            pageNo: 'number',
            pageSize: 'number',
            productKey: 'string',
            requestId: 'string',
            success: 'boolean',
            totalPage: 'number',
        };
    }
}
exports.QueryImportedDeviceByApplyIdResponseBody = QueryImportedDeviceByApplyIdResponseBody;
class QueryImportedDeviceByApplyIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryImportedDeviceByApplyIdResponseBody,
        };
    }
}
exports.QueryImportedDeviceByApplyIdResponse = QueryImportedDeviceByApplyIdResponse;
class QueryJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            jobId: 'string',
        };
    }
}
exports.QueryJobRequest = QueryJobRequest;
class QueryJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryJobResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryJobResponseBody = QueryJobResponseBody;
class QueryJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryJobResponseBody,
        };
    }
}
exports.QueryJobResponse = QueryJobResponse;
class QueryJobStatisticsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            jobId: 'string',
        };
    }
}
exports.QueryJobStatisticsRequest = QueryJobStatisticsRequest;
class QueryJobStatisticsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryJobStatisticsResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryJobStatisticsResponseBody = QueryJobStatisticsResponseBody;
class QueryJobStatisticsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryJobStatisticsResponseBody,
        };
    }
}
exports.QueryJobStatisticsResponse = QueryJobStatisticsResponse;
class QueryLicenseDeviceListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'EndTime',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            licenseCode: 'LicenseCode',
            pageId: 'PageId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            endTime: 'number',
            iotId: 'string',
            iotInstanceId: 'string',
            licenseCode: 'string',
            pageId: 'number',
            pageSize: 'number',
            productKey: 'string',
            startTime: 'number',
        };
    }
}
exports.QueryLicenseDeviceListRequest = QueryLicenseDeviceListRequest;
class QueryLicenseDeviceListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryLicenseDeviceListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryLicenseDeviceListResponseBody = QueryLicenseDeviceListResponseBody;
class QueryLicenseDeviceListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryLicenseDeviceListResponseBody,
        };
    }
}
exports.QueryLicenseDeviceListResponse = QueryLicenseDeviceListResponse;
class QueryLoRaJoinPermissionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
        };
    }
}
exports.QueryLoRaJoinPermissionsRequest = QueryLoRaJoinPermissionsRequest;
class QueryLoRaJoinPermissionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            joinPermissions: 'JoinPermissions',
            productKey: 'ProductKey',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            joinPermissions: QueryLoRaJoinPermissionsResponseBodyJoinPermissions,
            productKey: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryLoRaJoinPermissionsResponseBody = QueryLoRaJoinPermissionsResponseBody;
class QueryLoRaJoinPermissionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryLoRaJoinPermissionsResponseBody,
        };
    }
}
exports.QueryLoRaJoinPermissionsResponse = QueryLoRaJoinPermissionsResponse;
class QueryMessageInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            uniMsgId: 'UniMsgId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            uniMsgId: 'string',
        };
    }
}
exports.QueryMessageInfoRequest = QueryMessageInfoRequest;
class QueryMessageInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            message: QueryMessageInfoResponseBodyMessage,
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryMessageInfoResponseBody = QueryMessageInfoResponseBody;
class QueryMessageInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryMessageInfoResponseBody,
        };
    }
}
exports.QueryMessageInfoResponse = QueryMessageInfoResponse;
class QueryOTAFirmwareRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            firmwareId: 'FirmwareId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            firmwareId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.QueryOTAFirmwareRequest = QueryOTAFirmwareRequest;
class QueryOTAFirmwareResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            firmwareInfo: 'FirmwareInfo',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            firmwareInfo: QueryOTAFirmwareResponseBodyFirmwareInfo,
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryOTAFirmwareResponseBody = QueryOTAFirmwareResponseBody;
class QueryOTAFirmwareResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryOTAFirmwareResponseBody,
        };
    }
}
exports.QueryOTAFirmwareResponse = QueryOTAFirmwareResponse;
class QueryOTAJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            jobId: 'string',
        };
    }
}
exports.QueryOTAJobRequest = QueryOTAJobRequest;
class QueryOTAJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryOTAJobResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryOTAJobResponseBody = QueryOTAJobResponseBody;
class QueryOTAJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryOTAJobResponseBody,
        };
    }
}
exports.QueryOTAJobResponse = QueryOTAJobResponse;
class QueryPageByApplyIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyId: 'ApplyId',
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            applyId: 'number',
            currentPage: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
        };
    }
}
exports.QueryPageByApplyIdRequest = QueryPageByApplyIdRequest;
class QueryPageByApplyIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyDeviceList: 'ApplyDeviceList',
            code: 'Code',
            errorMessage: 'ErrorMessage',
            page: 'Page',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            applyDeviceList: QueryPageByApplyIdResponseBodyApplyDeviceList,
            code: 'string',
            errorMessage: 'string',
            page: 'number',
            pageCount: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryPageByApplyIdResponseBody = QueryPageByApplyIdResponseBody;
class QueryPageByApplyIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryPageByApplyIdResponseBody,
        };
    }
}
exports.QueryPageByApplyIdResponse = QueryPageByApplyIdResponse;
class QueryProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryProductRequest = QueryProductRequest;
class QueryProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryProductResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryProductResponseBody = QueryProductResponseBody;
class QueryProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryProductResponseBody,
        };
    }
}
exports.QueryProductResponse = QueryProductResponse;
class QueryProductCertInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryProductCertInfoRequest = QueryProductCertInfoRequest;
class QueryProductCertInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            productCertInfo: 'ProductCertInfo',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            productCertInfo: QueryProductCertInfoResponseBodyProductCertInfo,
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryProductCertInfoResponseBody = QueryProductCertInfoResponseBody;
class QueryProductCertInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryProductCertInfoResponseBody,
        };
    }
}
exports.QueryProductCertInfoResponse = QueryProductCertInfoResponse;
class QueryProductListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliyunCommodityCode: 'AliyunCommodityCode',
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            aliyunCommodityCode: 'string',
            currentPage: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            resourceGroupId: 'string',
        };
    }
}
exports.QueryProductListRequest = QueryProductListRequest;
class QueryProductListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryProductListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryProductListResponseBody = QueryProductListResponseBody;
class QueryProductListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryProductListResponseBody,
        };
    }
}
exports.QueryProductListResponse = QueryProductListResponse;
class QueryProductTopicRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryProductTopicRequest = QueryProductTopicRequest;
class QueryProductTopicResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryProductTopicResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryProductTopicResponseBody = QueryProductTopicResponseBody;
class QueryProductTopicResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryProductTopicResponseBody,
        };
    }
}
exports.QueryProductTopicResponse = QueryProductTopicResponse;
class QueryProjectShareDeviceListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
            productKey: 'string',
        };
    }
}
exports.QueryProjectShareDeviceListRequest = QueryProjectShareDeviceListRequest;
class QueryProjectShareDeviceListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryProjectShareDeviceListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryProjectShareDeviceListResponseBody = QueryProjectShareDeviceListResponseBody;
class QueryProjectShareDeviceListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryProjectShareDeviceListResponseBody,
        };
    }
}
exports.QueryProjectShareDeviceListResponse = QueryProjectShareDeviceListResponse;
class QuerySceneRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            ruleName: 'RuleName',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            ruleName: 'string',
        };
    }
}
exports.QuerySceneRuleRequest = QuerySceneRuleRequest;
class QuerySceneRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySceneRuleResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySceneRuleResponseBody = QuerySceneRuleResponseBody;
class QuerySceneRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySceneRuleResponseBody,
        };
    }
}
exports.QuerySceneRuleResponse = QuerySceneRuleResponse;
class QuerySchedulePeriodListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
            scheduleCode: 'ScheduleCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
            scheduleCode: 'string',
        };
    }
}
exports.QuerySchedulePeriodListRequest = QuerySchedulePeriodListRequest;
class QuerySchedulePeriodListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySchedulePeriodListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySchedulePeriodListResponseBody = QuerySchedulePeriodListResponseBody;
class QuerySchedulePeriodListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySchedulePeriodListResponseBody,
        };
    }
}
exports.QuerySchedulePeriodListResponse = QuerySchedulePeriodListResponse;
class QueryShareTaskDeviceListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
            shareTaskId: 'ShareTaskId',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
            shareTaskId: 'string',
        };
    }
}
exports.QueryShareTaskDeviceListRequest = QueryShareTaskDeviceListRequest;
class QueryShareTaskDeviceListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryShareTaskDeviceListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryShareTaskDeviceListResponseBody = QueryShareTaskDeviceListResponseBody;
class QueryShareTaskDeviceListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryShareTaskDeviceListResponseBody,
        };
    }
}
exports.QueryShareTaskDeviceListResponse = QueryShareTaskDeviceListResponse;
class QuerySolutionDeviceGroupPageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fuzzyGroupName: 'FuzzyGroupName',
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
            projectCode: 'ProjectCode',
        };
    }
    static types() {
        return {
            fuzzyGroupName: 'string',
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
            projectCode: 'string',
        };
    }
}
exports.QuerySolutionDeviceGroupPageRequest = QuerySolutionDeviceGroupPageRequest;
class QuerySolutionDeviceGroupPageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySolutionDeviceGroupPageResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySolutionDeviceGroupPageResponseBody = QuerySolutionDeviceGroupPageResponseBody;
class QuerySolutionDeviceGroupPageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySolutionDeviceGroupPageResponseBody,
        };
    }
}
exports.QuerySolutionDeviceGroupPageResponse = QuerySolutionDeviceGroupPageResponse;
class QuerySoundCodeLabelBatchFailedResultRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            batchCode: 'BatchCode',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            batchCode: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.QuerySoundCodeLabelBatchFailedResultRequest = QuerySoundCodeLabelBatchFailedResultRequest;
class QuerySoundCodeLabelBatchFailedResultResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySoundCodeLabelBatchFailedResultResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySoundCodeLabelBatchFailedResultResponseBody = QuerySoundCodeLabelBatchFailedResultResponseBody;
class QuerySoundCodeLabelBatchFailedResultResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySoundCodeLabelBatchFailedResultResponseBody,
        };
    }
}
exports.QuerySoundCodeLabelBatchFailedResultResponse = QuerySoundCodeLabelBatchFailedResultResponse;
class QuerySoundCodeLabelBatchListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
            scheduleCode: 'ScheduleCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
            scheduleCode: 'string',
        };
    }
}
exports.QuerySoundCodeLabelBatchListRequest = QuerySoundCodeLabelBatchListRequest;
class QuerySoundCodeLabelBatchListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySoundCodeLabelBatchListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySoundCodeLabelBatchListResponseBody = QuerySoundCodeLabelBatchListResponseBody;
class QuerySoundCodeLabelBatchListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySoundCodeLabelBatchListResponseBody,
        };
    }
}
exports.QuerySoundCodeLabelBatchListResponse = QuerySoundCodeLabelBatchListResponse;
class QuerySoundCodeLabelListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
            scheduleCode: 'ScheduleCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
            scheduleCode: 'string',
        };
    }
}
exports.QuerySoundCodeLabelListRequest = QuerySoundCodeLabelListRequest;
class QuerySoundCodeLabelListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySoundCodeLabelListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySoundCodeLabelListResponseBody = QuerySoundCodeLabelListResponseBody;
class QuerySoundCodeLabelListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySoundCodeLabelListResponseBody,
        };
    }
}
exports.QuerySoundCodeLabelListResponse = QuerySoundCodeLabelListResponse;
class QuerySoundCodeListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
        };
    }
}
exports.QuerySoundCodeListRequest = QuerySoundCodeListRequest;
class QuerySoundCodeListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySoundCodeListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySoundCodeListResponseBody = QuerySoundCodeListResponseBody;
class QuerySoundCodeListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySoundCodeListResponseBody,
        };
    }
}
exports.QuerySoundCodeListResponse = QuerySoundCodeListResponse;
class QuerySoundCodeScheduleListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
        };
    }
}
exports.QuerySoundCodeScheduleListRequest = QuerySoundCodeScheduleListRequest;
class QuerySoundCodeScheduleListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySoundCodeScheduleListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySoundCodeScheduleListResponseBody = QuerySoundCodeScheduleListResponseBody;
class QuerySoundCodeScheduleListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySoundCodeScheduleListResponseBody,
        };
    }
}
exports.QuerySoundCodeScheduleListResponse = QuerySoundCodeScheduleListResponse;
class QuerySpeechRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            speechCode: 'SpeechCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            speechCode: 'string',
        };
    }
}
exports.QuerySpeechRequest = QuerySpeechRequest;
class QuerySpeechResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySpeechResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySpeechResponseBody = QuerySpeechResponseBody;
class QuerySpeechResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySpeechResponseBody,
        };
    }
}
exports.QuerySpeechResponse = QuerySpeechResponse;
class QuerySpeechDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableSpace: 'AvailableSpace',
            availableSpaceScope: 'AvailableSpaceScope',
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
            projectCode: 'ProjectCode',
        };
    }
    static types() {
        return {
            availableSpace: 'string',
            availableSpaceScope: 'string',
            deviceName: 'string',
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
            projectCode: 'string',
        };
    }
}
exports.QuerySpeechDeviceRequest = QuerySpeechDeviceRequest;
class QuerySpeechDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySpeechDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySpeechDeviceResponseBody = QuerySpeechDeviceResponseBody;
class QuerySpeechDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySpeechDeviceResponseBody,
        };
    }
}
exports.QuerySpeechDeviceResponse = QuerySpeechDeviceResponse;
class QuerySpeechLicenseAvailableQuotaRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
        };
    }
}
exports.QuerySpeechLicenseAvailableQuotaRequest = QuerySpeechLicenseAvailableQuotaRequest;
class QuerySpeechLicenseAvailableQuotaResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'number',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySpeechLicenseAvailableQuotaResponseBody = QuerySpeechLicenseAvailableQuotaResponseBody;
class QuerySpeechLicenseAvailableQuotaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySpeechLicenseAvailableQuotaResponseBody,
        };
    }
}
exports.QuerySpeechLicenseAvailableQuotaResponse = QuerySpeechLicenseAvailableQuotaResponse;
class QuerySpeechLicenseDeviceListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkGroupId: 'CheckGroupId',
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            licenseStatusList: 'LicenseStatusList',
            pageId: 'PageId',
            pageSize: 'PageSize',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            checkGroupId: 'string',
            deviceName: 'string',
            iotInstanceId: 'string',
            licenseStatusList: { 'type': 'array', 'itemType': 'string' },
            pageId: 'number',
            pageSize: 'number',
            productKey: 'string',
        };
    }
}
exports.QuerySpeechLicenseDeviceListRequest = QuerySpeechLicenseDeviceListRequest;
class QuerySpeechLicenseDeviceListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySpeechLicenseDeviceListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySpeechLicenseDeviceListResponseBody = QuerySpeechLicenseDeviceListResponseBody;
class QuerySpeechLicenseDeviceListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySpeechLicenseDeviceListResponseBody,
        };
    }
}
exports.QuerySpeechLicenseDeviceListResponse = QuerySpeechLicenseDeviceListResponse;
class QuerySpeechListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            iotInstanceId: 'IotInstanceId',
            pageId: 'PageId',
            pageSize: 'PageSize',
            projectCode: 'ProjectCode',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            iotInstanceId: 'string',
            pageId: 'number',
            pageSize: 'number',
            projectCode: 'string',
        };
    }
}
exports.QuerySpeechListRequest = QuerySpeechListRequest;
class QuerySpeechListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySpeechListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySpeechListResponseBody = QuerySpeechListResponseBody;
class QuerySpeechListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySpeechListResponseBody,
        };
    }
}
exports.QuerySpeechListResponse = QuerySpeechListResponse;
class QuerySpeechPushJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            jobCode: 'JobCode',
            pageId: 'PageId',
            pageSize: 'PageSize',
            projectCode: 'ProjectCode',
            pushMode: 'PushMode',
            statusList: 'StatusList',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            jobCode: 'string',
            pageId: 'number',
            pageSize: 'number',
            projectCode: 'string',
            pushMode: 'string',
            statusList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QuerySpeechPushJobRequest = QuerySpeechPushJobRequest;
class QuerySpeechPushJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySpeechPushJobResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySpeechPushJobResponseBody = QuerySpeechPushJobResponseBody;
class QuerySpeechPushJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySpeechPushJobResponseBody,
        };
    }
}
exports.QuerySpeechPushJobResponse = QuerySpeechPushJobResponse;
class QuerySpeechPushJobDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            jobCode: 'JobCode',
            pageId: 'PageId',
            pageSize: 'PageSize',
            status: 'Status',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            jobCode: 'string',
            pageId: 'number',
            pageSize: 'number',
            status: 'string',
        };
    }
}
exports.QuerySpeechPushJobDeviceRequest = QuerySpeechPushJobDeviceRequest;
class QuerySpeechPushJobDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySpeechPushJobDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySpeechPushJobDeviceResponseBody = QuerySpeechPushJobDeviceResponseBody;
class QuerySpeechPushJobDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySpeechPushJobDeviceResponseBody,
        };
    }
}
exports.QuerySpeechPushJobDeviceResponse = QuerySpeechPushJobDeviceResponse;
class QuerySpeechPushJobSpeechRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            jobCode: 'JobCode',
            pageId: 'PageId',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            jobCode: 'string',
            pageId: 'number',
            pageSize: 'number',
        };
    }
}
exports.QuerySpeechPushJobSpeechRequest = QuerySpeechPushJobSpeechRequest;
class QuerySpeechPushJobSpeechResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySpeechPushJobSpeechResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySpeechPushJobSpeechResponseBody = QuerySpeechPushJobSpeechResponseBody;
class QuerySpeechPushJobSpeechResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySpeechPushJobSpeechResponseBody,
        };
    }
}
exports.QuerySpeechPushJobSpeechResponse = QuerySpeechPushJobSpeechResponse;
class QueryStudioAppDomainListOpenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            iotInstanceId: 'IotInstanceId',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            appId: 'string',
            iotInstanceId: 'string',
            projectId: 'string',
        };
    }
}
exports.QueryStudioAppDomainListOpenRequest = QueryStudioAppDomainListOpenRequest;
class QueryStudioAppDomainListOpenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryStudioAppDomainListOpenResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryStudioAppDomainListOpenResponseBody = QueryStudioAppDomainListOpenResponseBody;
class QueryStudioAppDomainListOpenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryStudioAppDomainListOpenResponseBody,
        };
    }
}
exports.QueryStudioAppDomainListOpenResponse = QueryStudioAppDomainListOpenResponse;
class QueryStudioAppListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fuzzyName: 'FuzzyName',
            iotInstanceId: 'IotInstanceId',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            projectId: 'ProjectId',
            types: 'Types',
        };
    }
    static types() {
        return {
            fuzzyName: 'string',
            iotInstanceId: 'string',
            pageNo: 'number',
            pageSize: 'number',
            projectId: 'string',
            types: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryStudioAppListRequest = QueryStudioAppListRequest;
class QueryStudioAppListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryStudioAppListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryStudioAppListResponseBody = QueryStudioAppListResponseBody;
class QueryStudioAppListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryStudioAppListResponseBody,
        };
    }
}
exports.QueryStudioAppListResponse = QueryStudioAppListResponse;
class QueryStudioAppPageListOpenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            iotInstanceId: 'IotInstanceId',
            isRelease: 'IsRelease',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            appId: 'string',
            iotInstanceId: 'string',
            isRelease: 'boolean',
            pageNo: 'number',
            pageSize: 'number',
            projectId: 'string',
        };
    }
}
exports.QueryStudioAppPageListOpenRequest = QueryStudioAppPageListOpenRequest;
class QueryStudioAppPageListOpenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryStudioAppPageListOpenResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryStudioAppPageListOpenResponseBody = QueryStudioAppPageListOpenResponseBody;
class QueryStudioAppPageListOpenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryStudioAppPageListOpenResponseBody,
        };
    }
}
exports.QueryStudioAppPageListOpenResponse = QueryStudioAppPageListOpenResponse;
class QueryStudioProjectListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            name: 'string',
            pageNo: 'number',
            pageSize: 'number',
        };
    }
}
exports.QueryStudioProjectListRequest = QueryStudioProjectListRequest;
class QueryStudioProjectListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryStudioProjectListResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryStudioProjectListResponseBody = QueryStudioProjectListResponseBody;
class QueryStudioProjectListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryStudioProjectListResponseBody,
        };
    }
}
exports.QueryStudioProjectListResponse = QueryStudioProjectListResponse;
class QuerySubscribeRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            type: 'Type',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
            type: 'string',
        };
    }
}
exports.QuerySubscribeRelationRequest = QuerySubscribeRelationRequest;
class QuerySubscribeRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            consumerGroupIds: 'ConsumerGroupIds',
            deviceDataFlag: 'DeviceDataFlag',
            deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
            deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
            deviceTagFlag: 'DeviceTagFlag',
            deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
            errorMessage: 'ErrorMessage',
            foundDeviceListFlag: 'FoundDeviceListFlag',
            mnsConfiguration: 'MnsConfiguration',
            otaEventFlag: 'OtaEventFlag',
            otaJobFlag: 'OtaJobFlag',
            otaVersionFlag: 'OtaVersionFlag',
            productKey: 'ProductKey',
            requestId: 'RequestId',
            subscribeFlags: 'SubscribeFlags',
            success: 'Success',
            thingHistoryFlag: 'ThingHistoryFlag',
            type: 'Type',
        };
    }
    static types() {
        return {
            code: 'string',
            consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
            deviceDataFlag: 'boolean',
            deviceLifeCycleFlag: 'boolean',
            deviceStatusChangeFlag: 'boolean',
            deviceTagFlag: 'boolean',
            deviceTopoLifeCycleFlag: 'boolean',
            errorMessage: 'string',
            foundDeviceListFlag: 'boolean',
            mnsConfiguration: 'string',
            otaEventFlag: 'boolean',
            otaJobFlag: 'boolean',
            otaVersionFlag: 'boolean',
            productKey: 'string',
            requestId: 'string',
            subscribeFlags: 'string',
            success: 'boolean',
            thingHistoryFlag: 'boolean',
            type: 'string',
        };
    }
}
exports.QuerySubscribeRelationResponseBody = QuerySubscribeRelationResponseBody;
class QuerySubscribeRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySubscribeRelationResponseBody,
        };
    }
}
exports.QuerySubscribeRelationResponse = QuerySubscribeRelationResponse;
class QuerySummarySceneRuleLogRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            endTime: 'EndTime',
            iotInstanceId: 'IotInstanceId',
            pageSize: 'PageSize',
            ruleId: 'RuleId',
            startTime: 'StartTime',
            status: 'Status',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            endTime: 'number',
            iotInstanceId: 'string',
            pageSize: 'number',
            ruleId: 'string',
            startTime: 'number',
            status: 'string',
        };
    }
}
exports.QuerySummarySceneRuleLogRequest = QuerySummarySceneRuleLogRequest;
class QuerySummarySceneRuleLogResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySummarySceneRuleLogResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySummarySceneRuleLogResponseBody = QuerySummarySceneRuleLogResponseBody;
class QuerySummarySceneRuleLogResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySummarySceneRuleLogResponseBody,
        };
    }
}
exports.QuerySummarySceneRuleLogResponse = QuerySummarySceneRuleLogResponse;
class QuerySuperDeviceGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            groupId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.QuerySuperDeviceGroupRequest = QuerySuperDeviceGroupRequest;
class QuerySuperDeviceGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySuperDeviceGroupResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySuperDeviceGroupResponseBody = QuerySuperDeviceGroupResponseBody;
class QuerySuperDeviceGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySuperDeviceGroupResponseBody,
        };
    }
}
exports.QuerySuperDeviceGroupResponse = QuerySuperDeviceGroupResponse;
class QueryTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            taskId: 'string',
        };
    }
}
exports.QueryTaskRequest = QueryTaskRequest;
class QueryTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryTaskResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryTaskResponseBody = QueryTaskResponseBody;
class QueryTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryTaskResponseBody,
        };
    }
}
exports.QueryTaskResponse = QueryTaskResponse;
class QueryThingModelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionBlockId: 'FunctionBlockId',
            iotInstanceId: 'IotInstanceId',
            modelVersion: 'ModelVersion',
            productKey: 'ProductKey',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            functionBlockId: 'string',
            iotInstanceId: 'string',
            modelVersion: 'string',
            productKey: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.QueryThingModelRequest = QueryThingModelRequest;
class QueryThingModelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            productKey: 'ProductKey',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryThingModelResponseBodyData,
            errorMessage: 'string',
            productKey: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryThingModelResponseBody = QueryThingModelResponseBody;
class QueryThingModelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryThingModelResponseBody,
        };
    }
}
exports.QueryThingModelResponse = QueryThingModelResponse;
class QueryThingModelExtendConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionBlockId: 'FunctionBlockId',
            iotInstanceId: 'IotInstanceId',
            modelVersion: 'ModelVersion',
            productKey: 'ProductKey',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            functionBlockId: 'string',
            iotInstanceId: 'string',
            modelVersion: 'string',
            productKey: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.QueryThingModelExtendConfigRequest = QueryThingModelExtendConfigRequest;
class QueryThingModelExtendConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryThingModelExtendConfigResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryThingModelExtendConfigResponseBody = QueryThingModelExtendConfigResponseBody;
class QueryThingModelExtendConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryThingModelExtendConfigResponseBody,
        };
    }
}
exports.QueryThingModelExtendConfigResponse = QueryThingModelExtendConfigResponse;
class QueryThingModelExtendConfigPublishedRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionBlockId: 'FunctionBlockId',
            iotInstanceId: 'IotInstanceId',
            modelVersion: 'ModelVersion',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            functionBlockId: 'string',
            iotInstanceId: 'string',
            modelVersion: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryThingModelExtendConfigPublishedRequest = QueryThingModelExtendConfigPublishedRequest;
class QueryThingModelExtendConfigPublishedResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryThingModelExtendConfigPublishedResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryThingModelExtendConfigPublishedResponseBody = QueryThingModelExtendConfigPublishedResponseBody;
class QueryThingModelExtendConfigPublishedResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryThingModelExtendConfigPublishedResponseBody,
        };
    }
}
exports.QueryThingModelExtendConfigPublishedResponse = QueryThingModelExtendConfigPublishedResponse;
class QueryThingModelPublishedRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionBlockId: 'FunctionBlockId',
            iotInstanceId: 'IotInstanceId',
            modelVersion: 'ModelVersion',
            productKey: 'ProductKey',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            functionBlockId: 'string',
            iotInstanceId: 'string',
            modelVersion: 'string',
            productKey: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.QueryThingModelPublishedRequest = QueryThingModelPublishedRequest;
class QueryThingModelPublishedResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            productKey: 'ProductKey',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryThingModelPublishedResponseBodyData,
            errorMessage: 'string',
            productKey: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryThingModelPublishedResponseBody = QueryThingModelPublishedResponseBody;
class QueryThingModelPublishedResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryThingModelPublishedResponseBody,
        };
    }
}
exports.QueryThingModelPublishedResponse = QueryThingModelPublishedResponse;
class QueryTopicConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryTopicConfigRequest = QueryTopicConfigRequest;
class QueryTopicConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryTopicConfigResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryTopicConfigResponseBody = QueryTopicConfigResponseBody;
class QueryTopicConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryTopicConfigResponseBody,
        };
    }
}
exports.QueryTopicConfigResponse = QueryTopicConfigResponse;
class QueryTopicReverseRouteTableRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            regionId: 'RegionId',
            topic: 'Topic',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            regionId: 'string',
            topic: 'string',
        };
    }
}
exports.QueryTopicReverseRouteTableRequest = QueryTopicReverseRouteTableRequest;
class QueryTopicReverseRouteTableResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            srcTopics: 'SrcTopics',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            srcTopics: QueryTopicReverseRouteTableResponseBodySrcTopics,
            success: 'boolean',
        };
    }
}
exports.QueryTopicReverseRouteTableResponseBody = QueryTopicReverseRouteTableResponseBody;
class QueryTopicReverseRouteTableResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryTopicReverseRouteTableResponseBody,
        };
    }
}
exports.QueryTopicReverseRouteTableResponse = QueryTopicReverseRouteTableResponse;
class QueryTopicRouteTableRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            topic: 'Topic',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            topic: 'string',
        };
    }
}
exports.QueryTopicRouteTableRequest = QueryTopicRouteTableRequest;
class QueryTopicRouteTableResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            dstTopics: 'DstTopics',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            dstTopics: QueryTopicRouteTableResponseBodyDstTopics,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryTopicRouteTableResponseBody = QueryTopicRouteTableResponseBody;
class QueryTopicRouteTableResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryTopicRouteTableResponseBody,
        };
    }
}
exports.QueryTopicRouteTableResponse = QueryTopicRouteTableResponse;
class QueryVehicleDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryVehicleDeviceRequest = QueryVehicleDeviceRequest;
class QueryVehicleDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryVehicleDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryVehicleDeviceResponseBody = QueryVehicleDeviceResponseBody;
class QueryVehicleDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryVehicleDeviceResponseBody,
        };
    }
}
exports.QueryVehicleDeviceResponse = QueryVehicleDeviceResponse;
class RRpcRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'ContentType',
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            requestBase64Byte: 'RequestBase64Byte',
            timeout: 'Timeout',
            topic: 'Topic',
        };
    }
    static types() {
        return {
            contentType: 'string',
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            requestBase64Byte: 'string',
            timeout: 'number',
            topic: 'string',
        };
    }
}
exports.RRpcRequest = RRpcRequest;
class RRpcResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            messageId: 'MessageId',
            payloadBase64Byte: 'PayloadBase64Byte',
            requestId: 'RequestId',
            rrpcCode: 'RrpcCode',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            messageId: 'number',
            payloadBase64Byte: 'string',
            requestId: 'string',
            rrpcCode: 'string',
            success: 'boolean',
        };
    }
}
exports.RRpcResponseBody = RRpcResponseBody;
class RRpcResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RRpcResponseBody,
        };
    }
}
exports.RRpcResponse = RRpcResponse;
class ReBindLicenseDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceNameList: 'DeviceNameList',
            iotInstanceId: 'IotInstanceId',
            licenseCode: 'LicenseCode',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceNameList: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            licenseCode: 'string',
            productKey: 'string',
        };
    }
}
exports.ReBindLicenseDeviceRequest = ReBindLicenseDeviceRequest;
class ReBindLicenseDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ReBindLicenseDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ReBindLicenseDeviceResponseBody = ReBindLicenseDeviceResponseBody;
class ReBindLicenseDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReBindLicenseDeviceResponseBody,
        };
    }
}
exports.ReBindLicenseDeviceResponse = ReBindLicenseDeviceResponse;
class RecognizeCarNumRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            url: 'Url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
}
exports.RecognizeCarNumRequest = RecognizeCarNumRequest;
class RecognizeCarNumResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RecognizeCarNumResponseBody = RecognizeCarNumResponseBody;
class RecognizeCarNumResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeCarNumResponseBody,
        };
    }
}
exports.RecognizeCarNumResponse = RecognizeCarNumResponse;
class RecognizePictureGeneralRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            url: 'Url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
}
exports.RecognizePictureGeneralRequest = RecognizePictureGeneralRequest;
class RecognizePictureGeneralResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RecognizePictureGeneralResponseBody = RecognizePictureGeneralResponseBody;
class RecognizePictureGeneralResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizePictureGeneralResponseBody,
        };
    }
}
exports.RecognizePictureGeneralResponse = RecognizePictureGeneralResponse;
class RefreshDeviceTunnelSharePasswordRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.RefreshDeviceTunnelSharePasswordRequest = RefreshDeviceTunnelSharePasswordRequest;
class RefreshDeviceTunnelSharePasswordResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            password: 'Password',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            password: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RefreshDeviceTunnelSharePasswordResponseBody = RefreshDeviceTunnelSharePasswordResponseBody;
class RefreshDeviceTunnelSharePasswordResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RefreshDeviceTunnelSharePasswordResponseBody,
        };
    }
}
exports.RefreshDeviceTunnelSharePasswordResponse = RefreshDeviceTunnelSharePasswordResponse;
class RefreshStudioAppTokenOpenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            iotInstanceId: 'IotInstanceId',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            appId: 'string',
            iotInstanceId: 'string',
            projectId: 'string',
        };
    }
}
exports.RefreshStudioAppTokenOpenRequest = RefreshStudioAppTokenOpenRequest;
class RefreshStudioAppTokenOpenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: RefreshStudioAppTokenOpenResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RefreshStudioAppTokenOpenResponseBody = RefreshStudioAppTokenOpenResponseBody;
class RefreshStudioAppTokenOpenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RefreshStudioAppTokenOpenResponseBody,
        };
    }
}
exports.RefreshStudioAppTokenOpenResponse = RefreshStudioAppTokenOpenResponse;
class RegisterDeviceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appKey: 'AppKey',
            devEui: 'DevEui',
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            joinEui: 'JoinEui',
            loraNodeType: 'LoraNodeType',
            nickname: 'Nickname',
            pinCode: 'PinCode',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            appKey: 'string',
            devEui: 'string',
            deviceName: 'string',
            iotInstanceId: 'string',
            joinEui: 'string',
            loraNodeType: 'string',
            nickname: 'string',
            pinCode: 'string',
            productKey: 'string',
        };
    }
}
exports.RegisterDeviceRequest = RegisterDeviceRequest;
class RegisterDeviceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: RegisterDeviceResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RegisterDeviceResponseBody = RegisterDeviceResponseBody;
class RegisterDeviceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RegisterDeviceResponseBody,
        };
    }
}
exports.RegisterDeviceResponse = RegisterDeviceResponse;
class ReleaseEdgeDriverVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            driverVersion: 'DriverVersion',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            driverVersion: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.ReleaseEdgeDriverVersionRequest = ReleaseEdgeDriverVersionRequest;
class ReleaseEdgeDriverVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ReleaseEdgeDriverVersionResponseBody = ReleaseEdgeDriverVersionResponseBody;
class ReleaseEdgeDriverVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReleaseEdgeDriverVersionResponseBody,
        };
    }
}
exports.ReleaseEdgeDriverVersionResponse = ReleaseEdgeDriverVersionResponse;
class ReleaseProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.ReleaseProductRequest = ReleaseProductRequest;
class ReleaseProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ReleaseProductResponseBody = ReleaseProductResponseBody;
class ReleaseProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReleaseProductResponseBody,
        };
    }
}
exports.ReleaseProductResponse = ReleaseProductResponse;
class RemoveThingTopoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.RemoveThingTopoRequest = RemoveThingTopoRequest;
class RemoveThingTopoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RemoveThingTopoResponseBody = RemoveThingTopoResponseBody;
class RemoveThingTopoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RemoveThingTopoResponseBody,
        };
    }
}
exports.RemoveThingTopoResponse = RemoveThingTopoResponse;
class ReplaceEdgeInstanceGatewayRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentGatewayId: 'CurrentGatewayId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            newGatewayId: 'NewGatewayId',
        };
    }
    static types() {
        return {
            currentGatewayId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
            newGatewayId: 'string',
        };
    }
}
exports.ReplaceEdgeInstanceGatewayRequest = ReplaceEdgeInstanceGatewayRequest;
class ReplaceEdgeInstanceGatewayResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ReplaceEdgeInstanceGatewayResponseBody = ReplaceEdgeInstanceGatewayResponseBody;
class ReplaceEdgeInstanceGatewayResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReplaceEdgeInstanceGatewayResponseBody,
        };
    }
}
exports.ReplaceEdgeInstanceGatewayResponse = ReplaceEdgeInstanceGatewayResponse;
class RerunJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            jobId: 'string',
        };
    }
}
exports.RerunJobRequest = RerunJobRequest;
class RerunJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RerunJobResponseBody = RerunJobResponseBody;
class RerunJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RerunJobResponseBody,
        };
    }
}
exports.RerunJobResponse = RerunJobResponse;
class ResetConsumerGroupPositionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            groupId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.ResetConsumerGroupPositionRequest = ResetConsumerGroupPositionRequest;
class ResetConsumerGroupPositionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ResetConsumerGroupPositionResponseBody = ResetConsumerGroupPositionResponseBody;
class ResetConsumerGroupPositionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ResetConsumerGroupPositionResponseBody,
        };
    }
}
exports.ResetConsumerGroupPositionResponse = ResetConsumerGroupPositionResponse;
class ResetThingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.ResetThingRequest = ResetThingRequest;
class ResetThingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            jobId: 'JobId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            jobId: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ResetThingResponseBody = ResetThingResponseBody;
class ResetThingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ResetThingResponseBody,
        };
    }
}
exports.ResetThingResponse = ResetThingResponse;
class RetrySoundCodeLabelBatchRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            batchCode: 'BatchCode',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            batchCode: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.RetrySoundCodeLabelBatchRequest = RetrySoundCodeLabelBatchRequest;
class RetrySoundCodeLabelBatchResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RetrySoundCodeLabelBatchResponseBody = RetrySoundCodeLabelBatchResponseBody;
class RetrySoundCodeLabelBatchResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RetrySoundCodeLabelBatchResponseBody,
        };
    }
}
exports.RetrySoundCodeLabelBatchResponse = RetrySoundCodeLabelBatchResponse;
class ReupgradeOTATaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            jobId: 'string',
            taskId: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ReupgradeOTATaskRequest = ReupgradeOTATaskRequest;
class ReupgradeOTATaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ReupgradeOTATaskResponseBody = ReupgradeOTATaskResponseBody;
class ReupgradeOTATaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReupgradeOTATaskResponseBody,
        };
    }
}
exports.ReupgradeOTATaskResponse = ReupgradeOTATaskResponse;
class SaveDevicePropRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            props: 'Props',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            props: 'string',
        };
    }
}
exports.SaveDevicePropRequest = SaveDevicePropRequest;
class SaveDevicePropResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SaveDevicePropResponseBody = SaveDevicePropResponseBody;
class SaveDevicePropResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SaveDevicePropResponseBody,
        };
    }
}
exports.SaveDevicePropResponse = SaveDevicePropResponse;
class SaveScriptRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            parserId: 'ParserId',
            scriptDraft: 'ScriptDraft',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            parserId: 'number',
            scriptDraft: 'string',
        };
    }
}
exports.SaveScriptRequest = SaveScriptRequest;
class SaveScriptResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SaveScriptResponseBody = SaveScriptResponseBody;
class SaveScriptResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SaveScriptResponseBody,
        };
    }
}
exports.SaveScriptResponse = SaveScriptResponse;
class SetDeviceDesiredPropertyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            items: 'Items',
            productKey: 'ProductKey',
            versions: 'Versions',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            items: 'string',
            productKey: 'string',
            versions: 'string',
        };
    }
}
exports.SetDeviceDesiredPropertyRequest = SetDeviceDesiredPropertyRequest;
class SetDeviceDesiredPropertyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: SetDeviceDesiredPropertyResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetDeviceDesiredPropertyResponseBody = SetDeviceDesiredPropertyResponseBody;
class SetDeviceDesiredPropertyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetDeviceDesiredPropertyResponseBody,
        };
    }
}
exports.SetDeviceDesiredPropertyResponse = SetDeviceDesiredPropertyResponse;
class SetDeviceGroupTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            groupType: 'GroupType',
            iotInstanceId: 'IotInstanceId',
            tagString: 'TagString',
        };
    }
    static types() {
        return {
            groupId: 'string',
            groupType: 'string',
            iotInstanceId: 'string',
            tagString: 'string',
        };
    }
}
exports.SetDeviceGroupTagsRequest = SetDeviceGroupTagsRequest;
class SetDeviceGroupTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetDeviceGroupTagsResponseBody = SetDeviceGroupTagsResponseBody;
class SetDeviceGroupTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetDeviceGroupTagsResponseBody,
        };
    }
}
exports.SetDeviceGroupTagsResponse = SetDeviceGroupTagsResponse;
class SetDevicePropertyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            items: 'Items',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            items: 'string',
            productKey: 'string',
        };
    }
}
exports.SetDevicePropertyRequest = SetDevicePropertyRequest;
class SetDevicePropertyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: SetDevicePropertyResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetDevicePropertyResponseBody = SetDevicePropertyResponseBody;
class SetDevicePropertyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetDevicePropertyResponseBody,
        };
    }
}
exports.SetDevicePropertyResponse = SetDevicePropertyResponse;
class SetDevicesPropertyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            items: 'Items',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: { 'type': 'array', 'itemType': 'string' },
            iotInstanceId: 'string',
            items: 'string',
            productKey: 'string',
        };
    }
}
exports.SetDevicesPropertyRequest = SetDevicesPropertyRequest;
class SetDevicesPropertyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetDevicesPropertyResponseBody = SetDevicesPropertyResponseBody;
class SetDevicesPropertyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetDevicesPropertyResponseBody,
        };
    }
}
exports.SetDevicesPropertyResponse = SetDevicesPropertyResponse;
class SetEdgeInstanceDriverConfigsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configs: 'Configs',
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            configs: { 'type': 'array', 'itemType': SetEdgeInstanceDriverConfigsRequestConfigs },
            driverId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.SetEdgeInstanceDriverConfigsRequest = SetEdgeInstanceDriverConfigsRequest;
class SetEdgeInstanceDriverConfigsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetEdgeInstanceDriverConfigsResponseBody = SetEdgeInstanceDriverConfigsResponseBody;
class SetEdgeInstanceDriverConfigsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetEdgeInstanceDriverConfigsResponseBody,
        };
    }
}
exports.SetEdgeInstanceDriverConfigsResponse = SetEdgeInstanceDriverConfigsResponse;
class SetProductCertInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            issueModel: 'IssueModel',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            issueModel: 'number',
            productKey: 'string',
        };
    }
}
exports.SetProductCertInfoRequest = SetProductCertInfoRequest;
class SetProductCertInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetProductCertInfoResponseBody = SetProductCertInfoResponseBody;
class SetProductCertInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetProductCertInfoResponseBody,
        };
    }
}
exports.SetProductCertInfoResponse = SetProductCertInfoResponse;
class SetStudioProjectCooperationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            status: 'Status',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            status: 'string',
        };
    }
}
exports.SetStudioProjectCooperationRequest = SetStudioProjectCooperationRequest;
class SetStudioProjectCooperationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetStudioProjectCooperationResponseBody = SetStudioProjectCooperationResponseBody;
class SetStudioProjectCooperationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetStudioProjectCooperationResponseBody,
        };
    }
}
exports.SetStudioProjectCooperationResponse = SetStudioProjectCooperationResponse;
class SetupStudioAppAuthModeOpenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            authMode: 'AuthMode',
            iotInstanceId: 'IotInstanceId',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            appId: 'string',
            authMode: 'number',
            iotInstanceId: 'string',
            projectId: 'string',
        };
    }
}
exports.SetupStudioAppAuthModeOpenRequest = SetupStudioAppAuthModeOpenRequest;
class SetupStudioAppAuthModeOpenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: SetupStudioAppAuthModeOpenResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetupStudioAppAuthModeOpenResponseBody = SetupStudioAppAuthModeOpenResponseBody;
class SetupStudioAppAuthModeOpenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetupStudioAppAuthModeOpenResponseBody,
        };
    }
}
exports.SetupStudioAppAuthModeOpenResponse = SetupStudioAppAuthModeOpenResponse;
class ShareSpeechByCombinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            combinationList: 'CombinationList',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            speechId: 'SpeechId',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            combinationList: { 'type': 'array', 'itemType': 'string' },
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            speechId: 'string',
        };
    }
}
exports.ShareSpeechByCombinationRequest = ShareSpeechByCombinationRequest;
class ShareSpeechByCombinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ShareSpeechByCombinationResponseBody = ShareSpeechByCombinationResponseBody;
class ShareSpeechByCombinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ShareSpeechByCombinationResponseBody,
        };
    }
}
exports.ShareSpeechByCombinationResponse = ShareSpeechByCombinationResponse;
class SpeechByCombinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            combinationList: 'CombinationList',
            deviceName: 'DeviceName',
            enforceFlag: 'EnforceFlag',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            speechId: 'SpeechId',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            combinationList: { 'type': 'array', 'itemType': 'string' },
            deviceName: 'string',
            enforceFlag: 'boolean',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            speechId: 'string',
        };
    }
}
exports.SpeechByCombinationRequest = SpeechByCombinationRequest;
class SpeechByCombinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SpeechByCombinationResponseBody = SpeechByCombinationResponseBody;
class SpeechByCombinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SpeechByCombinationResponseBody,
        };
    }
}
exports.SpeechByCombinationResponse = SpeechByCombinationResponse;
class SpeechBySynthesisRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            speechId: 'SpeechId',
            speechRate: 'SpeechRate',
            text: 'Text',
            voice: 'Voice',
            volume: 'Volume',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            speechId: 'string',
            speechRate: 'number',
            text: 'string',
            voice: 'string',
            volume: 'number',
        };
    }
}
exports.SpeechBySynthesisRequest = SpeechBySynthesisRequest;
class SpeechBySynthesisResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SpeechBySynthesisResponseBody = SpeechBySynthesisResponseBody;
class SpeechBySynthesisResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SpeechBySynthesisResponseBody,
        };
    }
}
exports.SpeechBySynthesisResponse = SpeechBySynthesisResponse;
class StartParserRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            parserId: 'number',
        };
    }
}
exports.StartParserRequest = StartParserRequest;
class StartParserResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.StartParserResponseBody = StartParserResponseBody;
class StartParserResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartParserResponseBody,
        };
    }
}
exports.StartParserResponse = StartParserResponse;
class StartRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleId: 'number',
        };
    }
}
exports.StartRuleRequest = StartRuleRequest;
class StartRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.StartRuleResponseBody = StartRuleResponseBody;
class StartRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartRuleResponseBody,
        };
    }
}
exports.StartRuleResponse = StartRuleResponse;
class StopParserRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            parserId: 'number',
        };
    }
}
exports.StopParserRequest = StopParserRequest;
class StopParserResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.StopParserResponseBody = StopParserResponseBody;
class StopParserResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StopParserResponseBody,
        };
    }
}
exports.StopParserResponse = StopParserResponse;
class StopRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleId: 'number',
        };
    }
}
exports.StopRuleRequest = StopRuleRequest;
class StopRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.StopRuleResponseBody = StopRuleResponseBody;
class StopRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StopRuleResponseBody,
        };
    }
}
exports.StopRuleResponse = StopRuleResponse;
class SubscribeTopicRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            topic: 'Topic',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            topic: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.SubscribeTopicRequest = SubscribeTopicRequest;
class SubscribeTopicResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SubscribeTopicResponseBody = SubscribeTopicResponseBody;
class SubscribeTopicResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SubscribeTopicResponseBody,
        };
    }
}
exports.SubscribeTopicResponse = SubscribeTopicResponse;
class SyncSpeechByCombinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            combinationList: 'CombinationList',
            deviceName: 'DeviceName',
            enforceFlag: 'EnforceFlag',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            speechId: 'SpeechId',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            combinationList: { 'type': 'array', 'itemType': 'string' },
            deviceName: 'string',
            enforceFlag: 'boolean',
            iotId: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            speechId: 'string',
        };
    }
}
exports.SyncSpeechByCombinationRequest = SyncSpeechByCombinationRequest;
class SyncSpeechByCombinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: SyncSpeechByCombinationResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SyncSpeechByCombinationResponseBody = SyncSpeechByCombinationResponseBody;
class SyncSpeechByCombinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SyncSpeechByCombinationResponseBody,
        };
    }
}
exports.SyncSpeechByCombinationResponse = SyncSpeechByCombinationResponse;
class TestSpeechRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            enableSoundCode: 'EnableSoundCode',
            iotInstanceId: 'IotInstanceId',
            projectCode: 'ProjectCode',
            soundCodeConfig: 'SoundCodeConfig',
            speechRate: 'SpeechRate',
            speechType: 'SpeechType',
            text: 'Text',
            voice: 'Voice',
            volume: 'Volume',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            enableSoundCode: 'boolean',
            iotInstanceId: 'string',
            projectCode: 'string',
            soundCodeConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            speechRate: 'number',
            speechType: 'string',
            text: 'string',
            voice: 'string',
            volume: 'number',
        };
    }
}
exports.TestSpeechRequest = TestSpeechRequest;
class TestSpeechShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            enableSoundCode: 'EnableSoundCode',
            iotInstanceId: 'IotInstanceId',
            projectCode: 'ProjectCode',
            soundCodeConfigShrink: 'SoundCodeConfig',
            speechRate: 'SpeechRate',
            speechType: 'SpeechType',
            text: 'Text',
            voice: 'Voice',
            volume: 'Volume',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            enableSoundCode: 'boolean',
            iotInstanceId: 'string',
            projectCode: 'string',
            soundCodeConfigShrink: 'string',
            speechRate: 'number',
            speechType: 'string',
            text: 'string',
            voice: 'string',
            volume: 'number',
        };
    }
}
exports.TestSpeechShrinkRequest = TestSpeechShrinkRequest;
class TestSpeechResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: TestSpeechResponseBodyData,
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.TestSpeechResponseBody = TestSpeechResponseBody;
class TestSpeechResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TestSpeechResponseBody,
        };
    }
}
exports.TestSpeechResponse = TestSpeechResponse;
class TestSwitchRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
        };
    }
}
exports.TestSwitchRequest = TestSwitchRequest;
class TestSwitchResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            iotId: 'IotId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            iotId: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.TestSwitchResponseBody = TestSwitchResponseBody;
class TestSwitchResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TestSwitchResponseBody,
        };
    }
}
exports.TestSwitchResponse = TestSwitchResponse;
class TransformClientIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientId: 'ClientId',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            clientId: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.TransformClientIdRequest = TransformClientIdRequest;
class TransformClientIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.TransformClientIdResponseBody = TransformClientIdResponseBody;
class TransformClientIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TransformClientIdResponseBody,
        };
    }
}
exports.TransformClientIdResponse = TransformClientIdResponse;
class TriggerSceneRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
            ruleId: 'string',
        };
    }
}
exports.TriggerSceneRuleRequest = TriggerSceneRuleRequest;
class TriggerSceneRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.TriggerSceneRuleResponseBody = TriggerSceneRuleResponseBody;
class TriggerSceneRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TriggerSceneRuleResponseBody,
        };
    }
}
exports.TriggerSceneRuleResponse = TriggerSceneRuleResponse;
class UnbindApplicationFromEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applicationId: 'ApplicationId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            applicationId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.UnbindApplicationFromEdgeInstanceRequest = UnbindApplicationFromEdgeInstanceRequest;
class UnbindApplicationFromEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UnbindApplicationFromEdgeInstanceResponseBody = UnbindApplicationFromEdgeInstanceResponseBody;
class UnbindApplicationFromEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnbindApplicationFromEdgeInstanceResponseBody,
        };
    }
}
exports.UnbindApplicationFromEdgeInstanceResponse = UnbindApplicationFromEdgeInstanceResponse;
class UnbindDriverFromEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.UnbindDriverFromEdgeInstanceRequest = UnbindDriverFromEdgeInstanceRequest;
class UnbindDriverFromEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UnbindDriverFromEdgeInstanceResponseBody = UnbindDriverFromEdgeInstanceResponseBody;
class UnbindDriverFromEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnbindDriverFromEdgeInstanceResponseBody,
        };
    }
}
exports.UnbindDriverFromEdgeInstanceResponse = UnbindDriverFromEdgeInstanceResponse;
class UnbindLicenseProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            licenseCode: 'LicenseCode',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            licenseCode: 'string',
            productKey: 'string',
        };
    }
}
exports.UnbindLicenseProductRequest = UnbindLicenseProductRequest;
class UnbindLicenseProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UnbindLicenseProductResponseBody = UnbindLicenseProductResponseBody;
class UnbindLicenseProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnbindLicenseProductResponseBody,
        };
    }
}
exports.UnbindLicenseProductResponse = UnbindLicenseProductResponse;
class UnbindRoleFromEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.UnbindRoleFromEdgeInstanceRequest = UnbindRoleFromEdgeInstanceRequest;
class UnbindRoleFromEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UnbindRoleFromEdgeInstanceResponseBody = UnbindRoleFromEdgeInstanceResponseBody;
class UnbindRoleFromEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnbindRoleFromEdgeInstanceResponseBody,
        };
    }
}
exports.UnbindRoleFromEdgeInstanceResponse = UnbindRoleFromEdgeInstanceResponse;
class UnbindSceneRuleFromEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
            ruleId: 'string',
        };
    }
}
exports.UnbindSceneRuleFromEdgeInstanceRequest = UnbindSceneRuleFromEdgeInstanceRequest;
class UnbindSceneRuleFromEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UnbindSceneRuleFromEdgeInstanceResponseBody = UnbindSceneRuleFromEdgeInstanceResponseBody;
class UnbindSceneRuleFromEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnbindSceneRuleFromEdgeInstanceResponseBody,
        };
    }
}
exports.UnbindSceneRuleFromEdgeInstanceResponse = UnbindSceneRuleFromEdgeInstanceResponse;
class UpdateConsumerGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            iotInstanceId: 'IotInstanceId',
            newGroupName: 'NewGroupName',
        };
    }
    static types() {
        return {
            groupId: 'string',
            iotInstanceId: 'string',
            newGroupName: 'string',
        };
    }
}
exports.UpdateConsumerGroupRequest = UpdateConsumerGroupRequest;
class UpdateConsumerGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateConsumerGroupResponseBody = UpdateConsumerGroupResponseBody;
class UpdateConsumerGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateConsumerGroupResponseBody,
        };
    }
}
exports.UpdateConsumerGroupResponse = UpdateConsumerGroupResponse;
class UpdateDestinationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
            description: 'Description',
            destinationId: 'DestinationId',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            type: 'Type',
        };
    }
    static types() {
        return {
            configuration: 'string',
            description: 'string',
            destinationId: 'number',
            iotInstanceId: 'string',
            name: 'string',
            type: 'string',
        };
    }
}
exports.UpdateDestinationRequest = UpdateDestinationRequest;
class UpdateDestinationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateDestinationResponseBody = UpdateDestinationResponseBody;
class UpdateDestinationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateDestinationResponseBody,
        };
    }
}
exports.UpdateDestinationResponse = UpdateDestinationResponse;
class UpdateDeviceGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupDesc: 'GroupDesc',
            groupId: 'GroupId',
            groupType: 'GroupType',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            groupDesc: 'string',
            groupId: 'string',
            groupType: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.UpdateDeviceGroupRequest = UpdateDeviceGroupRequest;
class UpdateDeviceGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateDeviceGroupResponseBody = UpdateDeviceGroupResponseBody;
class UpdateDeviceGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateDeviceGroupResponseBody,
        };
    }
}
exports.UpdateDeviceGroupResponse = UpdateDeviceGroupResponse;
class UpdateDeviceShadowRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deltaUpdate: 'DeltaUpdate',
            deviceName: 'DeviceName',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            shadowMessage: 'ShadowMessage',
        };
    }
    static types() {
        return {
            deltaUpdate: 'boolean',
            deviceName: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            shadowMessage: 'string',
        };
    }
}
exports.UpdateDeviceShadowRequest = UpdateDeviceShadowRequest;
class UpdateDeviceShadowResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateDeviceShadowResponseBody = UpdateDeviceShadowResponseBody;
class UpdateDeviceShadowResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateDeviceShadowResponseBody,
        };
    }
}
exports.UpdateDeviceShadowResponse = UpdateDeviceShadowResponse;
class UpdateEdgeDriverVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            argument: 'Argument',
            configCheckRule: 'ConfigCheckRule',
            containerConfig: 'ContainerConfig',
            description: 'Description',
            driverConfig: 'DriverConfig',
            driverId: 'DriverId',
            driverVersion: 'DriverVersion',
            edgeVersion: 'EdgeVersion',
            iotInstanceId: 'IotInstanceId',
            sourceConfig: 'SourceConfig',
        };
    }
    static types() {
        return {
            argument: 'string',
            configCheckRule: 'string',
            containerConfig: 'string',
            description: 'string',
            driverConfig: 'string',
            driverId: 'string',
            driverVersion: 'string',
            edgeVersion: 'string',
            iotInstanceId: 'string',
            sourceConfig: 'string',
        };
    }
}
exports.UpdateEdgeDriverVersionRequest = UpdateEdgeDriverVersionRequest;
class UpdateEdgeDriverVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateEdgeDriverVersionResponseBody = UpdateEdgeDriverVersionResponseBody;
class UpdateEdgeDriverVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateEdgeDriverVersionResponseBody,
        };
    }
}
exports.UpdateEdgeDriverVersionResponse = UpdateEdgeDriverVersionResponse;
class UpdateEdgeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizEnable: 'BizEnable',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            spec: 'Spec',
            tags: 'Tags',
        };
    }
    static types() {
        return {
            bizEnable: 'boolean',
            instanceId: 'string',
            iotInstanceId: 'string',
            name: 'string',
            spec: 'number',
            tags: 'string',
        };
    }
}
exports.UpdateEdgeInstanceRequest = UpdateEdgeInstanceRequest;
class UpdateEdgeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateEdgeInstanceResponseBody = UpdateEdgeInstanceResponseBody;
class UpdateEdgeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateEdgeInstanceResponseBody,
        };
    }
}
exports.UpdateEdgeInstanceResponse = UpdateEdgeInstanceResponse;
class UpdateEdgeInstanceChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelId: 'ChannelId',
            channelName: 'ChannelName',
            configs: 'Configs',
            driverId: 'DriverId',
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
        };
    }
    static types() {
        return {
            channelId: 'string',
            channelName: 'string',
            configs: { 'type': 'array', 'itemType': UpdateEdgeInstanceChannelRequestConfigs },
            driverId: 'string',
            instanceId: 'string',
            iotInstanceId: 'string',
        };
    }
}
exports.UpdateEdgeInstanceChannelRequest = UpdateEdgeInstanceChannelRequest;
class UpdateEdgeInstanceChannelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateEdgeInstanceChannelResponseBody = UpdateEdgeInstanceChannelResponseBody;
class UpdateEdgeInstanceChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateEdgeInstanceChannelResponseBody,
        };
    }
}
exports.UpdateEdgeInstanceChannelResponse = UpdateEdgeInstanceChannelResponse;
class UpdateEdgeInstanceMessageRoutingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            routeId: 'RouteId',
            sourceData: 'SourceData',
            sourceType: 'SourceType',
            targetData: 'TargetData',
            targetIotHubQos: 'TargetIotHubQos',
            targetType: 'TargetType',
            topicFilter: 'TopicFilter',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            iotInstanceId: 'string',
            name: 'string',
            routeId: 'number',
            sourceData: 'string',
            sourceType: 'string',
            targetData: 'string',
            targetIotHubQos: 'number',
            targetType: 'string',
            topicFilter: 'string',
        };
    }
}
exports.UpdateEdgeInstanceMessageRoutingRequest = UpdateEdgeInstanceMessageRoutingRequest;
class UpdateEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateEdgeInstanceMessageRoutingResponseBody = UpdateEdgeInstanceMessageRoutingResponseBody;
class UpdateEdgeInstanceMessageRoutingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateEdgeInstanceMessageRoutingResponseBody,
        };
    }
}
exports.UpdateEdgeInstanceMessageRoutingResponse = UpdateEdgeInstanceMessageRoutingResponse;
class UpdateJobRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
            rolloutConfig: 'RolloutConfig',
            timeoutConfig: 'TimeoutConfig',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            jobId: 'string',
            rolloutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            timeoutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.UpdateJobRequest = UpdateJobRequest;
class UpdateJobShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            jobId: 'JobId',
            rolloutConfigShrink: 'RolloutConfig',
            timeoutConfigShrink: 'TimeoutConfig',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            jobId: 'string',
            rolloutConfigShrink: 'string',
            timeoutConfigShrink: 'string',
        };
    }
}
exports.UpdateJobShrinkRequest = UpdateJobShrinkRequest;
class UpdateJobResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateJobResponseBody = UpdateJobResponseBody;
class UpdateJobResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateJobResponseBody,
        };
    }
}
exports.UpdateJobResponse = UpdateJobResponse;
class UpdateOTAModuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliasName: 'AliasName',
            desc: 'Desc',
            iotInstanceId: 'IotInstanceId',
            moduleName: 'ModuleName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            aliasName: 'string',
            desc: 'string',
            iotInstanceId: 'string',
            moduleName: 'string',
            productKey: 'string',
        };
    }
}
exports.UpdateOTAModuleRequest = UpdateOTAModuleRequest;
class UpdateOTAModuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateOTAModuleResponseBody = UpdateOTAModuleResponseBody;
class UpdateOTAModuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateOTAModuleResponseBody,
        };
    }
}
exports.UpdateOTAModuleResponse = UpdateOTAModuleResponse;
class UpdateParserRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            parserId: 'ParserId',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            name: 'string',
            parserId: 'number',
        };
    }
}
exports.UpdateParserRequest = UpdateParserRequest;
class UpdateParserResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateParserResponseBody = UpdateParserResponseBody;
class UpdateParserResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateParserResponseBody,
        };
    }
}
exports.UpdateParserResponse = UpdateParserResponse;
class UpdateParserDataSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            description: 'string',
            iotInstanceId: 'string',
            name: 'string',
        };
    }
}
exports.UpdateParserDataSourceRequest = UpdateParserDataSourceRequest;
class UpdateParserDataSourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateParserDataSourceResponseBody = UpdateParserDataSourceResponseBody;
class UpdateParserDataSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateParserDataSourceResponseBody,
        };
    }
}
exports.UpdateParserDataSourceResponse = UpdateParserDataSourceResponse;
class UpdateProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            productName: 'ProductName',
        };
    }
    static types() {
        return {
            description: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            productName: 'string',
        };
    }
}
exports.UpdateProductRequest = UpdateProductRequest;
class UpdateProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateProductResponseBody = UpdateProductResponseBody;
class UpdateProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateProductResponseBody,
        };
    }
}
exports.UpdateProductResponse = UpdateProductResponse;
class UpdateProductFilterConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            propertyTimestampFilter: 'PropertyTimestampFilter',
            propertyValueFilter: 'PropertyValueFilter',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
            propertyTimestampFilter: 'boolean',
            propertyValueFilter: 'boolean',
        };
    }
}
exports.UpdateProductFilterConfigRequest = UpdateProductFilterConfigRequest;
class UpdateProductFilterConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateProductFilterConfigResponseBody = UpdateProductFilterConfigResponseBody;
class UpdateProductFilterConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateProductFilterConfigResponseBody,
        };
    }
}
exports.UpdateProductFilterConfigResponse = UpdateProductFilterConfigResponse;
class UpdateProductTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            productTag: 'ProductTag',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
            productTag: { 'type': 'array', 'itemType': UpdateProductTagsRequestProductTag },
        };
    }
}
exports.UpdateProductTagsRequest = UpdateProductTagsRequest;
class UpdateProductTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            invalidProductTags: 'InvalidProductTags',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            invalidProductTags: UpdateProductTagsResponseBodyInvalidProductTags,
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateProductTagsResponseBody = UpdateProductTagsResponseBody;
class UpdateProductTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateProductTagsResponseBody,
        };
    }
}
exports.UpdateProductTagsResponse = UpdateProductTagsResponse;
class UpdateProductTopicRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            codec: 'Codec',
            desc: 'Desc',
            enableProxySubscribe: 'EnableProxySubscribe',
            iotInstanceId: 'IotInstanceId',
            operation: 'Operation',
            topicId: 'TopicId',
            topicShortName: 'TopicShortName',
        };
    }
    static types() {
        return {
            codec: 'string',
            desc: 'string',
            enableProxySubscribe: 'boolean',
            iotInstanceId: 'string',
            operation: 'string',
            topicId: 'string',
            topicShortName: 'string',
        };
    }
}
exports.UpdateProductTopicRequest = UpdateProductTopicRequest;
class UpdateProductTopicResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateProductTopicResponseBody = UpdateProductTopicResponseBody;
class UpdateProductTopicResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateProductTopicResponseBody,
        };
    }
}
exports.UpdateProductTopicResponse = UpdateProductTopicResponse;
class UpdateRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            productKey: 'ProductKey',
            ruleDesc: 'RuleDesc',
            ruleId: 'RuleId',
            select: 'Select',
            shortTopic: 'ShortTopic',
            topic: 'Topic',
            topicType: 'TopicType',
            where: 'Where',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            name: 'string',
            productKey: 'string',
            ruleDesc: 'string',
            ruleId: 'number',
            select: 'string',
            shortTopic: 'string',
            topic: 'string',
            topicType: 'number',
            where: 'string',
        };
    }
}
exports.UpdateRuleRequest = UpdateRuleRequest;
class UpdateRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateRuleResponseBody = UpdateRuleResponseBody;
class UpdateRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateRuleResponseBody,
        };
    }
}
exports.UpdateRuleResponse = UpdateRuleResponse;
class UpdateRuleActionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionId: 'ActionId',
            configuration: 'Configuration',
            iotInstanceId: 'IotInstanceId',
            type: 'Type',
        };
    }
    static types() {
        return {
            actionId: 'number',
            configuration: 'string',
            iotInstanceId: 'string',
            type: 'string',
        };
    }
}
exports.UpdateRuleActionRequest = UpdateRuleActionRequest;
class UpdateRuleActionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateRuleActionResponseBody = UpdateRuleActionResponseBody;
class UpdateRuleActionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateRuleActionResponseBody,
        };
    }
}
exports.UpdateRuleActionResponse = UpdateRuleActionResponse;
class UpdateSceneRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            ruleContent: 'RuleContent',
            ruleDescription: 'RuleDescription',
            ruleId: 'RuleId',
            ruleName: 'RuleName',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            ruleContent: 'string',
            ruleDescription: 'string',
            ruleId: 'string',
            ruleName: 'string',
        };
    }
}
exports.UpdateSceneRuleRequest = UpdateSceneRuleRequest;
class UpdateSceneRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateSceneRuleResponseBody = UpdateSceneRuleResponseBody;
class UpdateSceneRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSceneRuleResponseBody,
        };
    }
}
exports.UpdateSceneRuleResponse = UpdateSceneRuleResponse;
class UpdateSchedulePeriodRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            endTime: 'EndTime',
            iotInstanceId: 'IotInstanceId',
            periodCode: 'PeriodCode',
            soundCodeContent: 'SoundCodeContent',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            description: 'string',
            endTime: 'string',
            iotInstanceId: 'string',
            periodCode: 'string',
            soundCodeContent: 'string',
            startTime: 'string',
        };
    }
}
exports.UpdateSchedulePeriodRequest = UpdateSchedulePeriodRequest;
class UpdateSchedulePeriodResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateSchedulePeriodResponseBody = UpdateSchedulePeriodResponseBody;
class UpdateSchedulePeriodResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSchedulePeriodResponseBody,
        };
    }
}
exports.UpdateSchedulePeriodResponse = UpdateSchedulePeriodResponse;
class UpdateSoundCodeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'Duration',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            soundCode: 'SoundCode',
            soundCodeContent: 'SoundCodeContent',
        };
    }
    static types() {
        return {
            duration: 'number',
            iotInstanceId: 'string',
            name: 'string',
            soundCode: 'string',
            soundCodeContent: 'string',
        };
    }
}
exports.UpdateSoundCodeRequest = UpdateSoundCodeRequest;
class UpdateSoundCodeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateSoundCodeResponseBody = UpdateSoundCodeResponseBody;
class UpdateSoundCodeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSoundCodeResponseBody,
        };
    }
}
exports.UpdateSoundCodeResponse = UpdateSoundCodeResponse;
class UpdateSoundCodeLabelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            label: 'Label',
            soundCode: 'SoundCode',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            label: 'string',
            soundCode: 'string',
        };
    }
}
exports.UpdateSoundCodeLabelRequest = UpdateSoundCodeLabelRequest;
class UpdateSoundCodeLabelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateSoundCodeLabelResponseBody = UpdateSoundCodeLabelResponseBody;
class UpdateSoundCodeLabelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSoundCodeLabelResponseBody,
        };
    }
}
exports.UpdateSoundCodeLabelResponse = UpdateSoundCodeLabelResponse;
class UpdateSoundCodeScheduleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            endDate: 'EndDate',
            endTime: 'EndTime',
            iotInstanceId: 'IotInstanceId',
            name: 'Name',
            scheduleCode: 'ScheduleCode',
            startDate: 'StartDate',
            startTime: 'StartTime',
            status: 'Status',
        };
    }
    static types() {
        return {
            description: 'string',
            endDate: 'string',
            endTime: 'string',
            iotInstanceId: 'string',
            name: 'string',
            scheduleCode: 'string',
            startDate: 'string',
            startTime: 'string',
            status: 'string',
        };
    }
}
exports.UpdateSoundCodeScheduleRequest = UpdateSoundCodeScheduleRequest;
class UpdateSoundCodeScheduleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateSoundCodeScheduleResponseBody = UpdateSoundCodeScheduleResponseBody;
class UpdateSoundCodeScheduleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSoundCodeScheduleResponseBody,
        };
    }
}
exports.UpdateSoundCodeScheduleResponse = UpdateSoundCodeScheduleResponse;
class UpdateSpeechRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableSoundCode: 'EnableSoundCode',
            iotInstanceId: 'IotInstanceId',
            projectCode: 'ProjectCode',
            soundCodeConfig: 'SoundCodeConfig',
            speechCode: 'SpeechCode',
            speechRate: 'SpeechRate',
            voice: 'Voice',
            volume: 'Volume',
        };
    }
    static types() {
        return {
            enableSoundCode: 'boolean',
            iotInstanceId: 'string',
            projectCode: 'string',
            soundCodeConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            speechCode: 'string',
            speechRate: 'number',
            voice: 'string',
            volume: 'number',
        };
    }
}
exports.UpdateSpeechRequest = UpdateSpeechRequest;
class UpdateSpeechShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableSoundCode: 'EnableSoundCode',
            iotInstanceId: 'IotInstanceId',
            projectCode: 'ProjectCode',
            soundCodeConfigShrink: 'SoundCodeConfig',
            speechCode: 'SpeechCode',
            speechRate: 'SpeechRate',
            voice: 'Voice',
            volume: 'Volume',
        };
    }
    static types() {
        return {
            enableSoundCode: 'boolean',
            iotInstanceId: 'string',
            projectCode: 'string',
            soundCodeConfigShrink: 'string',
            speechCode: 'string',
            speechRate: 'number',
            voice: 'string',
            volume: 'number',
        };
    }
}
exports.UpdateSpeechShrinkRequest = UpdateSpeechShrinkRequest;
class UpdateSpeechResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateSpeechResponseBody = UpdateSpeechResponseBody;
class UpdateSpeechResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSpeechResponseBody,
        };
    }
}
exports.UpdateSpeechResponse = UpdateSpeechResponse;
class UpdateSubscribeRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            consumerGroupIds: 'ConsumerGroupIds',
            deviceDataFlag: 'DeviceDataFlag',
            deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
            deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
            deviceTagFlag: 'DeviceTagFlag',
            deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
            foundDeviceListFlag: 'FoundDeviceListFlag',
            iotInstanceId: 'IotInstanceId',
            mnsConfiguration: 'MnsConfiguration',
            otaEventFlag: 'OtaEventFlag',
            otaJobFlag: 'OtaJobFlag',
            otaVersionFlag: 'OtaVersionFlag',
            productKey: 'ProductKey',
            subscribeFlags: 'SubscribeFlags',
            thingHistoryFlag: 'ThingHistoryFlag',
            type: 'Type',
        };
    }
    static types() {
        return {
            consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
            deviceDataFlag: 'boolean',
            deviceLifeCycleFlag: 'boolean',
            deviceStatusChangeFlag: 'boolean',
            deviceTagFlag: 'boolean',
            deviceTopoLifeCycleFlag: 'boolean',
            foundDeviceListFlag: 'boolean',
            iotInstanceId: 'string',
            mnsConfiguration: 'string',
            otaEventFlag: 'boolean',
            otaJobFlag: 'boolean',
            otaVersionFlag: 'boolean',
            productKey: 'string',
            subscribeFlags: 'string',
            thingHistoryFlag: 'boolean',
            type: 'string',
        };
    }
}
exports.UpdateSubscribeRelationRequest = UpdateSubscribeRelationRequest;
class UpdateSubscribeRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateSubscribeRelationResponseBody = UpdateSubscribeRelationResponseBody;
class UpdateSubscribeRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSubscribeRelationResponseBody,
        };
    }
}
exports.UpdateSubscribeRelationResponse = UpdateSubscribeRelationResponse;
class UpdateThingModelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionBlockId: 'FunctionBlockId',
            functionBlockName: 'FunctionBlockName',
            identifier: 'Identifier',
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            thingModelJson: 'ThingModelJson',
        };
    }
    static types() {
        return {
            functionBlockId: 'string',
            functionBlockName: 'string',
            identifier: 'string',
            iotInstanceId: 'string',
            productKey: 'string',
            thingModelJson: 'string',
        };
    }
}
exports.UpdateThingModelRequest = UpdateThingModelRequest;
class UpdateThingModelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateThingModelResponseBody = UpdateThingModelResponseBody;
class UpdateThingModelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateThingModelResponseBody,
        };
    }
}
exports.UpdateThingModelResponse = UpdateThingModelResponse;
class UpdateThingScriptRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotInstanceId: 'IotInstanceId',
            productKey: 'ProductKey',
            scriptContent: 'ScriptContent',
            scriptType: 'ScriptType',
        };
    }
    static types() {
        return {
            iotInstanceId: 'string',
            productKey: 'string',
            scriptContent: 'string',
            scriptType: 'string',
        };
    }
}
exports.UpdateThingScriptRequest = UpdateThingScriptRequest;
class UpdateThingScriptResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateThingScriptResponseBody = UpdateThingScriptResponseBody;
class UpdateThingScriptResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateThingScriptResponseBody,
        };
    }
}
exports.UpdateThingScriptResponse = UpdateThingScriptResponse;
class UpdateTopicConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            codec: 'Codec',
            description: 'Description',
            enableBroadcast: 'EnableBroadcast',
            enableProxySubscribe: 'EnableProxySubscribe',
            iotInstanceId: 'IotInstanceId',
            operation: 'Operation',
            productKey: 'ProductKey',
            topicFullName: 'TopicFullName',
        };
    }
    static types() {
        return {
            codec: 'string',
            description: 'string',
            enableBroadcast: 'boolean',
            enableProxySubscribe: 'boolean',
            iotInstanceId: 'string',
            operation: 'string',
            productKey: 'string',
            topicFullName: 'string',
        };
    }
}
exports.UpdateTopicConfigRequest = UpdateTopicConfigRequest;
class UpdateTopicConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateTopicConfigResponseBody = UpdateTopicConfigResponseBody;
class UpdateTopicConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateTopicConfigResponseBody,
        };
    }
}
exports.UpdateTopicConfigResponse = UpdateTopicConfigResponse;
class WriteDevicesHotStorageDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            iotInstanceId: 'IotInstanceId',
            items: 'Items',
            productKey: 'ProductKey',
            userTopic: 'UserTopic',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            iotInstanceId: 'string',
            items: 'string',
            productKey: 'string',
            userTopic: 'string',
        };
    }
}
exports.WriteDevicesHotStorageDataRequest = WriteDevicesHotStorageDataRequest;
class WriteDevicesHotStorageDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            errorMessage: 'ErrorMessage',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            errorMessage: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.WriteDevicesHotStorageDataResponseBody = WriteDevicesHotStorageDataResponseBody;
class WriteDevicesHotStorageDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: WriteDevicesHotStorageDataResponseBody,
        };
    }
}
exports.WriteDevicesHotStorageDataResponse = WriteDevicesHotStorageDataResponse;
class AddShareTaskDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failSum: 'FailSum',
            failedResultCsvFile: 'FailedResultCsvFile',
            progress: 'Progress',
            progressId: 'ProgressId',
            successSum: 'SuccessSum',
        };
    }
    static types() {
        return {
            failSum: 'number',
            failedResultCsvFile: 'string',
            progress: 'number',
            progressId: 'string',
            successSum: 'number',
        };
    }
}
exports.AddShareTaskDeviceResponseBodyData = AddShareTaskDeviceResponseBodyData;
class BatchAddDeviceGroupRelationsRequestDevice extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchAddDeviceGroupRelationsRequestDevice = BatchAddDeviceGroupRelationsRequestDevice;
class BatchAddThingTopoRequestTopoAddItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientId: 'ClientId',
            deviceName: 'DeviceName',
            productKey: 'ProductKey',
            sign: 'Sign',
            signMethod: 'SignMethod',
            timestamp: 'Timestamp',
        };
    }
    static types() {
        return {
            clientId: 'string',
            deviceName: 'string',
            productKey: 'string',
            sign: 'string',
            signMethod: 'string',
            timestamp: 'string',
        };
    }
}
exports.BatchAddThingTopoRequestTopoAddItem = BatchAddThingTopoRequestTopoAddItem;
class BatchBindDevicesIntoProjectRequestDevices extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchBindDevicesIntoProjectRequestDevices = BatchBindDevicesIntoProjectRequestDevices;
class BatchCheckDeviceNamesRequestDeviceNameList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceNickname: 'DeviceNickname',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceNickname: 'string',
        };
    }
}
exports.BatchCheckDeviceNamesRequestDeviceNameList = BatchCheckDeviceNamesRequestDeviceNameList;
class BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            errorMsg: 'ErrorMsg',
            nickName: 'NickName',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            errorMsg: 'string',
            nickName: 'string',
        };
    }
}
exports.BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList = BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList;
class BatchCheckDeviceNamesResponseBodyDataInvalidDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDetailList: 'InvalidDetailList',
        };
    }
    static types() {
        return {
            invalidDetailList: { 'type': 'array', 'itemType': BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList },
        };
    }
}
exports.BatchCheckDeviceNamesResponseBodyDataInvalidDetailList = BatchCheckDeviceNamesResponseBodyDataInvalidDetailList;
class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDeviceName: 'InvalidDeviceName',
        };
    }
    static types() {
        return {
            invalidDeviceName: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList = BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList;
class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDeviceNickname: 'InvalidDeviceNickname',
        };
    }
    static types() {
        return {
            invalidDeviceNickname: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList = BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList;
class BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            repeatDevieNameList: 'RepeatDevieNameList',
        };
    }
    static types() {
        return {
            repeatDevieNameList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList = BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList;
class BatchCheckDeviceNamesResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyId: 'ApplyId',
            invalidDetailList: 'InvalidDetailList',
            invalidDeviceNameList: 'InvalidDeviceNameList',
            invalidDeviceNicknameList: 'InvalidDeviceNicknameList',
            repeatedDeviceNameList: 'RepeatedDeviceNameList',
        };
    }
    static types() {
        return {
            applyId: 'number',
            invalidDetailList: BatchCheckDeviceNamesResponseBodyDataInvalidDetailList,
            invalidDeviceNameList: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList,
            invalidDeviceNicknameList: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList,
            repeatedDeviceNameList: BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList,
        };
    }
}
exports.BatchCheckDeviceNamesResponseBodyData = BatchCheckDeviceNamesResponseBodyData;
class BatchCheckImportDeviceRequestDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            sn: 'Sn',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            sn: 'string',
        };
    }
}
exports.BatchCheckImportDeviceRequestDeviceList = BatchCheckImportDeviceRequestDeviceList;
class BatchCheckImportDeviceResponseBodyDataInvalidDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            errorMsg: 'ErrorMsg',
            sn: 'Sn',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            errorMsg: 'string',
            sn: 'string',
        };
    }
}
exports.BatchCheckImportDeviceResponseBodyDataInvalidDetailList = BatchCheckImportDeviceResponseBodyDataInvalidDetailList;
class BatchCheckImportDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDetailList: 'InvalidDetailList',
            invalidDeviceNameList: 'InvalidDeviceNameList',
            invalidDeviceSecretList: 'InvalidDeviceSecretList',
            invalidSnList: 'InvalidSnList',
            repeatedDeviceNameList: 'RepeatedDeviceNameList',
        };
    }
    static types() {
        return {
            invalidDetailList: { 'type': 'array', 'itemType': BatchCheckImportDeviceResponseBodyDataInvalidDetailList },
            invalidDeviceNameList: { 'type': 'array', 'itemType': 'string' },
            invalidDeviceSecretList: { 'type': 'array', 'itemType': 'string' },
            invalidSnList: { 'type': 'array', 'itemType': 'string' },
            repeatedDeviceNameList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchCheckImportDeviceResponseBodyData = BatchCheckImportDeviceResponseBodyData;
class BatchCheckVehicleDeviceRequestDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceId: 'DeviceId',
            deviceModel: 'DeviceModel',
            deviceName: 'DeviceName',
            manufacturer: 'Manufacturer',
        };
    }
    static types() {
        return {
            deviceId: 'string',
            deviceModel: 'string',
            deviceName: 'string',
            manufacturer: 'string',
        };
    }
}
exports.BatchCheckVehicleDeviceRequestDeviceList = BatchCheckVehicleDeviceRequestDeviceList;
class BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceId: 'DeviceId',
            deviceModel: 'DeviceModel',
            deviceName: 'DeviceName',
            errorMsg: 'ErrorMsg',
            manufacturer: 'Manufacturer',
        };
    }
    static types() {
        return {
            deviceId: 'string',
            deviceModel: 'string',
            deviceName: 'string',
            errorMsg: 'string',
            manufacturer: 'string',
        };
    }
}
exports.BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList = BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList;
class BatchCheckVehicleDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDetailList: 'InvalidDetailList',
            invalidDeviceIdList: 'InvalidDeviceIdList',
            invalidDeviceModelList: 'InvalidDeviceModelList',
            invalidDeviceNameList: 'InvalidDeviceNameList',
            invalidManufacturerList: 'InvalidManufacturerList',
            repeatedDeviceIdList: 'RepeatedDeviceIdList',
            repeatedDeviceNameList: 'RepeatedDeviceNameList',
        };
    }
    static types() {
        return {
            invalidDetailList: { 'type': 'array', 'itemType': BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList },
            invalidDeviceIdList: { 'type': 'array', 'itemType': 'string' },
            invalidDeviceModelList: { 'type': 'array', 'itemType': 'string' },
            invalidDeviceNameList: { 'type': 'array', 'itemType': 'string' },
            invalidManufacturerList: { 'type': 'array', 'itemType': 'string' },
            repeatedDeviceIdList: { 'type': 'array', 'itemType': 'string' },
            repeatedDeviceNameList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchCheckVehicleDeviceResponseBodyData = BatchCheckVehicleDeviceResponseBodyData;
class BatchDeleteDeviceGroupRelationsRequestDevice extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchDeleteDeviceGroupRelationsRequestDevice = BatchDeleteDeviceGroupRelationsRequestDevice;
class BatchGetDeviceBindStatusResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bindStatus: 'BindStatus',
            instanceId: 'InstanceId',
            iotId: 'IotId',
        };
    }
    static types() {
        return {
            bindStatus: 'number',
            instanceId: 'string',
            iotId: 'string',
        };
    }
}
exports.BatchGetDeviceBindStatusResponseBodyData = BatchGetDeviceBindStatusResponseBodyData;
class BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asAddress: 'AsAddress',
            deviceId: 'DeviceId',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            lastOnlineTime: 'LastOnlineTime',
            status: 'Status',
        };
    }
    static types() {
        return {
            asAddress: 'string',
            deviceId: 'string',
            deviceName: 'string',
            iotId: 'string',
            lastOnlineTime: 'string',
            status: 'string',
        };
    }
}
exports.BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus = BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus;
class BatchGetDeviceStateResponseBodyDeviceStatusList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceStatus: 'DeviceStatus',
        };
    }
    static types() {
        return {
            deviceStatus: { 'type': 'array', 'itemType': BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus },
        };
    }
}
exports.BatchGetDeviceStateResponseBodyDeviceStatusList = BatchGetDeviceStateResponseBodyDeviceStatusList;
class BatchGetEdgeDriverResponseBodyDriverList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cpuArch: 'CpuArch',
            driverId: 'DriverId',
            driverName: 'DriverName',
            driverProtocol: 'DriverProtocol',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            isBuiltIn: 'IsBuiltIn',
            runtime: 'Runtime',
            type: 'Type',
        };
    }
    static types() {
        return {
            cpuArch: 'string',
            driverId: 'string',
            driverName: 'string',
            driverProtocol: 'string',
            gmtCreateTimestamp: 'number',
            gmtModifiedTimestamp: 'number',
            isBuiltIn: 'boolean',
            runtime: 'string',
            type: 'number',
        };
    }
}
exports.BatchGetEdgeDriverResponseBodyDriverList = BatchGetEdgeDriverResponseBodyDriverList;
class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configId: 'ConfigId',
            content: 'Content',
            format: 'Format',
            key: 'Key',
        };
    }
    static types() {
        return {
            configId: 'string',
            content: 'string',
            format: 'string',
            key: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig = BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig;
class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'Config',
        };
    }
    static types() {
        return {
            config: { 'type': 'array', 'itemType': BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig },
        };
    }
}
exports.BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList = BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList;
class BatchGetEdgeInstanceChannelResponseBodyDataChannel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelId: 'ChannelId',
            channelName: 'ChannelName',
            configList: 'ConfigList',
        };
    }
    static types() {
        return {
            channelId: 'string',
            channelName: 'string',
            configList: BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList,
        };
    }
}
exports.BatchGetEdgeInstanceChannelResponseBodyDataChannel = BatchGetEdgeInstanceChannelResponseBodyDataChannel;
class BatchGetEdgeInstanceChannelResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channel: 'Channel',
        };
    }
    static types() {
        return {
            channel: { 'type': 'array', 'itemType': BatchGetEdgeInstanceChannelResponseBodyDataChannel },
        };
    }
}
exports.BatchGetEdgeInstanceChannelResponseBodyData = BatchGetEdgeInstanceChannelResponseBodyData;
class BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelId: 'ChannelId',
            channelName: 'ChannelName',
            iotId: 'IotId',
        };
    }
    static types() {
        return {
            channelId: 'string',
            channelName: 'string',
            iotId: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList = BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList;
class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'Content',
            format: 'Format',
        };
    }
    static types() {
        return {
            content: 'string',
            format: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig = BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig;
class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'Config',
            iotId: 'IotId',
        };
    }
    static types() {
        return {
            config: BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig,
            iotId: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList = BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList;
class BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            iotId: 'IotId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            iotId: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList = BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList;
class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configId: 'ConfigId',
            content: 'Content',
            format: 'Format',
            key: 'Key',
        };
    }
    static types() {
        return {
            configId: 'string',
            content: 'string',
            format: 'string',
            key: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList = BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList;
class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configList: 'ConfigList',
            driverId: 'DriverId',
        };
    }
    static types() {
        return {
            configList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList },
            driverId: 'string',
        };
    }
}
exports.BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList = BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList;
class BatchGrayMigrationDeviceResponseBodyDataDetailsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            deviceName: 'DeviceName',
            message: 'Message',
            status: 'Status',
        };
    }
    static types() {
        return {
            code: 'number',
            deviceName: 'string',
            message: 'string',
            status: 'string',
        };
    }
}
exports.BatchGrayMigrationDeviceResponseBodyDataDetailsItem = BatchGrayMigrationDeviceResponseBodyDataDetailsItem;
class BatchGrayMigrationDeviceResponseBodyDataDetails extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': BatchGrayMigrationDeviceResponseBodyDataDetailsItem },
        };
    }
}
exports.BatchGrayMigrationDeviceResponseBodyDataDetails = BatchGrayMigrationDeviceResponseBodyDataDetails;
class BatchGrayMigrationDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            details: 'Details',
        };
    }
    static types() {
        return {
            details: BatchGrayMigrationDeviceResponseBodyDataDetails,
        };
    }
}
exports.BatchGrayMigrationDeviceResponseBodyData = BatchGrayMigrationDeviceResponseBodyData;
class BatchImportDeviceRequestDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            sn: 'Sn',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            sn: 'string',
        };
    }
}
exports.BatchImportDeviceRequestDeviceList = BatchImportDeviceRequestDeviceList;
class BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            errorMsg: 'ErrorMsg',
            sn: 'Sn',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            errorMsg: 'string',
            sn: 'string',
        };
    }
}
exports.BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList = BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList;
class BatchImportDeviceResponseBodyDataInvalidDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDetailList: 'InvalidDetailList',
        };
    }
    static types() {
        return {
            invalidDetailList: { 'type': 'array', 'itemType': BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList },
        };
    }
}
exports.BatchImportDeviceResponseBodyDataInvalidDetailList = BatchImportDeviceResponseBodyDataInvalidDetailList;
class BatchImportDeviceResponseBodyDataInvalidDeviceNameList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDeviceName: 'invalidDeviceName',
        };
    }
    static types() {
        return {
            invalidDeviceName: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchImportDeviceResponseBodyDataInvalidDeviceNameList = BatchImportDeviceResponseBodyDataInvalidDeviceNameList;
class BatchImportDeviceResponseBodyDataInvalidDeviceSecretList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDeviceSecret: 'invalidDeviceSecret',
        };
    }
    static types() {
        return {
            invalidDeviceSecret: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchImportDeviceResponseBodyDataInvalidDeviceSecretList = BatchImportDeviceResponseBodyDataInvalidDeviceSecretList;
class BatchImportDeviceResponseBodyDataInvalidSnList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidSn: 'invalidSn',
        };
    }
    static types() {
        return {
            invalidSn: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchImportDeviceResponseBodyDataInvalidSnList = BatchImportDeviceResponseBodyDataInvalidSnList;
class BatchImportDeviceResponseBodyDataRepeatedDeviceNameList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            repeatedDeviceName: 'repeatedDeviceName',
        };
    }
    static types() {
        return {
            repeatedDeviceName: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchImportDeviceResponseBodyDataRepeatedDeviceNameList = BatchImportDeviceResponseBodyDataRepeatedDeviceNameList;
class BatchImportDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyId: 'ApplyId',
            invalidDetailList: 'InvalidDetailList',
            invalidDeviceNameList: 'InvalidDeviceNameList',
            invalidDeviceSecretList: 'InvalidDeviceSecretList',
            invalidSnList: 'InvalidSnList',
            repeatedDeviceNameList: 'RepeatedDeviceNameList',
        };
    }
    static types() {
        return {
            applyId: 'number',
            invalidDetailList: BatchImportDeviceResponseBodyDataInvalidDetailList,
            invalidDeviceNameList: BatchImportDeviceResponseBodyDataInvalidDeviceNameList,
            invalidDeviceSecretList: BatchImportDeviceResponseBodyDataInvalidDeviceSecretList,
            invalidSnList: BatchImportDeviceResponseBodyDataInvalidSnList,
            repeatedDeviceNameList: BatchImportDeviceResponseBodyDataRepeatedDeviceNameList,
        };
    }
}
exports.BatchImportDeviceResponseBodyData = BatchImportDeviceResponseBodyData;
class BatchImportVehicleDeviceRequestDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceId: 'DeviceId',
            deviceModel: 'DeviceModel',
            deviceName: 'DeviceName',
            manufacturer: 'Manufacturer',
        };
    }
    static types() {
        return {
            deviceId: 'string',
            deviceModel: 'string',
            deviceName: 'string',
            manufacturer: 'string',
        };
    }
}
exports.BatchImportVehicleDeviceRequestDeviceList = BatchImportVehicleDeviceRequestDeviceList;
class BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceId: 'DeviceId',
            deviceModel: 'DeviceModel',
            deviceName: 'DeviceName',
            errorMsg: 'ErrorMsg',
            manufacturer: 'Manufacturer',
        };
    }
    static types() {
        return {
            deviceId: 'string',
            deviceModel: 'string',
            deviceName: 'string',
            errorMsg: 'string',
            manufacturer: 'string',
        };
    }
}
exports.BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList = BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList;
class BatchImportVehicleDeviceResponseBodyDataInvalidDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDetailList: 'InvalidDetailList',
        };
    }
    static types() {
        return {
            invalidDetailList: { 'type': 'array', 'itemType': BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList },
        };
    }
}
exports.BatchImportVehicleDeviceResponseBodyDataInvalidDetailList = BatchImportVehicleDeviceResponseBodyDataInvalidDetailList;
class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDeviceIdList: 'invalidDeviceIdList',
        };
    }
    static types() {
        return {
            invalidDeviceIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList = BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList;
class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDeviceModelList: 'invalidDeviceModelList',
        };
    }
    static types() {
        return {
            invalidDeviceModelList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList = BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList;
class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDeviceNameList: 'InvalidDeviceNameList',
        };
    }
    static types() {
        return {
            invalidDeviceNameList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList = BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList;
class BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidManufacturerList: 'invalidManufacturerList',
        };
    }
    static types() {
        return {
            invalidManufacturerList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList = BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList;
class BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            repeatedDeviceIdList: 'repeatedDeviceIdList',
        };
    }
    static types() {
        return {
            repeatedDeviceIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList = BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList;
class BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            repeatedDeviceNameList: 'RepeatedDeviceNameList',
        };
    }
    static types() {
        return {
            repeatedDeviceNameList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList = BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList;
class BatchImportVehicleDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyId: 'ApplyId',
            invalidDetailList: 'InvalidDetailList',
            invalidDeviceIdList: 'InvalidDeviceIdList',
            invalidDeviceModelList: 'InvalidDeviceModelList',
            invalidDeviceNameList: 'InvalidDeviceNameList',
            invalidManufacturerList: 'InvalidManufacturerList',
            repeatedDeviceIdList: 'RepeatedDeviceIdList',
            repeatedDeviceNameList: 'RepeatedDeviceNameList',
        };
    }
    static types() {
        return {
            applyId: 'number',
            invalidDetailList: BatchImportVehicleDeviceResponseBodyDataInvalidDetailList,
            invalidDeviceIdList: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList,
            invalidDeviceModelList: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList,
            invalidDeviceNameList: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList,
            invalidManufacturerList: BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList,
            repeatedDeviceIdList: BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList,
            repeatedDeviceNameList: BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList,
        };
    }
}
exports.BatchImportVehicleDeviceResponseBodyData = BatchImportVehicleDeviceResponseBodyData;
class BatchQueryDeviceDetailResponseBodyDataData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            firmwareVersion: 'FirmwareVersion',
            gmtActive: 'GmtActive',
            gmtCreate: 'GmtCreate',
            iotId: 'IotId',
            nickname: 'Nickname',
            nodeType: 'NodeType',
            productKey: 'ProductKey',
            productName: 'ProductName',
            region: 'Region',
            status: 'Status',
            utcActive: 'UtcActive',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            firmwareVersion: 'string',
            gmtActive: 'string',
            gmtCreate: 'string',
            iotId: 'string',
            nickname: 'string',
            nodeType: 'number',
            productKey: 'string',
            productName: 'string',
            region: 'string',
            status: 'string',
            utcActive: 'string',
            utcCreate: 'string',
        };
    }
}
exports.BatchQueryDeviceDetailResponseBodyDataData = BatchQueryDeviceDetailResponseBodyDataData;
class BatchQueryDeviceDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': BatchQueryDeviceDetailResponseBodyDataData },
        };
    }
}
exports.BatchQueryDeviceDetailResponseBodyData = BatchQueryDeviceDetailResponseBodyData;
class BatchRegisterDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyId: 'ApplyId',
        };
    }
    static types() {
        return {
            applyId: 'number',
        };
    }
}
exports.BatchRegisterDeviceResponseBodyData = BatchRegisterDeviceResponseBodyData;
class BatchRegisterDeviceWithApplyIdResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyId: 'ApplyId',
        };
    }
    static types() {
        return {
            applyId: 'number',
        };
    }
}
exports.BatchRegisterDeviceWithApplyIdResponseBodyData = BatchRegisterDeviceWithApplyIdResponseBodyData;
class BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'Content',
            iotId: 'IotId',
        };
    }
    static types() {
        return {
            content: 'string',
            iotId: 'string',
        };
    }
}
exports.BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs = BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs;
class BatchUnbindProjectDevicesRequestDevices extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchUnbindProjectDevicesRequestDevices = BatchUnbindProjectDevicesRequestDevices;
class BatchUpdateDeviceNicknameRequestDeviceNicknameInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            nickname: 'Nickname',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            nickname: 'string',
            productKey: 'string',
        };
    }
}
exports.BatchUpdateDeviceNicknameRequestDeviceNicknameInfo = BatchUpdateDeviceNicknameRequestDeviceNicknameInfo;
class BindLicenseDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkProgressId: 'CheckProgressId',
            failSum: 'FailSum',
            progress: 'Progress',
            resultCsvFile: 'ResultCsvFile',
            successSum: 'SuccessSum',
        };
    }
    static types() {
        return {
            checkProgressId: 'string',
            failSum: 'number',
            progress: 'number',
            resultCsvFile: 'string',
            successSum: 'number',
        };
    }
}
exports.BindLicenseDeviceResponseBodyData = BindLicenseDeviceResponseBodyData;
class CheckBindLicenseDeviceProgressResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failSum: 'FailSum',
            progress: 'Progress',
            resultCsvFile: 'ResultCsvFile',
            successSum: 'SuccessSum',
        };
    }
    static types() {
        return {
            failSum: 'number',
            progress: 'number',
            resultCsvFile: 'string',
            successSum: 'number',
        };
    }
}
exports.CheckBindLicenseDeviceProgressResponseBodyData = CheckBindLicenseDeviceProgressResponseBodyData;
class ClearDeviceDesiredPropertyResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            versions: 'Versions',
        };
    }
    static types() {
        return {
            versions: 'string',
        };
    }
}
exports.ClearDeviceDesiredPropertyResponseBodyData = ClearDeviceDesiredPropertyResponseBodyData;
class CreateDataAPIServiceRequestRequestParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            desc: 'Desc',
            example: 'Example',
            name: 'Name',
            required: 'Required',
            type: 'Type',
        };
    }
    static types() {
        return {
            desc: 'string',
            example: 'string',
            name: 'string',
            required: 'boolean',
            type: 'string',
        };
    }
}
exports.CreateDataAPIServiceRequestRequestParam = CreateDataAPIServiceRequestRequestParam;
class CreateDataAPIServiceRequestResponseParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            desc: 'Desc',
            example: 'Example',
            name: 'Name',
            required: 'Required',
            type: 'Type',
        };
    }
    static types() {
        return {
            desc: 'string',
            example: 'string',
            name: 'string',
            required: 'boolean',
            type: 'string',
        };
    }
}
exports.CreateDataAPIServiceRequestResponseParam = CreateDataAPIServiceRequestResponseParam;
class CreateDataAPIServiceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiSrn: 'ApiSrn',
            createTime: 'CreateTime',
            lastUpdateTime: 'LastUpdateTime',
        };
    }
    static types() {
        return {
            apiSrn: 'string',
            createTime: 'number',
            lastUpdateTime: 'number',
        };
    }
}
exports.CreateDataAPIServiceResponseBodyData = CreateDataAPIServiceResponseBodyData;
class CreateDestinationResponseBodyDestination extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
            destinationId: 'DestinationId',
            isFailover: 'IsFailover',
            name: 'Name',
            type: 'Type',
            utcCreated: 'UtcCreated',
        };
    }
    static types() {
        return {
            configuration: 'string',
            destinationId: 'number',
            isFailover: 'boolean',
            name: 'string',
            type: 'string',
            utcCreated: 'string',
        };
    }
}
exports.CreateDestinationResponseBodyDestination = CreateDestinationResponseBodyDestination;
class CreateDeviceDistributeJobRequestTargetInstanceConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetInstanceId: 'TargetInstanceId',
        };
    }
    static types() {
        return {
            targetInstanceId: 'string',
        };
    }
}
exports.CreateDeviceDistributeJobRequestTargetInstanceConfig = CreateDeviceDistributeJobRequestTargetInstanceConfig;
class CreateDeviceDynamicGroupResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dynamicGroupExpression: 'DynamicGroupExpression',
            groupDesc: 'GroupDesc',
            groupId: 'GroupId',
            groupName: 'GroupName',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            dynamicGroupExpression: 'string',
            groupDesc: 'string',
            groupId: 'string',
            groupName: 'string',
            utcCreate: 'string',
        };
    }
}
exports.CreateDeviceDynamicGroupResponseBodyData = CreateDeviceDynamicGroupResponseBodyData;
class CreateDeviceGroupResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupDesc: 'GroupDesc',
            groupId: 'GroupId',
            groupName: 'GroupName',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            groupDesc: 'string',
            groupId: 'string',
            groupName: 'string',
            utcCreate: 'string',
        };
    }
}
exports.CreateDeviceGroupResponseBodyData = CreateDeviceGroupResponseBodyData;
class CreateDeviceTunnelResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            sourceAccessToken: 'SourceAccessToken',
            sourceURI: 'SourceURI',
            tunnelId: 'TunnelId',
        };
    }
    static types() {
        return {
            sourceAccessToken: 'string',
            sourceURI: 'string',
            tunnelId: 'string',
        };
    }
}
exports.CreateDeviceTunnelResponseBodyData = CreateDeviceTunnelResponseBodyData;
class CreateDownloadDataJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asyncExecute: 'AsyncExecute',
            csvFileName: 'CsvFileName',
            csvUrl: 'CsvUrl',
            longJobId: 'LongJobId',
            status: 'Status',
        };
    }
    static types() {
        return {
            asyncExecute: 'boolean',
            csvFileName: 'string',
            csvUrl: 'string',
            longJobId: 'string',
            status: 'number',
        };
    }
}
exports.CreateDownloadDataJobResponseBodyData = CreateDownloadDataJobResponseBodyData;
class CreateEdgeInstanceChannelRequestConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'Content',
            format: 'Format',
            key: 'Key',
        };
    }
    static types() {
        return {
            content: 'string',
            format: 'string',
            key: 'string',
        };
    }
}
exports.CreateEdgeInstanceChannelRequestConfigs = CreateEdgeInstanceChannelRequestConfigs;
class CreateEdgeOssPreSignedAddressResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ossAddress: 'OssAddress',
            ossPreSignedAddress: 'OssPreSignedAddress',
        };
    }
    static types() {
        return {
            ossAddress: 'string',
            ossPreSignedAddress: 'string',
        };
    }
}
exports.CreateEdgeOssPreSignedAddressResponseBodyData = CreateEdgeOssPreSignedAddressResponseBodyData;
class CreateLoRaNodesTaskRequestDeviceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            devEui: 'DevEui',
            pinCode: 'PinCode',
        };
    }
    static types() {
        return {
            devEui: 'string',
            pinCode: 'string',
        };
    }
}
exports.CreateLoRaNodesTaskRequestDeviceInfo = CreateLoRaNodesTaskRequestDeviceInfo;
class CreateOTADynamicUpgradeJobRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.CreateOTADynamicUpgradeJobRequestTag = CreateOTADynamicUpgradeJobRequestTag;
class CreateOTADynamicUpgradeJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'JobId',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            jobId: 'string',
            utcCreate: 'string',
        };
    }
}
exports.CreateOTADynamicUpgradeJobResponseBodyData = CreateOTADynamicUpgradeJobResponseBodyData;
class CreateOTAFirmwareRequestMultiFiles extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileMd5: 'FileMd5',
            name: 'Name',
            signValue: 'SignValue',
            size: 'Size',
            url: 'Url',
        };
    }
    static types() {
        return {
            fileMd5: 'string',
            name: 'string',
            signValue: 'string',
            size: 'number',
            url: 'string',
        };
    }
}
exports.CreateOTAFirmwareRequestMultiFiles = CreateOTAFirmwareRequestMultiFiles;
class CreateOTAFirmwareResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            firmwareId: 'FirmwareId',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            firmwareId: 'string',
            utcCreate: 'string',
        };
    }
}
exports.CreateOTAFirmwareResponseBodyData = CreateOTAFirmwareResponseBodyData;
class CreateOTAStaticUpgradeJobRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.CreateOTAStaticUpgradeJobRequestTag = CreateOTAStaticUpgradeJobRequestTag;
class CreateOTAStaticUpgradeJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'JobId',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            jobId: 'string',
            utcCreate: 'string',
        };
    }
}
exports.CreateOTAStaticUpgradeJobResponseBodyData = CreateOTAStaticUpgradeJobResponseBodyData;
class CreateOTAVerifyJobRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.CreateOTAVerifyJobRequestTag = CreateOTAVerifyJobRequestTag;
class CreateOTAVerifyJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'JobId',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            jobId: 'string',
            utcCreate: 'string',
        };
    }
}
exports.CreateOTAVerifyJobResponseBodyData = CreateOTAVerifyJobResponseBodyData;
class CreateParserDataSourceResponseBodyDataSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            description: 'Description',
            name: 'Name',
            utcCreated: 'UtcCreated',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            description: 'string',
            name: 'string',
            utcCreated: 'string',
        };
    }
}
exports.CreateParserDataSourceResponseBodyDataSource = CreateParserDataSourceResponseBodyDataSource;
class CreateProductResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliyunCommodityCode: 'AliyunCommodityCode',
            authType: 'AuthType',
            dataFormat: 'DataFormat',
            description: 'Description',
            id2: 'Id2',
            nodeType: 'NodeType',
            productKey: 'ProductKey',
            productName: 'ProductName',
            productSecret: 'ProductSecret',
            protocolType: 'ProtocolType',
        };
    }
    static types() {
        return {
            aliyunCommodityCode: 'string',
            authType: 'string',
            dataFormat: 'number',
            description: 'string',
            id2: 'boolean',
            nodeType: 'number',
            productKey: 'string',
            productName: 'string',
            productSecret: 'string',
            protocolType: 'string',
        };
    }
}
exports.CreateProductResponseBodyData = CreateProductResponseBodyData;
class CreateProductTagsRequestProductTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.CreateProductTagsRequestProductTag = CreateProductTagsRequestProductTag;
class CreateProductTagsResponseBodyInvalidProductTagsProductTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.CreateProductTagsResponseBodyInvalidProductTagsProductTag = CreateProductTagsResponseBodyInvalidProductTagsProductTag;
class CreateProductTagsResponseBodyInvalidProductTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            productTag: 'ProductTag',
        };
    }
    static types() {
        return {
            productTag: { 'type': 'array', 'itemType': CreateProductTagsResponseBodyInvalidProductTagsProductTag },
        };
    }
}
exports.CreateProductTagsResponseBodyInvalidProductTags = CreateProductTagsResponseBodyInvalidProductTags;
class CreateStudioAppDomainOpenResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            host: 'Host',
            id: 'Id',
            isBeian: 'IsBeian',
            projectId: 'ProjectId',
            protocol: 'Protocol',
            tenantId: 'TenantId',
        };
    }
    static types() {
        return {
            appId: 'string',
            host: 'string',
            id: 'number',
            isBeian: 'string',
            projectId: 'string',
            protocol: 'string',
            tenantId: 'string',
        };
    }
}
exports.CreateStudioAppDomainOpenResponseBodyData = CreateStudioAppDomainOpenResponseBodyData;
class CreateTopicRouteTableResponseBodyFailureTopics extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            topic: 'Topic',
        };
    }
    static types() {
        return {
            topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
}
exports.CreateTopicRouteTableResponseBodyFailureTopics = CreateTopicRouteTableResponseBodyFailureTopics;
class DeleteDeviceSpeechRequestDeviceSpeechList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            bizCode: 'BizCode',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            bizCode: 'string',
        };
    }
}
exports.DeleteDeviceSpeechRequestDeviceSpeechList = DeleteDeviceSpeechRequestDeviceSpeechList;
class DeleteShareTaskDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            progress: 'Progress',
            progressId: 'ProgressId',
        };
    }
    static types() {
        return {
            progress: 'number',
            progressId: 'string',
        };
    }
}
exports.DeleteShareTaskDeviceResponseBodyData = DeleteShareTaskDeviceResponseBodyData;
class DeleteTopicRouteTableResponseBodyFailureTopics extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            topic: 'Topic',
        };
    }
    static types() {
        return {
            topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
}
exports.DeleteTopicRouteTableResponseBodyFailureTopics = DeleteTopicRouteTableResponseBodyFailureTopics;
class GenerateDeviceNameListURLResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accessKeyId: 'AccessKeyId',
            fileUrl: 'FileUrl',
            host: 'Host',
            key: 'Key',
            objectStorage: 'ObjectStorage',
            policy: 'Policy',
            signature: 'Signature',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            accessKeyId: 'string',
            fileUrl: 'string',
            host: 'string',
            key: 'string',
            objectStorage: 'string',
            policy: 'string',
            signature: 'string',
            utcCreate: 'string',
        };
    }
}
exports.GenerateDeviceNameListURLResponseBodyData = GenerateDeviceNameListURLResponseBodyData;
class GenerateFileUploadURLResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            host: 'Host',
            key: 'Key',
            objectStorage: 'ObjectStorage',
            ossAccessKeyId: 'OssAccessKeyId',
            policy: 'Policy',
            signature: 'Signature',
        };
    }
    static types() {
        return {
            host: 'string',
            key: 'string',
            objectStorage: 'string',
            ossAccessKeyId: 'string',
            policy: 'string',
            signature: 'string',
        };
    }
}
exports.GenerateFileUploadURLResponseBodyData = GenerateFileUploadURLResponseBodyData;
class GenerateOTAUploadURLResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            firmwareUrl: 'FirmwareUrl',
            host: 'Host',
            key: 'Key',
            OSSAccessKeyId: 'OSSAccessKeyId',
            objectStorage: 'ObjectStorage',
            policy: 'Policy',
            signature: 'Signature',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            firmwareUrl: 'string',
            host: 'string',
            key: 'string',
            OSSAccessKeyId: 'string',
            objectStorage: 'string',
            policy: 'string',
            signature: 'string',
            utcCreate: 'string',
        };
    }
}
exports.GenerateOTAUploadURLResponseBodyData = GenerateOTAUploadURLResponseBodyData;
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            desc: 'Desc',
            example: 'Example',
            name: 'Name',
            required: 'Required',
            type: 'Type',
        };
    }
    static types() {
        return {
            desc: 'string',
            example: 'string',
            name: 'string',
            required: 'boolean',
            type: 'string',
        };
    }
}
exports.GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams = GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams;
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestParams: 'RequestParams',
        };
    }
    static types() {
        return {
            requestParams: { 'type': 'array', 'itemType': GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams },
        };
    }
}
exports.GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams = GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams;
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            desc: 'Desc',
            example: 'Example',
            name: 'Name',
            required: 'Required',
            type: 'Type',
        };
    }
    static types() {
        return {
            desc: 'string',
            example: 'string',
            name: 'string',
            required: 'boolean',
            type: 'string',
        };
    }
}
exports.GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams = GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams;
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            responseParams: 'ResponseParams',
        };
    }
    static types() {
        return {
            responseParams: { 'type': 'array', 'itemType': GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams },
        };
    }
}
exports.GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams = GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams;
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            originSql: 'OriginSql',
            requestParams: 'RequestParams',
            responseParams: 'ResponseParams',
            templateSql: 'TemplateSql',
        };
    }
    static types() {
        return {
            originSql: 'string',
            requestParams: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams,
            responseParams: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams,
            templateSql: 'string',
        };
    }
}
exports.GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO = GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO;
class GetDataAPIServiceDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiPath: 'ApiPath',
            apiSrn: 'ApiSrn',
            createTime: 'CreateTime',
            dateFormat: 'DateFormat',
            description: 'Description',
            displayName: 'DisplayName',
            lastUpdateTime: 'LastUpdateTime',
            requestMethod: 'RequestMethod',
            requestProtocol: 'RequestProtocol',
            sqlTemplateDTO: 'SqlTemplateDTO',
            status: 'Status',
        };
    }
    static types() {
        return {
            apiPath: 'string',
            apiSrn: 'string',
            createTime: 'number',
            dateFormat: 'string',
            description: 'string',
            displayName: 'string',
            lastUpdateTime: 'number',
            requestMethod: 'string',
            requestProtocol: 'string',
            sqlTemplateDTO: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO,
            status: 'number',
        };
    }
}
exports.GetDataAPIServiceDetailResponseBodyData = GetDataAPIServiceDetailResponseBodyData;
class GetDestinationResponseBodyDestination extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
            destinationId: 'DestinationId',
            isFailover: 'IsFailover',
            name: 'Name',
            status: 'Status',
            type: 'Type',
            utcCreated: 'UtcCreated',
        };
    }
    static types() {
        return {
            configuration: 'string',
            destinationId: 'string',
            isFailover: 'boolean',
            name: 'string',
            status: 'string',
            type: 'string',
            utcCreated: 'string',
        };
    }
}
exports.GetDestinationResponseBodyDestination = GetDestinationResponseBodyDestination;
class GetDeviceStatusResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            status: 'Status',
            timestamp: 'Timestamp',
        };
    }
    static types() {
        return {
            status: 'string',
            timestamp: 'number',
        };
    }
}
exports.GetDeviceStatusResponseBodyData = GetDeviceStatusResponseBodyData;
class GetDeviceTunnelShareStatusResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtOpened: 'GmtOpened',
            isOpen: 'IsOpen',
            password: 'Password',
            shareId: 'ShareId',
        };
    }
    static types() {
        return {
            gmtOpened: 'number',
            isOpen: 'boolean',
            password: 'string',
            shareId: 'string',
        };
    }
}
exports.GetDeviceTunnelShareStatusResponseBodyData = GetDeviceTunnelShareStatusResponseBodyData;
class GetDownloadFileResponseBodyDataHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alias: 'Alias',
            dimDateClass: 'DimDateClass',
            fieldName: 'FieldName',
            fieldType: 'FieldType',
            geoClass: 'GeoClass',
            timeClass: 'TimeClass',
            typeClass: 'TypeClass',
        };
    }
    static types() {
        return {
            alias: 'string',
            dimDateClass: 'string',
            fieldName: 'string',
            fieldType: 'string',
            geoClass: 'string',
            timeClass: 'string',
            typeClass: 'string',
        };
    }
}
exports.GetDownloadFileResponseBodyDataHeader = GetDownloadFileResponseBodyDataHeader;
class GetDownloadFileResponseBodyDataQuerySettingAstExpr extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expr: 'Expr',
            exprType: 'ExprType',
        };
    }
    static types() {
        return {
            expr: 'string',
            exprType: 'string',
        };
    }
}
exports.GetDownloadFileResponseBodyDataQuerySettingAstExpr = GetDownloadFileResponseBodyDataQuerySettingAstExpr;
class GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alias: 'Alias',
            dimDateClass: 'DimDateClass',
            fieldName: 'FieldName',
            fieldType: 'FieldType',
            geoClass: 'GeoClass',
            timeClass: 'TimeClass',
        };
    }
    static types() {
        return {
            alias: 'string',
            dimDateClass: 'string',
            fieldName: 'string',
            fieldType: 'string',
            geoClass: 'string',
            timeClass: 'string',
        };
    }
}
exports.GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders = GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders;
class GetDownloadFileResponseBodyDataQuerySetting extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            astExpr: 'AstExpr',
            selectedHeaders: 'SelectedHeaders',
        };
    }
    static types() {
        return {
            astExpr: { 'type': 'array', 'itemType': GetDownloadFileResponseBodyDataQuerySettingAstExpr },
            selectedHeaders: { 'type': 'array', 'itemType': GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders },
        };
    }
}
exports.GetDownloadFileResponseBodyDataQuerySetting = GetDownloadFileResponseBodyDataQuerySetting;
class GetDownloadFileResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asyncExecute: 'AsyncExecute',
            beginTime: 'BeginTime',
            csvFileName: 'CsvFileName',
            csvUrl: 'CsvUrl',
            datasetId: 'DatasetId',
            endTime: 'EndTime',
            header: 'Header',
            longJobId: 'LongJobId',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            previewSize: 'PreviewSize',
            querySetting: 'QuerySetting',
            result: 'Result',
            resultDataInString: 'ResultDataInString',
            status: 'Status',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            asyncExecute: 'boolean',
            beginTime: 'number',
            csvFileName: 'string',
            csvUrl: 'string',
            datasetId: 'string',
            endTime: 'number',
            header: { 'type': 'array', 'itemType': GetDownloadFileResponseBodyDataHeader },
            longJobId: 'string',
            pageNo: 'number',
            pageSize: 'number',
            previewSize: 'number',
            querySetting: GetDownloadFileResponseBodyDataQuerySetting,
            result: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
            resultDataInString: 'string',
            status: 'number',
            totalCount: 'number',
        };
    }
}
exports.GetDownloadFileResponseBodyData = GetDownloadFileResponseBodyData;
class GetEdgeDriverVersionResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            argument: 'Argument',
            configCheckRule: 'ConfigCheckRule',
            containerConfig: 'ContainerConfig',
            description: 'Description',
            driverConfig: 'DriverConfig',
            driverId: 'DriverId',
            driverVersion: 'DriverVersion',
            edgeVersion: 'EdgeVersion',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            sourceConfig: 'SourceConfig',
            versionState: 'VersionState',
        };
    }
    static types() {
        return {
            argument: 'string',
            configCheckRule: 'string',
            containerConfig: 'string',
            description: 'string',
            driverConfig: 'string',
            driverId: 'string',
            driverVersion: 'string',
            edgeVersion: 'string',
            gmtCreateTimestamp: 'number',
            gmtModifiedTimestamp: 'number',
            sourceConfig: 'string',
            versionState: 'string',
        };
    }
}
exports.GetEdgeDriverVersionResponseBodyData = GetEdgeDriverVersionResponseBodyData;
class GetEdgeInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizEnable: 'BizEnable',
            gmtCreate: 'GmtCreate',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModified: 'GmtModified',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            instanceId: 'InstanceId',
            latestDeploymentStatus: 'LatestDeploymentStatus',
            latestDeploymentType: 'LatestDeploymentType',
            name: 'Name',
            roleArn: 'RoleArn',
            roleAttachTime: 'RoleAttachTime',
            roleAttachTimestamp: 'RoleAttachTimestamp',
            roleName: 'RoleName',
            spec: 'Spec',
            tags: 'Tags',
            type: 'Type',
        };
    }
    static types() {
        return {
            bizEnable: 'boolean',
            gmtCreate: 'string',
            gmtCreateTimestamp: 'number',
            gmtModified: 'string',
            gmtModifiedTimestamp: 'number',
            instanceId: 'string',
            latestDeploymentStatus: 'number',
            latestDeploymentType: 'string',
            name: 'string',
            roleArn: 'string',
            roleAttachTime: 'string',
            roleAttachTimestamp: 'number',
            roleName: 'string',
            spec: 'number',
            tags: 'string',
            type: 'string',
        };
    }
}
exports.GetEdgeInstanceResponseBodyData = GetEdgeInstanceResponseBodyData;
class GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCompleted: 'GmtCompleted',
            gmtCompletedTimestamp: 'GmtCompletedTimestamp',
            gmtCreate: 'GmtCreate',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModified: 'GmtModified',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            log: 'Log',
            operateType: 'OperateType',
            resourceId: 'ResourceId',
            resourceName: 'ResourceName',
            resourceType: 'ResourceType',
            snapshotId: 'SnapshotId',
            stage: 'Stage',
            status: 'Status',
        };
    }
    static types() {
        return {
            gmtCompleted: 'string',
            gmtCompletedTimestamp: 'number',
            gmtCreate: 'string',
            gmtCreateTimestamp: 'number',
            gmtModified: 'string',
            gmtModifiedTimestamp: 'number',
            log: 'string',
            operateType: 'number',
            resourceId: 'string',
            resourceName: 'string',
            resourceType: 'string',
            snapshotId: 'string',
            stage: 'number',
            status: 'number',
        };
    }
}
exports.GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList = GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList;
class GetEdgeInstanceDeploymentResponseBodyDataTaskList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gatewayId: 'GatewayId',
            gmtCompleted: 'GmtCompleted',
            gmtCompletedTimestamp: 'GmtCompletedTimestamp',
            gmtCreate: 'GmtCreate',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModified: 'GmtModified',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            resourceSnapshotList: 'ResourceSnapshotList',
            stage: 'Stage',
            status: 'Status',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            gatewayId: 'string',
            gmtCompleted: 'string',
            gmtCompletedTimestamp: 'number',
            gmtCreate: 'string',
            gmtCreateTimestamp: 'number',
            gmtModified: 'string',
            gmtModifiedTimestamp: 'number',
            resourceSnapshotList: { 'type': 'array', 'itemType': GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList },
            stage: 'number',
            status: 'number',
            taskId: 'string',
        };
    }
}
exports.GetEdgeInstanceDeploymentResponseBodyDataTaskList = GetEdgeInstanceDeploymentResponseBodyDataTaskList;
class GetEdgeInstanceDeploymentResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deploymentId: 'DeploymentId',
            description: 'Description',
            gmtCompleted: 'GmtCompleted',
            gmtCompletedTimestamp: 'GmtCompletedTimestamp',
            gmtCreate: 'GmtCreate',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModified: 'GmtModified',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            status: 'Status',
            taskList: 'TaskList',
            type: 'Type',
        };
    }
    static types() {
        return {
            deploymentId: 'string',
            description: 'string',
            gmtCompleted: 'string',
            gmtCompletedTimestamp: 'number',
            gmtCreate: 'string',
            gmtCreateTimestamp: 'number',
            gmtModified: 'string',
            gmtModifiedTimestamp: 'number',
            status: 'number',
            taskList: { 'type': 'array', 'itemType': GetEdgeInstanceDeploymentResponseBodyDataTaskList },
            type: 'string',
        };
    }
}
exports.GetEdgeInstanceDeploymentResponseBodyData = GetEdgeInstanceDeploymentResponseBodyData;
class GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qos: 'Qos',
            sourceApplicationName: 'SourceApplicationName',
            sourceFcFunctionName: 'SourceFcFunctionName',
            sourceFcServiceName: 'SourceFcServiceName',
            targetApplicationName: 'TargetApplicationName',
            targetFcFunctionName: 'TargetFcFunctionName',
            targetFcServiceName: 'TargetFcServiceName',
        };
    }
    static types() {
        return {
            qos: 'string',
            sourceApplicationName: 'string',
            sourceFcFunctionName: 'string',
            sourceFcServiceName: 'string',
            targetApplicationName: 'string',
            targetFcFunctionName: 'string',
            targetFcServiceName: 'string',
        };
    }
}
exports.GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext = GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext;
class GetEdgeInstanceMessageRoutingResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'GmtCreate',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModified: 'GmtModified',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            name: 'Name',
            routeContext: 'RouteContext',
            sourceData: 'SourceData',
            sourceType: 'SourceType',
            targetData: 'TargetData',
            targetType: 'TargetType',
            topicFilter: 'TopicFilter',
        };
    }
    static types() {
        return {
            gmtCreate: 'string',
            gmtCreateTimestamp: 'number',
            gmtModified: 'string',
            gmtModifiedTimestamp: 'number',
            name: 'string',
            routeContext: GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext,
            sourceData: 'string',
            sourceType: 'string',
            targetData: 'string',
            targetType: 'string',
            topicFilter: 'string',
        };
    }
}
exports.GetEdgeInstanceMessageRoutingResponseBodyData = GetEdgeInstanceMessageRoutingResponseBodyData;
class GetGatewayBySubDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            firmwareVersion: 'FirmwareVersion',
            gmtActive: 'GmtActive',
            gmtCreate: 'GmtCreate',
            gmtOnline: 'GmtOnline',
            ipAddress: 'IpAddress',
            nodeType: 'NodeType',
            productKey: 'ProductKey',
            productName: 'ProductName',
            status: 'Status',
            utcActive: 'UtcActive',
            utcCreate: 'UtcCreate',
            utcOnline: 'UtcOnline',
            iotId: 'iotId',
            region: 'region',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            firmwareVersion: 'string',
            gmtActive: 'string',
            gmtCreate: 'string',
            gmtOnline: 'string',
            ipAddress: 'string',
            nodeType: 'string',
            productKey: 'string',
            productName: 'string',
            status: 'string',
            utcActive: 'string',
            utcCreate: 'string',
            utcOnline: 'string',
            iotId: 'string',
            region: 'string',
        };
    }
}
exports.GetGatewayBySubDeviceResponseBodyData = GetGatewayBySubDeviceResponseBodyData;
class GetLoraNodesTaskResponseBodySuccessDevEuis extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            successDevEui: 'SuccessDevEui',
        };
    }
    static types() {
        return {
            successDevEui: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetLoraNodesTaskResponseBodySuccessDevEuis = GetLoraNodesTaskResponseBodySuccessDevEuis;
class GetParserResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            description: 'Description',
            name: 'Name',
            parserId: 'ParserId',
            script: 'Script',
            scriptDraft: 'ScriptDraft',
            status: 'Status',
            utcCreated: 'UtcCreated',
            utcModified: 'UtcModified',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            description: 'string',
            name: 'string',
            parserId: 'number',
            script: 'string',
            scriptDraft: 'string',
            status: 'string',
            utcCreated: 'string',
            utcModified: 'string',
        };
    }
}
exports.GetParserResponseBodyData = GetParserResponseBodyData;
class GetParserDataSourceResponseBodyDataSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createUserId: 'CreateUserId',
            dataSourceId: 'DataSourceId',
            description: 'Description',
            name: 'Name',
            utcCreated: 'UtcCreated',
        };
    }
    static types() {
        return {
            createUserId: 'number',
            dataSourceId: 'number',
            description: 'string',
            name: 'string',
            utcCreated: 'string',
        };
    }
}
exports.GetParserDataSourceResponseBodyDataSource = GetParserDataSourceResponseBodyDataSource;
class GetRuleResponseBodyRuleInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createUserId: 'CreateUserId',
            created: 'Created',
            dataType: 'DataType',
            id: 'Id',
            modified: 'Modified',
            name: 'Name',
            productKey: 'ProductKey',
            ruleDesc: 'RuleDesc',
            select: 'Select',
            shortTopic: 'ShortTopic',
            status: 'Status',
            topic: 'Topic',
            topicType: 'TopicType',
            utcCreated: 'UtcCreated',
            utcModified: 'UtcModified',
            where: 'Where',
        };
    }
    static types() {
        return {
            createUserId: 'number',
            created: 'string',
            dataType: 'string',
            id: 'number',
            modified: 'string',
            name: 'string',
            productKey: 'string',
            ruleDesc: 'string',
            select: 'string',
            shortTopic: 'string',
            status: 'string',
            topic: 'string',
            topicType: 'number',
            utcCreated: 'string',
            utcModified: 'string',
            where: 'string',
        };
    }
}
exports.GetRuleResponseBodyRuleInfo = GetRuleResponseBodyRuleInfo;
class GetRuleActionResponseBodyRuleActionInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
            errorActionFlag: 'ErrorActionFlag',
            id: 'Id',
            ruleId: 'RuleId',
            type: 'Type',
        };
    }
    static types() {
        return {
            configuration: 'string',
            errorActionFlag: 'boolean',
            id: 'number',
            ruleId: 'number',
            type: 'string',
        };
    }
}
exports.GetRuleActionResponseBodyRuleActionInfo = GetRuleActionResponseBodyRuleActionInfo;
class GetSceneRuleResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            ruleContent: 'RuleContent',
            ruleDescription: 'RuleDescription',
            ruleName: 'RuleName',
            ruleStatus: 'RuleStatus',
        };
    }
    static types() {
        return {
            gmtCreate: 'number',
            gmtModified: 'number',
            ruleContent: 'string',
            ruleDescription: 'string',
            ruleName: 'string',
            ruleStatus: 'number',
        };
    }
}
exports.GetSceneRuleResponseBodyData = GetSceneRuleResponseBodyData;
class GetShareSpeechModelAudioResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetShareSpeechModelAudioResponseBodyData = GetShareSpeechModelAudioResponseBodyData;
class GetSoundCodeAudioResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetSoundCodeAudioResponseBodyData = GetSoundCodeAudioResponseBodyData;
class GetSoundCodeScheduleResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            endDate: 'EndDate',
            endTime: 'EndTime',
            gmtCreate: 'GmtCreate',
            name: 'Name',
            openType: 'OpenType',
            scheduleCode: 'ScheduleCode',
            startDate: 'StartDate',
            startTime: 'StartTime',
            status: 'Status',
        };
    }
    static types() {
        return {
            description: 'string',
            endDate: 'string',
            endTime: 'string',
            gmtCreate: 'number',
            name: 'string',
            openType: 'string',
            scheduleCode: 'string',
            startDate: 'string',
            startTime: 'string',
            status: 'string',
        };
    }
}
exports.GetSoundCodeScheduleResponseBodyData = GetSoundCodeScheduleResponseBodyData;
class GetSpeechDeviceDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableSpace: 'AvailableSpace',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            productKey: 'ProductKey',
            speechListUpdateTime: 'SpeechListUpdateTime',
            status: 'Status',
            totalSpace: 'TotalSpace',
        };
    }
    static types() {
        return {
            availableSpace: 'number',
            deviceName: 'string',
            iotId: 'string',
            productKey: 'string',
            speechListUpdateTime: 'number',
            status: 'string',
            totalSpace: 'number',
        };
    }
}
exports.GetSpeechDeviceDetailResponseBodyData = GetSpeechDeviceDetailResponseBodyData;
class GetSpeechLicenseDeviceStatisticsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableQuota: 'AvailableQuota',
            expiredQuota: 'ExpiredQuota',
            expiringQuota: 'ExpiringQuota',
        };
    }
    static types() {
        return {
            availableQuota: 'number',
            expiredQuota: 'number',
            expiringQuota: 'number',
        };
    }
}
exports.GetSpeechLicenseDeviceStatisticsResponseBodyData = GetSpeechLicenseDeviceStatisticsResponseBodyData;
class GetSpeechVoiceResponseBodyDataItemsVoiceListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            label: 'Label',
            value: 'Value',
        };
    }
    static types() {
        return {
            label: 'string',
            value: 'string',
        };
    }
}
exports.GetSpeechVoiceResponseBodyDataItemsVoiceListItems = GetSpeechVoiceResponseBodyDataItemsVoiceListItems;
class GetSpeechVoiceResponseBodyDataItemsVoiceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': GetSpeechVoiceResponseBodyDataItemsVoiceListItems },
        };
    }
}
exports.GetSpeechVoiceResponseBodyDataItemsVoiceList = GetSpeechVoiceResponseBodyDataItemsVoiceList;
class GetSpeechVoiceResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            label: 'Label',
            value: 'Value',
            voiceList: 'VoiceList',
        };
    }
    static types() {
        return {
            label: 'string',
            value: 'string',
            voiceList: GetSpeechVoiceResponseBodyDataItemsVoiceList,
        };
    }
}
exports.GetSpeechVoiceResponseBodyDataItems = GetSpeechVoiceResponseBodyDataItems;
class GetSpeechVoiceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': GetSpeechVoiceResponseBodyDataItems },
        };
    }
}
exports.GetSpeechVoiceResponseBodyData = GetSpeechVoiceResponseBodyData;
class GetStudioAppTokenOpenResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizId: 'BizId',
            bizType: 'BizType',
            isEnable: 'IsEnable',
            token: 'Token',
            type: 'Type',
        };
    }
    static types() {
        return {
            bizId: 'string',
            bizType: 'string',
            isEnable: 'string',
            token: 'string',
            type: 'string',
        };
    }
}
exports.GetStudioAppTokenOpenResponseBodyData = GetStudioAppTokenOpenResponseBodyData;
class GetThingModelTslResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tslStr: 'TslStr',
            tslUri: 'TslUri',
        };
    }
    static types() {
        return {
            tslStr: 'string',
            tslUri: 'string',
        };
    }
}
exports.GetThingModelTslResponseBodyData = GetThingModelTslResponseBodyData;
class GetThingModelTslPublishedResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tslStr: 'TslStr',
            tslUri: 'TslUri',
        };
    }
    static types() {
        return {
            tslStr: 'string',
            tslUri: 'string',
        };
    }
}
exports.GetThingModelTslPublishedResponseBodyData = GetThingModelTslPublishedResponseBodyData;
class GetThingScriptResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scriptType: 'ScriptType',
            scriptUrl: 'ScriptUrl',
        };
    }
    static types() {
        return {
            scriptType: 'string',
            scriptUrl: 'string',
        };
    }
}
exports.GetThingScriptResponseBodyData = GetThingScriptResponseBodyData;
class GetThingTopoResponseBodyDataListDeviceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            productKey: 'string',
        };
    }
}
exports.GetThingTopoResponseBodyDataListDeviceInfo = GetThingTopoResponseBodyDataListDeviceInfo;
class GetThingTopoResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceInfo: 'deviceInfo',
        };
    }
    static types() {
        return {
            deviceInfo: { 'type': 'array', 'itemType': GetThingTopoResponseBodyDataListDeviceInfo },
        };
    }
}
exports.GetThingTopoResponseBodyDataList = GetThingTopoResponseBodyDataList;
class GetThingTopoResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            list: 'List',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            list: GetThingTopoResponseBodyDataList,
            pageCount: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.GetThingTopoResponseBodyData = GetThingTopoResponseBodyData;
class GisQueryDeviceLocationRequestThingList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            productKey: 'string',
        };
    }
}
exports.GisQueryDeviceLocationRequestThingList = GisQueryDeviceLocationRequestThingList;
class GisQueryDeviceLocationResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adcode: 'Adcode',
            city: 'City',
            coordinateSystem: 'CoordinateSystem',
            country: 'Country',
            deviceName: 'DeviceName',
            ip: 'Ip',
            latitude: 'Latitude',
            longitude: 'Longitude',
            productKey: 'ProductKey',
            province: 'Province',
        };
    }
    static types() {
        return {
            adcode: 'number',
            city: 'string',
            coordinateSystem: 'number',
            country: 'string',
            deviceName: 'string',
            ip: 'string',
            latitude: 'number',
            longitude: 'number',
            productKey: 'string',
            province: 'string',
        };
    }
}
exports.GisQueryDeviceLocationResponseBodyData = GisQueryDeviceLocationResponseBodyData;
class GisSearchDeviceTraceResponseBodyDataPoints extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            locateTime: 'LocateTime',
            location: 'Location',
        };
    }
    static types() {
        return {
            locateTime: 'number',
            location: 'string',
        };
    }
}
exports.GisSearchDeviceTraceResponseBodyDataPoints = GisSearchDeviceTraceResponseBodyDataPoints;
class GisSearchDeviceTraceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            points: 'Points',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            points: { 'type': 'array', 'itemType': GisSearchDeviceTraceResponseBodyDataPoints },
            productKey: 'string',
        };
    }
}
exports.GisSearchDeviceTraceResponseBodyData = GisSearchDeviceTraceResponseBodyData;
class ImportDTDataRequestItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            params: 'Params',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            params: 'string',
        };
    }
}
exports.ImportDTDataRequestItems = ImportDTDataRequestItems;
class ImportDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            iotId: 'IotId',
            nickname: 'Nickname',
            productKey: 'ProductKey',
            sn: 'Sn',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            iotId: 'string',
            nickname: 'string',
            productKey: 'string',
            sn: 'string',
        };
    }
}
exports.ImportDeviceResponseBodyData = ImportDeviceResponseBodyData;
class InvokeDataAPIServiceRequestParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            listParamType: 'ListParamType',
            listParamValue: 'ListParamValue',
            paramName: 'ParamName',
            paramType: 'ParamType',
            paramValue: 'ParamValue',
        };
    }
    static types() {
        return {
            listParamType: 'string',
            listParamValue: { 'type': 'array', 'itemType': 'string' },
            paramName: 'string',
            paramType: 'string',
            paramValue: 'string',
        };
    }
}
exports.InvokeDataAPIServiceRequestParam = InvokeDataAPIServiceRequestParam;
class InvokeDataAPIServiceResponseBodyDataFieldNameList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldNameList: 'FieldNameList',
        };
    }
    static types() {
        return {
            fieldNameList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.InvokeDataAPIServiceResponseBodyDataFieldNameList = InvokeDataAPIServiceResponseBodyDataFieldNameList;
class InvokeDataAPIServiceResponseBodyDataResultList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resultList: 'ResultList',
        };
    }
    static types() {
        return {
            resultList: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
}
exports.InvokeDataAPIServiceResponseBodyDataResultList = InvokeDataAPIServiceResponseBodyDataResultList;
class InvokeDataAPIServiceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiSrn: 'ApiSrn',
            fieldNameList: 'FieldNameList',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            resultList: 'ResultList',
            totalSize: 'TotalSize',
        };
    }
    static types() {
        return {
            apiSrn: 'string',
            fieldNameList: InvokeDataAPIServiceResponseBodyDataFieldNameList,
            pageNo: 'number',
            pageSize: 'number',
            resultList: InvokeDataAPIServiceResponseBodyDataResultList,
            totalSize: 'number',
        };
    }
}
exports.InvokeDataAPIServiceResponseBodyData = InvokeDataAPIServiceResponseBodyData;
class InvokeThingServiceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageId: 'MessageId',
            result: 'Result',
        };
    }
    static types() {
        return {
            messageId: 'string',
            result: 'string',
        };
    }
}
exports.InvokeThingServiceResponseBodyData = InvokeThingServiceResponseBodyData;
class ListAnalyticsDataRequestCondition extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            betweenEnd: 'BetweenEnd',
            betweenStart: 'BetweenStart',
            fieldName: 'FieldName',
            operate: 'Operate',
            value: 'Value',
        };
    }
    static types() {
        return {
            betweenEnd: 'string',
            betweenStart: 'string',
            fieldName: 'string',
            operate: 'string',
            value: 'string',
        };
    }
}
exports.ListAnalyticsDataRequestCondition = ListAnalyticsDataRequestCondition;
class ListAnalyticsDataResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            count: 'Count',
            hasNext: 'HasNext',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            resultJson: 'ResultJson',
        };
    }
    static types() {
        return {
            count: 'number',
            hasNext: 'boolean',
            pageNum: 'number',
            pageSize: 'number',
            resultJson: 'string',
        };
    }
}
exports.ListAnalyticsDataResponseBodyData = ListAnalyticsDataResponseBodyData;
class ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceItemId: 'DataSourceItemId',
            deviceName: 'DeviceName',
            productKey: 'ProductKey',
            scopeType: 'ScopeType',
            topic: 'Topic',
        };
    }
    static types() {
        return {
            dataSourceItemId: 'number',
            deviceName: 'string',
            productKey: 'string',
            scopeType: 'string',
            topic: 'string',
        };
    }
}
exports.ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem = ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem;
class ListDataSourceItemResponseBodyDataSourceItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceItem: 'dataSourceItem',
        };
    }
    static types() {
        return {
            dataSourceItem: { 'type': 'array', 'itemType': ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem },
        };
    }
}
exports.ListDataSourceItemResponseBodyDataSourceItems = ListDataSourceItemResponseBodyDataSourceItems;
class ListDestinationResponseBodyDestinationsDestinations extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
            description: 'Description',
            destinationId: 'DestinationId',
            isFailover: 'IsFailover',
            name: 'Name',
            status: 'Status',
            type: 'Type',
            utcCreated: 'UtcCreated',
        };
    }
    static types() {
        return {
            configuration: 'string',
            description: 'string',
            destinationId: 'number',
            isFailover: 'boolean',
            name: 'string',
            status: 'string',
            type: 'string',
            utcCreated: 'string',
        };
    }
}
exports.ListDestinationResponseBodyDestinationsDestinations = ListDestinationResponseBodyDestinationsDestinations;
class ListDestinationResponseBodyDestinations extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destinations: 'destinations',
        };
    }
    static types() {
        return {
            destinations: { 'type': 'array', 'itemType': ListDestinationResponseBodyDestinationsDestinations },
        };
    }
}
exports.ListDestinationResponseBodyDestinations = ListDestinationResponseBodyDestinations;
class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetInstanceId: 'TargetInstanceId',
            targetInstanceName: 'TargetInstanceName',
            targetRegion: 'TargetRegion',
        };
    }
    static types() {
        return {
            targetInstanceId: 'string',
            targetInstanceName: 'string',
            targetRegion: 'string',
        };
    }
}
exports.ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs = ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs;
class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetInstanceConfigs: 'targetInstanceConfigs',
        };
    }
    static types() {
        return {
            targetInstanceConfigs: { 'type': 'array', 'itemType': ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs },
        };
    }
}
exports.ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs = ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs;
class ListDeviceDistributeJobResponseBodyDataJobInfoItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'GmtCreate',
            jobId: 'JobId',
            productKey: 'ProductKey',
            sourceInstanceId: 'SourceInstanceId',
            sourceInstanceName: 'SourceInstanceName',
            sourceRegion: 'SourceRegion',
            sourceUid: 'SourceUid',
            status: 'Status',
            strategy: 'Strategy',
            targetInstanceConfigs: 'TargetInstanceConfigs',
            targetUid: 'TargetUid',
            total: 'Total',
        };
    }
    static types() {
        return {
            gmtCreate: 'number',
            jobId: 'string',
            productKey: 'string',
            sourceInstanceId: 'string',
            sourceInstanceName: 'string',
            sourceRegion: 'string',
            sourceUid: 'string',
            status: 'number',
            strategy: 'number',
            targetInstanceConfigs: ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs,
            targetUid: 'string',
            total: 'number',
        };
    }
}
exports.ListDeviceDistributeJobResponseBodyDataJobInfoItems = ListDeviceDistributeJobResponseBodyDataJobInfoItems;
class ListDeviceDistributeJobResponseBodyDataJobInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': ListDeviceDistributeJobResponseBodyDataJobInfoItems },
        };
    }
}
exports.ListDeviceDistributeJobResponseBodyDataJobInfo = ListDeviceDistributeJobResponseBodyDataJobInfo;
class ListDeviceDistributeJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobInfo: 'JobInfo',
            nextToken: 'NextToken',
            total: 'Total',
        };
    }
    static types() {
        return {
            jobInfo: ListDeviceDistributeJobResponseBodyDataJobInfo,
            nextToken: 'string',
            total: 'number',
        };
    }
}
exports.ListDeviceDistributeJobResponseBodyData = ListDeviceDistributeJobResponseBodyData;
class ListDistributedDeviceResponseBodyDataInfoItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            productKey: 'ProductKey',
            sourceInstanceId: 'SourceInstanceId',
            sourceInstanceName: 'SourceInstanceName',
            sourceRegion: 'SourceRegion',
            sourceUid: 'SourceUid',
            targetAliyunId: 'TargetAliyunId',
            targetInstanceId: 'TargetInstanceId',
            targetInstanceName: 'TargetInstanceName',
            targetRegion: 'TargetRegion',
            targetUid: 'TargetUid',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            gmtCreate: 'number',
            gmtModified: 'number',
            productKey: 'string',
            sourceInstanceId: 'string',
            sourceInstanceName: 'string',
            sourceRegion: 'string',
            sourceUid: 'string',
            targetAliyunId: 'string',
            targetInstanceId: 'string',
            targetInstanceName: 'string',
            targetRegion: 'string',
            targetUid: 'string',
        };
    }
}
exports.ListDistributedDeviceResponseBodyDataInfoItems = ListDistributedDeviceResponseBodyDataInfoItems;
class ListDistributedDeviceResponseBodyDataInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': ListDistributedDeviceResponseBodyDataInfoItems },
        };
    }
}
exports.ListDistributedDeviceResponseBodyDataInfo = ListDistributedDeviceResponseBodyDataInfo;
class ListDistributedDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            info: 'Info',
            total: 'Total',
        };
    }
    static types() {
        return {
            info: ListDistributedDeviceResponseBodyDataInfo,
            total: 'number',
        };
    }
}
exports.ListDistributedDeviceResponseBodyData = ListDistributedDeviceResponseBodyData;
class ListDistributedProductResponseBodyDataInfoItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'GmtCreate',
            productKey: 'ProductKey',
            sourceInstanceId: 'SourceInstanceId',
            sourceInstanceName: 'SourceInstanceName',
            sourceRegion: 'SourceRegion',
            sourceUid: 'SourceUid',
            targetAliyunId: 'TargetAliyunId',
            targetInstanceId: 'TargetInstanceId',
            targetInstanceName: 'TargetInstanceName',
            targetRegion: 'TargetRegion',
            targetUid: 'TargetUid',
        };
    }
    static types() {
        return {
            gmtCreate: 'number',
            productKey: 'string',
            sourceInstanceId: 'string',
            sourceInstanceName: 'string',
            sourceRegion: 'string',
            sourceUid: 'string',
            targetAliyunId: 'string',
            targetInstanceId: 'string',
            targetInstanceName: 'string',
            targetRegion: 'string',
            targetUid: 'string',
        };
    }
}
exports.ListDistributedProductResponseBodyDataInfoItems = ListDistributedProductResponseBodyDataInfoItems;
class ListDistributedProductResponseBodyDataInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': ListDistributedProductResponseBodyDataInfoItems },
        };
    }
}
exports.ListDistributedProductResponseBodyDataInfo = ListDistributedProductResponseBodyDataInfo;
class ListDistributedProductResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            info: 'Info',
            total: 'Total',
        };
    }
    static types() {
        return {
            info: ListDistributedProductResponseBodyDataInfo,
            total: 'number',
        };
    }
}
exports.ListDistributedProductResponseBodyData = ListDistributedProductResponseBodyData;
class ListJobResponseBodyDataData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            jobId: 'JobId',
            jobName: 'JobName',
            scheduledTime: 'ScheduledTime',
            status: 'Status',
            type: 'Type',
            utcCreate: 'UtcCreate',
            utcModified: 'UtcModified',
        };
    }
    static types() {
        return {
            description: 'string',
            jobId: 'string',
            jobName: 'string',
            scheduledTime: 'number',
            status: 'string',
            type: 'string',
            utcCreate: 'string',
            utcModified: 'string',
        };
    }
}
exports.ListJobResponseBodyDataData = ListJobResponseBodyDataData;
class ListJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': ListJobResponseBodyDataData },
        };
    }
}
exports.ListJobResponseBodyData = ListJobResponseBodyData;
class ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destVersion: 'DestVersion',
            firmwareDesc: 'FirmwareDesc',
            firmwareId: 'FirmwareId',
            firmwareName: 'FirmwareName',
            firmwareSign: 'FirmwareSign',
            firmwareSize: 'FirmwareSize',
            moduleName: 'ModuleName',
            productKey: 'ProductKey',
            productName: 'ProductName',
            signMethod: 'SignMethod',
            srcVersion: 'SrcVersion',
            status: 'Status',
            type: 'Type',
            utcCreate: 'UtcCreate',
            utcModified: 'UtcModified',
        };
    }
    static types() {
        return {
            destVersion: 'string',
            firmwareDesc: 'string',
            firmwareId: 'string',
            firmwareName: 'string',
            firmwareSign: 'string',
            firmwareSize: 'number',
            moduleName: 'string',
            productKey: 'string',
            productName: 'string',
            signMethod: 'string',
            srcVersion: 'string',
            status: 'number',
            type: 'number',
            utcCreate: 'string',
            utcModified: 'string',
        };
    }
}
exports.ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo = ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo;
class ListOTAFirmwareResponseBodyFirmwareInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            simpleFirmwareInfo: 'SimpleFirmwareInfo',
        };
    }
    static types() {
        return {
            simpleFirmwareInfo: { 'type': 'array', 'itemType': ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo },
        };
    }
}
exports.ListOTAFirmwareResponseBodyFirmwareInfo = ListOTAFirmwareResponseBodyFirmwareInfo;
class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO = ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO;
class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            otaTagDTO: 'OtaTagDTO',
        };
    }
    static types() {
        return {
            otaTagDTO: { 'type': 'array', 'itemType': ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO },
        };
    }
}
exports.ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags = ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags;
class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            firmwareId: 'FirmwareId',
            jobId: 'JobId',
            jobStatus: 'JobStatus',
            jobType: 'JobType',
            productKey: 'ProductKey',
            selectionType: 'SelectionType',
            tags: 'Tags',
            targetSelection: 'TargetSelection',
            utcCreate: 'UtcCreate',
            utcEndTime: 'UtcEndTime',
            utcModified: 'UtcModified',
            utcStartTime: 'UtcStartTime',
        };
    }
    static types() {
        return {
            firmwareId: 'string',
            jobId: 'string',
            jobStatus: 'string',
            jobType: 'string',
            productKey: 'string',
            selectionType: 'string',
            tags: ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags,
            targetSelection: 'string',
            utcCreate: 'string',
            utcEndTime: 'string',
            utcModified: 'string',
            utcStartTime: 'string',
        };
    }
}
exports.ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo = ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo;
class ListOTAJobByDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            simpleOTAJobInfo: 'SimpleOTAJobInfo',
        };
    }
    static types() {
        return {
            simpleOTAJobInfo: { 'type': 'array', 'itemType': ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo },
        };
    }
}
exports.ListOTAJobByDeviceResponseBodyData = ListOTAJobByDeviceResponseBodyData;
class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO = ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO;
class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            otaTagDTO: 'OtaTagDTO',
        };
    }
    static types() {
        return {
            otaTagDTO: { 'type': 'array', 'itemType': ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO },
        };
    }
}
exports.ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags = ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags;
class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            firmwareId: 'FirmwareId',
            jobId: 'JobId',
            jobStatus: 'JobStatus',
            jobType: 'JobType',
            productKey: 'ProductKey',
            selectionType: 'SelectionType',
            tags: 'Tags',
            targetSelection: 'TargetSelection',
            utcCreate: 'UtcCreate',
            utcEndTime: 'UtcEndTime',
            utcModified: 'UtcModified',
            utcStartTime: 'UtcStartTime',
        };
    }
    static types() {
        return {
            firmwareId: 'string',
            jobId: 'string',
            jobStatus: 'string',
            jobType: 'string',
            productKey: 'string',
            selectionType: 'string',
            tags: ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags,
            targetSelection: 'string',
            utcCreate: 'string',
            utcEndTime: 'string',
            utcModified: 'string',
            utcStartTime: 'string',
        };
    }
}
exports.ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo = ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo;
class ListOTAJobByFirmwareResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            simpleOTAJobInfo: 'SimpleOTAJobInfo',
        };
    }
    static types() {
        return {
            simpleOTAJobInfo: { 'type': 'array', 'itemType': ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo },
        };
    }
}
exports.ListOTAJobByFirmwareResponseBodyData = ListOTAJobByFirmwareResponseBodyData;
class ListOTAModuleByProductResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliasName: 'AliasName',
            desc: 'Desc',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            moduleName: 'ModuleName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            aliasName: 'string',
            desc: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            moduleName: 'string',
            productKey: 'string',
        };
    }
}
exports.ListOTAModuleByProductResponseBodyData = ListOTAModuleByProductResponseBodyData;
class ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            moduleName: 'ModuleName',
            moduleVersion: 'ModuleVersion',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            moduleName: 'string',
            moduleVersion: 'string',
            productKey: 'string',
        };
    }
}
exports.ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo = ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo;
class ListOTAModuleVersionsByDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            simpleOTAModuleInfo: 'SimpleOTAModuleInfo',
        };
    }
    static types() {
        return {
            simpleOTAModuleInfo: { 'type': 'array', 'itemType': ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo },
        };
    }
}
exports.ListOTAModuleVersionsByDeviceResponseBodyData = ListOTAModuleVersionsByDeviceResponseBodyData;
class ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destVersion: 'DestVersion',
            deviceName: 'DeviceName',
            firmwareId: 'FirmwareId',
            iotId: 'IotId',
            jobId: 'JobId',
            productKey: 'ProductKey',
            productName: 'ProductName',
            progress: 'Progress',
            srcVersion: 'SrcVersion',
            taskDesc: 'TaskDesc',
            taskId: 'TaskId',
            taskStatus: 'TaskStatus',
            timeout: 'Timeout',
            utcCreate: 'UtcCreate',
            utcModified: 'UtcModified',
        };
    }
    static types() {
        return {
            destVersion: 'string',
            deviceName: 'string',
            firmwareId: 'string',
            iotId: 'string',
            jobId: 'string',
            productKey: 'string',
            productName: 'string',
            progress: 'string',
            srcVersion: 'string',
            taskDesc: 'string',
            taskId: 'string',
            taskStatus: 'string',
            timeout: 'string',
            utcCreate: 'string',
            utcModified: 'string',
        };
    }
}
exports.ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo = ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo;
class ListOTATaskByJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            simpleOTATaskInfo: 'SimpleOTATaskInfo',
        };
    }
    static types() {
        return {
            simpleOTATaskInfo: { 'type': 'array', 'itemType': ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo },
        };
    }
}
exports.ListOTATaskByJobResponseBodyData = ListOTATaskByJobResponseBodyData;
class ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destVersion: 'DestVersion',
            deviceName: 'DeviceName',
            firmwareId: 'FirmwareId',
            iotId: 'IotId',
            jobId: 'JobId',
            moduleName: 'ModuleName',
            productKey: 'ProductKey',
            productName: 'ProductName',
            srcVersion: 'SrcVersion',
            taskId: 'TaskId',
            taskStatus: 'TaskStatus',
            utcCreate: 'UtcCreate',
            utcModified: 'UtcModified',
        };
    }
    static types() {
        return {
            destVersion: 'string',
            deviceName: 'string',
            firmwareId: 'string',
            iotId: 'string',
            jobId: 'string',
            moduleName: 'string',
            productKey: 'string',
            productName: 'string',
            srcVersion: 'string',
            taskId: 'string',
            taskStatus: 'string',
            utcCreate: 'string',
            utcModified: 'string',
        };
    }
}
exports.ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo = ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo;
class ListOTAUnfinishedTaskByDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            simpleOTATaskInfo: 'SimpleOTATaskInfo',
        };
    }
    static types() {
        return {
            simpleOTATaskInfo: { 'type': 'array', 'itemType': ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo },
        };
    }
}
exports.ListOTAUnfinishedTaskByDeviceResponseBodyData = ListOTAUnfinishedTaskByDeviceResponseBodyData;
class ListParserResponseBodyDataParserList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            name: 'Name',
            parserId: 'ParserId',
            status: 'Status',
            utcCreated: 'UtcCreated',
            utcModified: 'UtcModified',
        };
    }
    static types() {
        return {
            description: 'string',
            name: 'string',
            parserId: 'number',
            status: 'string',
            utcCreated: 'string',
            utcModified: 'string',
        };
    }
}
exports.ListParserResponseBodyDataParserList = ListParserResponseBodyDataParserList;
class ListParserResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parserList: 'ParserList',
        };
    }
    static types() {
        return {
            parserList: { 'type': 'array', 'itemType': ListParserResponseBodyDataParserList },
        };
    }
}
exports.ListParserResponseBodyData = ListParserResponseBodyData;
class ListParserDataSourceResponseBodyDataDataSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSourceId: 'DataSourceId',
            description: 'Description',
            name: 'Name',
            utcCreated: 'UtcCreated',
        };
    }
    static types() {
        return {
            dataSourceId: 'number',
            description: 'string',
            name: 'string',
            utcCreated: 'string',
        };
    }
}
exports.ListParserDataSourceResponseBodyDataDataSource = ListParserDataSourceResponseBodyDataDataSource;
class ListParserDataSourceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSource: 'DataSource',
        };
    }
    static types() {
        return {
            dataSource: { 'type': 'array', 'itemType': ListParserDataSourceResponseBodyDataDataSource },
        };
    }
}
exports.ListParserDataSourceResponseBodyData = ListParserDataSourceResponseBodyData;
class ListParserDestinationResponseBodyDataDestinations extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
            destinationId: 'DestinationId',
            isFailover: 'IsFailover',
            name: 'Name',
            type: 'Type',
            utcCreated: 'UtcCreated',
            utcModified: 'UtcModified',
        };
    }
    static types() {
        return {
            configuration: 'string',
            destinationId: 'number',
            isFailover: 'boolean',
            name: 'string',
            type: 'string',
            utcCreated: 'string',
            utcModified: 'string',
        };
    }
}
exports.ListParserDestinationResponseBodyDataDestinations = ListParserDestinationResponseBodyDataDestinations;
class ListParserDestinationResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destinations: 'destinations',
        };
    }
    static types() {
        return {
            destinations: { 'type': 'array', 'itemType': ListParserDestinationResponseBodyDataDestinations },
        };
    }
}
exports.ListParserDestinationResponseBodyData = ListParserDestinationResponseBodyData;
class ListProductByTagsRequestProductTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.ListProductByTagsRequestProductTag = ListProductByTagsRequestProductTag;
class ListProductByTagsResponseBodyProductInfosProductInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'CreateTime',
            description: 'Description',
            nodeType: 'NodeType',
            productKey: 'ProductKey',
            productName: 'ProductName',
        };
    }
    static types() {
        return {
            createTime: 'number',
            description: 'string',
            nodeType: 'number',
            productKey: 'string',
            productName: 'string',
        };
    }
}
exports.ListProductByTagsResponseBodyProductInfosProductInfo = ListProductByTagsResponseBodyProductInfosProductInfo;
class ListProductByTagsResponseBodyProductInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            productInfo: 'ProductInfo',
        };
    }
    static types() {
        return {
            productInfo: { 'type': 'array', 'itemType': ListProductByTagsResponseBodyProductInfosProductInfo },
        };
    }
}
exports.ListProductByTagsResponseBodyProductInfos = ListProductByTagsResponseBodyProductInfos;
class ListProductTagsResponseBodyDataProductTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.ListProductTagsResponseBodyDataProductTag = ListProductTagsResponseBodyDataProductTag;
class ListProductTagsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            productTag: 'ProductTag',
        };
    }
    static types() {
        return {
            productTag: { 'type': 'array', 'itemType': ListProductTagsResponseBodyDataProductTag },
        };
    }
}
exports.ListProductTagsResponseBodyData = ListProductTagsResponseBodyData;
class ListRuleResponseBodyDataRuleInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createUserId: 'CreateUserId',
            created: 'Created',
            dataType: 'DataType',
            id: 'Id',
            modified: 'Modified',
            name: 'Name',
            productKey: 'ProductKey',
            ruleDesc: 'RuleDesc',
            select: 'Select',
            shortTopic: 'ShortTopic',
            status: 'Status',
            topic: 'Topic',
            utcCreated: 'UtcCreated',
            utcModified: 'UtcModified',
            where: 'Where',
        };
    }
    static types() {
        return {
            createUserId: 'number',
            created: 'string',
            dataType: 'string',
            id: 'number',
            modified: 'string',
            name: 'string',
            productKey: 'string',
            ruleDesc: 'string',
            select: 'string',
            shortTopic: 'string',
            status: 'string',
            topic: 'string',
            utcCreated: 'string',
            utcModified: 'string',
            where: 'string',
        };
    }
}
exports.ListRuleResponseBodyDataRuleInfo = ListRuleResponseBodyDataRuleInfo;
class ListRuleResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ruleInfo: 'RuleInfo',
        };
    }
    static types() {
        return {
            ruleInfo: { 'type': 'array', 'itemType': ListRuleResponseBodyDataRuleInfo },
        };
    }
}
exports.ListRuleResponseBodyData = ListRuleResponseBodyData;
class ListRuleActionsResponseBodyRuleActionListRuleActionInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
            errorActionFlag: 'ErrorActionFlag',
            id: 'Id',
            ruleId: 'RuleId',
            status: 'Status',
            type: 'Type',
        };
    }
    static types() {
        return {
            configuration: 'string',
            errorActionFlag: 'boolean',
            id: 'number',
            ruleId: 'number',
            status: 'string',
            type: 'string',
        };
    }
}
exports.ListRuleActionsResponseBodyRuleActionListRuleActionInfo = ListRuleActionsResponseBodyRuleActionListRuleActionInfo;
class ListRuleActionsResponseBodyRuleActionList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ruleActionInfo: 'RuleActionInfo',
        };
    }
    static types() {
        return {
            ruleActionInfo: { 'type': 'array', 'itemType': ListRuleActionsResponseBodyRuleActionListRuleActionInfo },
        };
    }
}
exports.ListRuleActionsResponseBodyRuleActionList = ListRuleActionsResponseBodyRuleActionList;
class ListTaskResponseBodyDataData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            jobId: 'JobId',
            jobName: 'JobName',
            productKey: 'ProductKey',
            progress: 'Progress',
            status: 'Status',
            taskId: 'TaskId',
            utcModified: 'UtcModified',
            utcQueueTime: 'UtcQueueTime',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            jobId: 'string',
            jobName: 'string',
            productKey: 'string',
            progress: 'string',
            status: 'string',
            taskId: 'string',
            utcModified: 'string',
            utcQueueTime: 'string',
        };
    }
}
exports.ListTaskResponseBodyDataData = ListTaskResponseBodyDataData;
class ListTaskResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': ListTaskResponseBodyDataData },
        };
    }
}
exports.ListTaskResponseBodyData = ListTaskResponseBodyData;
class ListThingModelVersionResponseBodyDataModelVersions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            gmtCreate: 'GmtCreate',
            modelVersion: 'ModelVersion',
        };
    }
    static types() {
        return {
            description: 'string',
            gmtCreate: 'number',
            modelVersion: 'string',
        };
    }
}
exports.ListThingModelVersionResponseBodyDataModelVersions = ListThingModelVersionResponseBodyDataModelVersions;
class ListThingModelVersionResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            modelVersions: 'ModelVersions',
        };
    }
    static types() {
        return {
            modelVersions: { 'type': 'array', 'itemType': ListThingModelVersionResponseBodyDataModelVersions },
        };
    }
}
exports.ListThingModelVersionResponseBodyData = ListThingModelVersionResponseBodyData;
class ListThingTemplatesResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            categoryKey: 'CategoryKey',
            categoryName: 'CategoryName',
        };
    }
    static types() {
        return {
            categoryKey: 'string',
            categoryName: 'string',
        };
    }
}
exports.ListThingTemplatesResponseBodyData = ListThingTemplatesResponseBodyData;
class NotifyAddThingTopoResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageId: 'MessageId',
        };
    }
    static types() {
        return {
            messageId: 'string',
        };
    }
}
exports.NotifyAddThingTopoResponseBodyData = NotifyAddThingTopoResponseBodyData;
class PageQuerySharedSpeechOpenResponseBodyDataResultDataData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            bizCode: 'BizCode',
            code: 'Code',
            speechRate: 'SpeechRate',
            status: 'Status',
            text: 'Text',
            voice: 'Voice',
            volume: 'Volume',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            bizCode: 'string',
            code: 'string',
            speechRate: 'number',
            status: 'number',
            text: 'string',
            voice: 'string',
            volume: 'number',
        };
    }
}
exports.PageQuerySharedSpeechOpenResponseBodyDataResultDataData = PageQuerySharedSpeechOpenResponseBodyDataResultDataData;
class PageQuerySharedSpeechOpenResponseBodyDataResultData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': PageQuerySharedSpeechOpenResponseBodyDataResultDataData },
        };
    }
}
exports.PageQuerySharedSpeechOpenResponseBodyDataResultData = PageQuerySharedSpeechOpenResponseBodyDataResultData;
class PageQuerySharedSpeechOpenResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageId: 'PageId',
            pageSize: 'PageSize',
            resultData: 'ResultData',
            total: 'Total',
        };
    }
    static types() {
        return {
            pageId: 'number',
            pageSize: 'number',
            resultData: PageQuerySharedSpeechOpenResponseBodyDataResultData,
            total: 'number',
        };
    }
}
exports.PageQuerySharedSpeechOpenResponseBodyData = PageQuerySharedSpeechOpenResponseBodyData;
class PageQuerySpeechBroadcastHourResponseBodyDataResultDataData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            deviceName: 'DeviceName',
            msg: 'Msg',
            productKey: 'ProductKey',
            shareTaskCode: 'ShareTaskCode',
            speechId: 'SpeechId',
            speechs: 'Speechs',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            code: 'number',
            deviceName: 'string',
            msg: 'string',
            productKey: 'string',
            shareTaskCode: 'string',
            speechId: 'string',
            speechs: 'string',
            startTime: 'number',
        };
    }
}
exports.PageQuerySpeechBroadcastHourResponseBodyDataResultDataData = PageQuerySpeechBroadcastHourResponseBodyDataResultDataData;
class PageQuerySpeechBroadcastHourResponseBodyDataResultData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': PageQuerySpeechBroadcastHourResponseBodyDataResultDataData },
        };
    }
}
exports.PageQuerySpeechBroadcastHourResponseBodyDataResultData = PageQuerySpeechBroadcastHourResponseBodyDataResultData;
class PageQuerySpeechBroadcastHourResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageId: 'PageId',
            pageSize: 'PageSize',
            pageToken: 'PageToken',
            resultData: 'ResultData',
            total: 'Total',
        };
    }
    static types() {
        return {
            pageId: 'number',
            pageSize: 'number',
            pageToken: 'string',
            resultData: PageQuerySpeechBroadcastHourResponseBodyDataResultData,
            total: 'number',
        };
    }
}
exports.PageQuerySpeechBroadcastHourResponseBodyData = PageQuerySpeechBroadcastHourResponseBodyData;
class PrintByTemplateResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceErrorCode: 'DeviceErrorCode',
            deviceErrorMessage: 'DeviceErrorMessage',
            id: 'Id',
            maxRetryCount: 'MaxRetryCount',
            retryCount: 'RetryCount',
            success: 'Success',
        };
    }
    static types() {
        return {
            deviceErrorCode: 'string',
            deviceErrorMessage: 'string',
            id: 'string',
            maxRetryCount: 'number',
            retryCount: 'number',
            success: 'boolean',
        };
    }
}
exports.PrintByTemplateResponseBodyData = PrintByTemplateResponseBodyData;
class PubRequestUserProp extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.PubRequestUserProp = PubRequestUserProp;
class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            errorMsg: 'ErrorMsg',
            nickName: 'NickName',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            errorMsg: 'string',
            nickName: 'string',
        };
    }
}
exports.QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList = QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList;
class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDetailList: 'invalidDetailList',
        };
    }
    static types() {
        return {
            invalidDetailList: { 'type': 'array', 'itemType': QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList },
        };
    }
}
exports.QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList = QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList;
class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
        };
    }
    static types() {
        return {
            name: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList = QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList;
class QueryBatchRegisterDeviceStatusResponseBodyDataValidList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
        };
    }
    static types() {
        return {
            name: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryBatchRegisterDeviceStatusResponseBodyDataValidList = QueryBatchRegisterDeviceStatusResponseBodyDataValidList;
class QueryBatchRegisterDeviceStatusResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidDetailList: 'InvalidDetailList',
            invalidList: 'InvalidList',
            status: 'Status',
            validList: 'ValidList',
        };
    }
    static types() {
        return {
            invalidDetailList: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList,
            invalidList: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList,
            status: 'string',
            validList: QueryBatchRegisterDeviceStatusResponseBodyDataValidList,
        };
    }
}
exports.QueryBatchRegisterDeviceStatusResponseBodyData = QueryBatchRegisterDeviceStatusResponseBodyData;
class QueryClientIdsResponseBodyDataDynamicRegClientIds extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientId: 'ClientId',
            createTime: 'CreateTime',
        };
    }
    static types() {
        return {
            clientId: 'string',
            createTime: 'number',
        };
    }
}
exports.QueryClientIdsResponseBodyDataDynamicRegClientIds = QueryClientIdsResponseBodyDataDynamicRegClientIds;
class QueryClientIdsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dynamicRegClientIds: 'DynamicRegClientIds',
            iotId: 'IotId',
        };
    }
    static types() {
        return {
            dynamicRegClientIds: { 'type': 'array', 'itemType': QueryClientIdsResponseBodyDataDynamicRegClientIds },
            iotId: 'string',
        };
    }
}
exports.QueryClientIdsResponseBodyData = QueryClientIdsResponseBodyData;
class QueryConsumerGroupByGroupIdResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'CreateTime',
            groupId: 'GroupId',
            groupName: 'GroupName',
        };
    }
    static types() {
        return {
            createTime: 'string',
            groupId: 'string',
            groupName: 'string',
        };
    }
}
exports.QueryConsumerGroupByGroupIdResponseBodyData = QueryConsumerGroupByGroupIdResponseBodyData;
class QueryConsumerGroupListResponseBodyDataConsumerGroupDTO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'CreateTime',
            groupId: 'GroupId',
            groupName: 'GroupName',
        };
    }
    static types() {
        return {
            createTime: 'string',
            groupId: 'string',
            groupName: 'string',
        };
    }
}
exports.QueryConsumerGroupListResponseBodyDataConsumerGroupDTO = QueryConsumerGroupListResponseBodyDataConsumerGroupDTO;
class QueryConsumerGroupListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            consumerGroupDTO: 'ConsumerGroupDTO',
        };
    }
    static types() {
        return {
            consumerGroupDTO: { 'type': 'array', 'itemType': QueryConsumerGroupListResponseBodyDataConsumerGroupDTO },
        };
    }
}
exports.QueryConsumerGroupListResponseBodyData = QueryConsumerGroupListResponseBodyData;
class QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accumulatedConsumeCountPerMinute: 'AccumulatedConsumeCountPerMinute',
            clientId: 'ClientId',
            clientIpPort: 'ClientIpPort',
            onlineTime: 'OnlineTime',
            realTimeConsumeCountPerMinute: 'RealTimeConsumeCountPerMinute',
        };
    }
    static types() {
        return {
            accumulatedConsumeCountPerMinute: 'number',
            clientId: 'string',
            clientIpPort: 'string',
            onlineTime: 'number',
            realTimeConsumeCountPerMinute: 'number',
        };
    }
}
exports.QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo = QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo;
class QueryConsumerGroupStatusResponseBodyClientConnectionStatusList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            consumerGroupClientConnectionInfo: 'ConsumerGroupClientConnectionInfo',
        };
    }
    static types() {
        return {
            consumerGroupClientConnectionInfo: { 'type': 'array', 'itemType': QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo },
        };
    }
}
exports.QueryConsumerGroupStatusResponseBodyClientConnectionStatusList = QueryConsumerGroupStatusResponseBodyClientConnectionStatusList;
class QueryDetailSceneRuleLogResponseBodyDataLogList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            pkDn: 'PkDn',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            pkDn: 'string',
        };
    }
}
exports.QueryDetailSceneRuleLogResponseBodyDataLogList = QueryDetailSceneRuleLogResponseBodyDataLogList;
class QueryDetailSceneRuleLogResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            logList: 'LogList',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            logList: { 'type': 'array', 'itemType': QueryDetailSceneRuleLogResponseBodyDataLogList },
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryDetailSceneRuleLogResponseBodyData = QueryDetailSceneRuleLogResponseBodyData;
class QueryDeviceResponseBodyDataDeviceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceId: 'DeviceId',
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            deviceStatus: 'DeviceStatus',
            deviceType: 'DeviceType',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            iotId: 'IotId',
            nickname: 'Nickname',
            productKey: 'ProductKey',
            utcCreate: 'UtcCreate',
            utcModified: 'UtcModified',
        };
    }
    static types() {
        return {
            deviceId: 'string',
            deviceName: 'string',
            deviceSecret: 'string',
            deviceStatus: 'string',
            deviceType: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            iotId: 'string',
            nickname: 'string',
            productKey: 'string',
            utcCreate: 'string',
            utcModified: 'string',
        };
    }
}
exports.QueryDeviceResponseBodyDataDeviceInfo = QueryDeviceResponseBodyDataDeviceInfo;
class QueryDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceInfo: 'DeviceInfo',
        };
    }
    static types() {
        return {
            deviceInfo: { 'type': 'array', 'itemType': QueryDeviceResponseBodyDataDeviceInfo },
        };
    }
}
exports.QueryDeviceResponseBodyData = QueryDeviceResponseBodyData;
class QueryDeviceBySQLResponseBodyDataGroups extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
        };
    }
    static types() {
        return {
            groupId: 'string',
        };
    }
}
exports.QueryDeviceBySQLResponseBodyDataGroups = QueryDeviceBySQLResponseBodyDataGroups;
class QueryDeviceBySQLResponseBodyDataOTAModules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            firmwareVersion: 'FirmwareVersion',
            moduleName: 'ModuleName',
        };
    }
    static types() {
        return {
            firmwareVersion: 'string',
            moduleName: 'string',
        };
    }
}
exports.QueryDeviceBySQLResponseBodyDataOTAModules = QueryDeviceBySQLResponseBodyDataOTAModules;
class QueryDeviceBySQLResponseBodyDataTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagName: 'TagName',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagName: 'string',
            tagValue: 'string',
        };
    }
}
exports.QueryDeviceBySQLResponseBodyDataTags = QueryDeviceBySQLResponseBodyDataTags;
class QueryDeviceBySQLResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            activeTime: 'ActiveTime',
            deviceName: 'DeviceName',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            groups: 'Groups',
            iotId: 'IotId',
            nickname: 'Nickname',
            OTAModules: 'OTAModules',
            productKey: 'ProductKey',
            status: 'Status',
            tags: 'Tags',
        };
    }
    static types() {
        return {
            activeTime: 'string',
            deviceName: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            groups: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyDataGroups },
            iotId: 'string',
            nickname: 'string',
            OTAModules: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyDataOTAModules },
            productKey: 'string',
            status: 'string',
            tags: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyDataTags },
        };
    }
}
exports.QueryDeviceBySQLResponseBodyData = QueryDeviceBySQLResponseBodyData;
class QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            iotId: 'IotId',
            nickname: 'Nickname',
            productKey: 'ProductKey',
            status: 'Status',
            utcCreate: 'UtcCreate',
            utcModified: 'UtcModified',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            iotId: 'string',
            nickname: 'string',
            productKey: 'string',
            status: 'string',
            utcCreate: 'string',
            utcModified: 'string',
        };
    }
}
exports.QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo = QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo;
class QueryDeviceByStatusResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            simpleDeviceInfo: 'SimpleDeviceInfo',
        };
    }
    static types() {
        return {
            simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo },
        };
    }
}
exports.QueryDeviceByStatusResponseBodyData = QueryDeviceByStatusResponseBodyData;
class QueryDeviceByTagsRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.QueryDeviceByTagsRequestTag = QueryDeviceByTagsRequestTag;
class QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            productKey: 'ProductKey',
            productName: 'ProductName',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            productKey: 'string',
            productName: 'string',
        };
    }
}
exports.QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo = QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo;
class QueryDeviceByTagsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            simpleDeviceInfo: 'SimpleDeviceInfo',
        };
    }
    static types() {
        return {
            simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo },
        };
    }
}
exports.QueryDeviceByTagsResponseBodyData = QueryDeviceByTagsResponseBodyData;
class QueryDeviceCertResponseBodyDeviceCertInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            certSN: 'CertSN',
            certificate: 'Certificate',
            privateKey: 'PrivateKey',
            status: 'Status',
        };
    }
    static types() {
        return {
            certSN: 'string',
            certificate: 'string',
            privateKey: 'string',
            status: 'number',
        };
    }
}
exports.QueryDeviceCertResponseBodyDeviceCertInfo = QueryDeviceCertResponseBodyDeviceCertInfo;
class QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataType: 'DataType',
            identifier: 'Identifier',
            name: 'Name',
            time: 'Time',
            unit: 'Unit',
            value: 'Value',
            version: 'Version',
        };
    }
    static types() {
        return {
            dataType: 'string',
            identifier: 'string',
            name: 'string',
            time: 'string',
            unit: 'string',
            value: 'string',
            version: 'number',
        };
    }
}
exports.QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo = QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo;
class QueryDeviceDesiredPropertyResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            desiredPropertyInfo: 'DesiredPropertyInfo',
        };
    }
    static types() {
        return {
            desiredPropertyInfo: { 'type': 'array', 'itemType': QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo },
        };
    }
}
exports.QueryDeviceDesiredPropertyResponseBodyDataList = QueryDeviceDesiredPropertyResponseBodyDataList;
class QueryDeviceDesiredPropertyResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
        };
    }
    static types() {
        return {
            list: QueryDeviceDesiredPropertyResponseBodyDataList,
        };
    }
}
exports.QueryDeviceDesiredPropertyResponseBodyData = QueryDeviceDesiredPropertyResponseBodyData;
class QueryDeviceDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            firmwareVersion: 'FirmwareVersion',
            gmtActive: 'GmtActive',
            gmtCreate: 'GmtCreate',
            gmtOnline: 'GmtOnline',
            iotId: 'IotId',
            ipAddress: 'IpAddress',
            nickname: 'Nickname',
            nodeType: 'NodeType',
            owner: 'Owner',
            productKey: 'ProductKey',
            productName: 'ProductName',
            region: 'Region',
            status: 'Status',
            utcActive: 'UtcActive',
            utcCreate: 'UtcCreate',
            utcOnline: 'UtcOnline',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            firmwareVersion: 'string',
            gmtActive: 'string',
            gmtCreate: 'string',
            gmtOnline: 'string',
            iotId: 'string',
            ipAddress: 'string',
            nickname: 'string',
            nodeType: 'number',
            owner: 'boolean',
            productKey: 'string',
            productName: 'string',
            region: 'string',
            status: 'string',
            utcActive: 'string',
            utcCreate: 'string',
            utcOnline: 'string',
        };
    }
}
exports.QueryDeviceDetailResponseBodyData = QueryDeviceDetailResponseBodyData;
class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetInstanceId: 'TargetInstanceId',
        };
    }
    static types() {
        return {
            targetInstanceId: 'string',
        };
    }
}
exports.QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs = QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs;
class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetInstanceConfigs: 'targetInstanceConfigs',
        };
    }
    static types() {
        return {
            targetInstanceConfigs: { 'type': 'array', 'itemType': QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs },
        };
    }
}
exports.QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs = QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs;
class QueryDeviceDistributeJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'GmtCreate',
            jobId: 'JobId',
            productKey: 'ProductKey',
            sourceInstanceId: 'SourceInstanceId',
            sourceUid: 'SourceUid',
            status: 'Status',
            strategy: 'Strategy',
            targetInstanceConfigs: 'TargetInstanceConfigs',
            targetUid: 'TargetUid',
            total: 'Total',
        };
    }
    static types() {
        return {
            gmtCreate: 'number',
            jobId: 'string',
            productKey: 'string',
            sourceInstanceId: 'string',
            sourceUid: 'string',
            status: 'number',
            strategy: 'number',
            targetInstanceConfigs: QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs,
            targetUid: 'string',
            total: 'number',
        };
    }
}
exports.QueryDeviceDistributeJobResponseBodyData = QueryDeviceDistributeJobResponseBodyData;
class QueryDeviceEventDataResponseBodyDataListEventInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventType: 'EventType',
            identifier: 'Identifier',
            name: 'Name',
            outputData: 'OutputData',
            time: 'Time',
        };
    }
    static types() {
        return {
            eventType: 'string',
            identifier: 'string',
            name: 'string',
            outputData: 'string',
            time: 'string',
        };
    }
}
exports.QueryDeviceEventDataResponseBodyDataListEventInfo = QueryDeviceEventDataResponseBodyDataListEventInfo;
class QueryDeviceEventDataResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventInfo: 'EventInfo',
        };
    }
    static types() {
        return {
            eventInfo: { 'type': 'array', 'itemType': QueryDeviceEventDataResponseBodyDataListEventInfo },
        };
    }
}
exports.QueryDeviceEventDataResponseBodyDataList = QueryDeviceEventDataResponseBodyDataList;
class QueryDeviceEventDataResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            nextTime: 'NextTime',
            nextValid: 'NextValid',
        };
    }
    static types() {
        return {
            list: QueryDeviceEventDataResponseBodyDataList,
            nextTime: 'number',
            nextValid: 'boolean',
        };
    }
}
exports.QueryDeviceEventDataResponseBodyData = QueryDeviceEventDataResponseBodyData;
class QueryDeviceFileResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadUrl: 'DownloadUrl',
            fileId: 'FileId',
            name: 'Name',
            size: 'Size',
            utcCreatedOn: 'UtcCreatedOn',
        };
    }
    static types() {
        return {
            downloadUrl: 'string',
            fileId: 'string',
            name: 'string',
            size: 'string',
            utcCreatedOn: 'string',
        };
    }
}
exports.QueryDeviceFileResponseBodyData = QueryDeviceFileResponseBodyData;
class QueryDeviceFileListResponseBodyDataFileSummary extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileId: 'FileId',
            name: 'Name',
            size: 'Size',
            utcCreatedOn: 'UtcCreatedOn',
        };
    }
    static types() {
        return {
            fileId: 'string',
            name: 'string',
            size: 'string',
            utcCreatedOn: 'string',
        };
    }
}
exports.QueryDeviceFileListResponseBodyDataFileSummary = QueryDeviceFileListResponseBodyDataFileSummary;
class QueryDeviceFileListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileSummary: 'FileSummary',
        };
    }
    static types() {
        return {
            fileSummary: { 'type': 'array', 'itemType': QueryDeviceFileListResponseBodyDataFileSummary },
        };
    }
}
exports.QueryDeviceFileListResponseBodyData = QueryDeviceFileListResponseBodyData;
class QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupDesc: 'GroupDesc',
            groupId: 'GroupId',
            groupName: 'GroupName',
            groupType: 'GroupType',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            groupDesc: 'string',
            groupId: 'string',
            groupName: 'string',
            groupType: 'string',
            utcCreate: 'string',
        };
    }
}
exports.QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo = QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo;
class QueryDeviceGroupByDeviceResponseBodyGroupInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupInfo: 'GroupInfo',
        };
    }
    static types() {
        return {
            groupInfo: { 'type': 'array', 'itemType': QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo },
        };
    }
}
exports.QueryDeviceGroupByDeviceResponseBodyGroupInfos = QueryDeviceGroupByDeviceResponseBodyGroupInfos;
class QueryDeviceGroupByTagsRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.QueryDeviceGroupByTagsRequestTag = QueryDeviceGroupByTagsRequestTag;
class QueryDeviceGroupByTagsResponseBodyDataDeviceGroup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'GroupId',
            groupName: 'GroupName',
        };
    }
    static types() {
        return {
            groupId: 'string',
            groupName: 'string',
        };
    }
}
exports.QueryDeviceGroupByTagsResponseBodyDataDeviceGroup = QueryDeviceGroupByTagsResponseBodyDataDeviceGroup;
class QueryDeviceGroupByTagsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceGroup: 'DeviceGroup',
        };
    }
    static types() {
        return {
            deviceGroup: { 'type': 'array', 'itemType': QueryDeviceGroupByTagsResponseBodyDataDeviceGroup },
        };
    }
}
exports.QueryDeviceGroupByTagsResponseBodyData = QueryDeviceGroupByTagsResponseBodyData;
class QueryDeviceGroupInfoResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceActive: 'DeviceActive',
            deviceCount: 'DeviceCount',
            deviceOnline: 'DeviceOnline',
            dynamicGroupExpression: 'DynamicGroupExpression',
            groupDesc: 'GroupDesc',
            groupId: 'GroupId',
            groupName: 'GroupName',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            deviceActive: 'number',
            deviceCount: 'number',
            deviceOnline: 'number',
            dynamicGroupExpression: 'string',
            groupDesc: 'string',
            groupId: 'string',
            groupName: 'string',
            utcCreate: 'string',
        };
    }
}
exports.QueryDeviceGroupInfoResponseBodyData = QueryDeviceGroupInfoResponseBodyData;
class QueryDeviceGroupListResponseBodyDataGroupInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupDesc: 'GroupDesc',
            groupId: 'GroupId',
            groupName: 'GroupName',
            groupType: 'GroupType',
            utcCreate: 'UtcCreate',
        };
    }
    static types() {
        return {
            groupDesc: 'string',
            groupId: 'string',
            groupName: 'string',
            groupType: 'string',
            utcCreate: 'string',
        };
    }
}
exports.QueryDeviceGroupListResponseBodyDataGroupInfo = QueryDeviceGroupListResponseBodyDataGroupInfo;
class QueryDeviceGroupListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupInfo: 'GroupInfo',
        };
    }
    static types() {
        return {
            groupInfo: { 'type': 'array', 'itemType': QueryDeviceGroupListResponseBodyDataGroupInfo },
        };
    }
}
exports.QueryDeviceGroupListResponseBodyData = QueryDeviceGroupListResponseBodyData;
class QueryDeviceGroupTagListResponseBodyDataGroupTagInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.QueryDeviceGroupTagListResponseBodyDataGroupTagInfo = QueryDeviceGroupTagListResponseBodyDataGroupTagInfo;
class QueryDeviceGroupTagListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupTagInfo: 'GroupTagInfo',
        };
    }
    static types() {
        return {
            groupTagInfo: { 'type': 'array', 'itemType': QueryDeviceGroupTagListResponseBodyDataGroupTagInfo },
        };
    }
}
exports.QueryDeviceGroupTagListResponseBodyData = QueryDeviceGroupTagListResponseBodyData;
class QueryDeviceInfoResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            iotId: 'IotId',
            nickname: 'Nickname',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            iotId: 'string',
            nickname: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryDeviceInfoResponseBodyData = QueryDeviceInfoResponseBodyData;
class QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            productKey: 'ProductKey',
            productName: 'ProductName',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            productKey: 'string',
            productName: 'string',
        };
    }
}
exports.QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo = QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo;
class QueryDeviceListByDeviceGroupResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            simpleDeviceInfo: 'SimpleDeviceInfo',
        };
    }
    static types() {
        return {
            simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo },
        };
    }
}
exports.QueryDeviceListByDeviceGroupResponseBodyData = QueryDeviceListByDeviceGroupResponseBodyData;
class QueryDeviceOriginalEventDataResponseBodyDataListEventInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventType: 'EventType',
            identifier: 'Identifier',
            name: 'Name',
            outputData: 'OutputData',
            time: 'Time',
        };
    }
    static types() {
        return {
            eventType: 'string',
            identifier: 'string',
            name: 'string',
            outputData: 'string',
            time: 'string',
        };
    }
}
exports.QueryDeviceOriginalEventDataResponseBodyDataListEventInfo = QueryDeviceOriginalEventDataResponseBodyDataListEventInfo;
class QueryDeviceOriginalEventDataResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventInfo: 'EventInfo',
        };
    }
    static types() {
        return {
            eventInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalEventDataResponseBodyDataListEventInfo },
        };
    }
}
exports.QueryDeviceOriginalEventDataResponseBodyDataList = QueryDeviceOriginalEventDataResponseBodyDataList;
class QueryDeviceOriginalEventDataResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            nextPageToken: 'NextPageToken',
            nextValid: 'NextValid',
        };
    }
    static types() {
        return {
            list: QueryDeviceOriginalEventDataResponseBodyDataList,
            nextPageToken: 'string',
            nextValid: 'boolean',
        };
    }
}
exports.QueryDeviceOriginalEventDataResponseBodyData = QueryDeviceOriginalEventDataResponseBodyData;
class QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            time: 'Time',
            value: 'Value',
        };
    }
    static types() {
        return {
            time: 'string',
            value: 'string',
        };
    }
}
exports.QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo = QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo;
class QueryDeviceOriginalPropertyDataResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            propertyInfo: 'PropertyInfo',
        };
    }
    static types() {
        return {
            propertyInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo },
        };
    }
}
exports.QueryDeviceOriginalPropertyDataResponseBodyDataList = QueryDeviceOriginalPropertyDataResponseBodyDataList;
class QueryDeviceOriginalPropertyDataResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            nextValid: 'NextValid',
            nextPageToken: 'nextPageToken',
        };
    }
    static types() {
        return {
            list: QueryDeviceOriginalPropertyDataResponseBodyDataList,
            nextValid: 'boolean',
            nextPageToken: 'string',
        };
    }
}
exports.QueryDeviceOriginalPropertyDataResponseBodyData = QueryDeviceOriginalPropertyDataResponseBodyData;
class QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            identifier: 'Identifier',
            time: 'Time',
            value: 'Value',
        };
    }
    static types() {
        return {
            identifier: 'string',
            time: 'number',
            value: 'string',
        };
    }
}
exports.QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo = QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo;
class QueryDeviceOriginalPropertyStatusResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            propertyStatusDataInfo: 'PropertyStatusDataInfo',
        };
    }
    static types() {
        return {
            propertyStatusDataInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo },
        };
    }
}
exports.QueryDeviceOriginalPropertyStatusResponseBodyDataList = QueryDeviceOriginalPropertyStatusResponseBodyDataList;
class QueryDeviceOriginalPropertyStatusResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            nextPageToken: 'NextPageToken',
            nextValid: 'NextValid',
        };
    }
    static types() {
        return {
            list: QueryDeviceOriginalPropertyStatusResponseBodyDataList,
            nextPageToken: 'string',
            nextValid: 'boolean',
        };
    }
}
exports.QueryDeviceOriginalPropertyStatusResponseBodyData = QueryDeviceOriginalPropertyStatusResponseBodyData;
class QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            identifier: 'Identifier',
            inputData: 'InputData',
            name: 'Name',
            outputData: 'OutputData',
            time: 'Time',
        };
    }
    static types() {
        return {
            identifier: 'string',
            inputData: 'string',
            name: 'string',
            outputData: 'string',
            time: 'string',
        };
    }
}
exports.QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo = QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo;
class QueryDeviceOriginalServiceDataResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            serviceInfo: 'ServiceInfo',
        };
    }
    static types() {
        return {
            serviceInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo },
        };
    }
}
exports.QueryDeviceOriginalServiceDataResponseBodyDataList = QueryDeviceOriginalServiceDataResponseBodyDataList;
class QueryDeviceOriginalServiceDataResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            nextPageToken: 'NextPageToken',
            nextValid: 'NextValid',
        };
    }
    static types() {
        return {
            list: QueryDeviceOriginalServiceDataResponseBodyDataList,
            nextPageToken: 'string',
            nextValid: 'boolean',
        };
    }
}
exports.QueryDeviceOriginalServiceDataResponseBodyData = QueryDeviceOriginalServiceDataResponseBodyData;
class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            time: 'Time',
            value: 'Value',
        };
    }
    static types() {
        return {
            time: 'number',
            value: 'string',
        };
    }
}
exports.QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo = QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo;
class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            propertyInfo: 'PropertyInfo',
        };
    }
    static types() {
        return {
            propertyInfo: { 'type': 'array', 'itemType': QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo },
        };
    }
}
exports.QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList = QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList;
class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            identifier: 'Identifier',
            list: 'List',
        };
    }
    static types() {
        return {
            identifier: 'string',
            list: QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList,
        };
    }
}
exports.QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo = QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo;
class QueryDevicePropertiesDataResponseBodyPropertyDataInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            propertyDataInfo: 'PropertyDataInfo',
        };
    }
    static types() {
        return {
            propertyDataInfo: { 'type': 'array', 'itemType': QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo },
        };
    }
}
exports.QueryDevicePropertiesDataResponseBodyPropertyDataInfos = QueryDevicePropertiesDataResponseBodyPropertyDataInfos;
class QueryDevicePropertyDataResponseBodyDataListPropertyInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            time: 'Time',
            value: 'Value',
        };
    }
    static types() {
        return {
            time: 'string',
            value: 'string',
        };
    }
}
exports.QueryDevicePropertyDataResponseBodyDataListPropertyInfo = QueryDevicePropertyDataResponseBodyDataListPropertyInfo;
class QueryDevicePropertyDataResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            propertyInfo: 'PropertyInfo',
        };
    }
    static types() {
        return {
            propertyInfo: { 'type': 'array', 'itemType': QueryDevicePropertyDataResponseBodyDataListPropertyInfo },
        };
    }
}
exports.QueryDevicePropertyDataResponseBodyDataList = QueryDevicePropertyDataResponseBodyDataList;
class QueryDevicePropertyDataResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            nextTime: 'NextTime',
            nextValid: 'NextValid',
        };
    }
    static types() {
        return {
            list: QueryDevicePropertyDataResponseBodyDataList,
            nextTime: 'number',
            nextValid: 'boolean',
        };
    }
}
exports.QueryDevicePropertyDataResponseBodyData = QueryDevicePropertyDataResponseBodyData;
class QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataType: 'DataType',
            identifier: 'Identifier',
            name: 'Name',
            time: 'Time',
            unit: 'Unit',
            value: 'Value',
        };
    }
    static types() {
        return {
            dataType: 'string',
            identifier: 'string',
            name: 'string',
            time: 'string',
            unit: 'string',
            value: 'string',
        };
    }
}
exports.QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo = QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo;
class QueryDevicePropertyStatusResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            propertyStatusInfo: 'PropertyStatusInfo',
        };
    }
    static types() {
        return {
            propertyStatusInfo: { 'type': 'array', 'itemType': QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo },
        };
    }
}
exports.QueryDevicePropertyStatusResponseBodyDataList = QueryDevicePropertyStatusResponseBodyDataList;
class QueryDevicePropertyStatusResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
        };
    }
    static types() {
        return {
            list: QueryDevicePropertyStatusResponseBodyDataList,
        };
    }
}
exports.QueryDevicePropertyStatusResponseBodyData = QueryDevicePropertyStatusResponseBodyData;
class QueryDeviceProvisioningResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliyunUid: 'AliyunUid',
            deviceName: 'DeviceName',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            productKey: 'ProductKey',
            sourceIotInstanceId: 'SourceIotInstanceId',
            sourceRegion: 'SourceRegion',
            targetIotInstanceId: 'TargetIotInstanceId',
            targetRegion: 'TargetRegion',
        };
    }
    static types() {
        return {
            aliyunUid: 'string',
            deviceName: 'string',
            gmtCreate: 'number',
            gmtModified: 'number',
            productKey: 'string',
            sourceIotInstanceId: 'string',
            sourceRegion: 'string',
            targetIotInstanceId: 'string',
            targetRegion: 'string',
        };
    }
}
exports.QueryDeviceProvisioningResponseBodyData = QueryDeviceProvisioningResponseBodyData;
class QueryDeviceServiceDataResponseBodyDataListServiceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            identifier: 'Identifier',
            inputData: 'InputData',
            name: 'Name',
            outputData: 'OutputData',
            time: 'Time',
        };
    }
    static types() {
        return {
            identifier: 'string',
            inputData: 'string',
            name: 'string',
            outputData: 'string',
            time: 'string',
        };
    }
}
exports.QueryDeviceServiceDataResponseBodyDataListServiceInfo = QueryDeviceServiceDataResponseBodyDataListServiceInfo;
class QueryDeviceServiceDataResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            serviceInfo: 'ServiceInfo',
        };
    }
    static types() {
        return {
            serviceInfo: { 'type': 'array', 'itemType': QueryDeviceServiceDataResponseBodyDataListServiceInfo },
        };
    }
}
exports.QueryDeviceServiceDataResponseBodyDataList = QueryDeviceServiceDataResponseBodyDataList;
class QueryDeviceServiceDataResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            nextTime: 'NextTime',
            nextValid: 'NextValid',
        };
    }
    static types() {
        return {
            list: QueryDeviceServiceDataResponseBodyDataList,
            nextTime: 'number',
            nextValid: 'boolean',
        };
    }
}
exports.QueryDeviceServiceDataResponseBodyData = QueryDeviceServiceDataResponseBodyData;
class QueryDeviceSpeechResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            bizCode: 'BizCode',
            size: 'Size',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            bizCode: 'string',
            size: 'number',
        };
    }
}
exports.QueryDeviceSpeechResponseBodyDataListItems = QueryDeviceSpeechResponseBodyDataListItems;
class QueryDeviceSpeechResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QueryDeviceSpeechResponseBodyDataListItems },
        };
    }
}
exports.QueryDeviceSpeechResponseBodyDataList = QueryDeviceSpeechResponseBodyDataList;
class QueryDeviceSpeechResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QueryDeviceSpeechResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryDeviceSpeechResponseBodyData = QueryDeviceSpeechResponseBodyData;
class QueryDeviceStatisticsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            activeCount: 'activeCount',
            deviceCount: 'deviceCount',
            onlineCount: 'onlineCount',
        };
    }
    static types() {
        return {
            activeCount: 'number',
            deviceCount: 'number',
            onlineCount: 'number',
        };
    }
}
exports.QueryDeviceStatisticsResponseBodyData = QueryDeviceStatisticsResponseBodyData;
class QueryDeviceSubTopicResponseBodyTopicList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            timestamp: 'Timestamp',
            topicName: 'TopicName',
        };
    }
    static types() {
        return {
            timestamp: 'number',
            topicName: 'string',
        };
    }
}
exports.QueryDeviceSubTopicResponseBodyTopicList = QueryDeviceSubTopicResponseBodyTopicList;
class QueryDeviceTunnelResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            deviceConnState: 'DeviceConnState',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            productKey: 'ProductKey',
            productName: 'ProductName',
            sourceConnState: 'SourceConnState',
            tunnelId: 'TunnelId',
            tunnelState: 'TunnelState',
            udi: 'Udi',
            utcClosed: 'UtcClosed',
            utcCreated: 'UtcCreated',
        };
    }
    static types() {
        return {
            description: 'string',
            deviceConnState: 'string',
            deviceName: 'string',
            iotId: 'string',
            productKey: 'string',
            productName: 'string',
            sourceConnState: 'string',
            tunnelId: 'string',
            tunnelState: 'string',
            udi: 'string',
            utcClosed: 'string',
            utcCreated: 'string',
        };
    }
}
exports.QueryDeviceTunnelResponseBodyData = QueryDeviceTunnelResponseBodyData;
class QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            time: 'Time',
            value: 'Value',
        };
    }
    static types() {
        return {
            time: 'string',
            value: 'string',
        };
    }
}
exports.QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo = QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo;
class QueryDevicesHotStorageDataResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            propertyInfo: 'PropertyInfo',
        };
    }
    static types() {
        return {
            propertyInfo: { 'type': 'array', 'itemType': QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo },
        };
    }
}
exports.QueryDevicesHotStorageDataResponseBodyDataList = QueryDevicesHotStorageDataResponseBodyDataList;
class QueryDevicesHotStorageDataResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            nextValid: 'NextValid',
            nextPageToken: 'nextPageToken',
        };
    }
    static types() {
        return {
            list: QueryDevicesHotStorageDataResponseBodyDataList,
            nextValid: 'boolean',
            nextPageToken: 'string',
        };
    }
}
exports.QueryDevicesHotStorageDataResponseBodyData = QueryDevicesHotStorageDataResponseBodyData;
class QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            identifier: 'Identifier',
            time: 'Time',
            value: 'Value',
        };
    }
    static types() {
        return {
            identifier: 'string',
            time: 'number',
            value: 'string',
        };
    }
}
exports.QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo = QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo;
class QueryDevicesHotStorageDataStatusResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            propertyStatusDataInfo: 'PropertyStatusDataInfo',
        };
    }
    static types() {
        return {
            propertyStatusDataInfo: { 'type': 'array', 'itemType': QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo },
        };
    }
}
exports.QueryDevicesHotStorageDataStatusResponseBodyDataList = QueryDevicesHotStorageDataStatusResponseBodyDataList;
class QueryDevicesHotStorageDataStatusResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            nextPageToken: 'NextPageToken',
            nextValid: 'NextValid',
        };
    }
    static types() {
        return {
            list: QueryDevicesHotStorageDataStatusResponseBodyDataList,
            nextPageToken: 'string',
            nextValid: 'boolean',
        };
    }
}
exports.QueryDevicesHotStorageDataStatusResponseBodyData = QueryDevicesHotStorageDataStatusResponseBodyData;
class QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            activeTime: 'ActiveTime',
            categoryKey: 'CategoryKey',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            lastOnlineTime: 'LastOnlineTime',
            nickname: 'Nickname',
            nodeType: 'NodeType',
            productKey: 'ProductKey',
            productName: 'ProductName',
            status: 'Status',
            utcActiveTime: 'UtcActiveTime',
            utcLastOnlineTime: 'UtcLastOnlineTime',
        };
    }
    static types() {
        return {
            activeTime: 'string',
            categoryKey: 'string',
            deviceName: 'string',
            iotId: 'string',
            lastOnlineTime: 'string',
            nickname: 'string',
            nodeType: 'number',
            productKey: 'string',
            productName: 'string',
            status: 'string',
            utcActiveTime: 'string',
            utcLastOnlineTime: 'string',
        };
    }
}
exports.QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo = QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo;
class QueryDynamicGroupDevicesResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            simpleDeviceInfo: 'SimpleDeviceInfo',
        };
    }
    static types() {
        return {
            simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo },
        };
    }
}
exports.QueryDynamicGroupDevicesResponseBodyData = QueryDynamicGroupDevicesResponseBodyData;
class QueryEdgeDriverResponseBodyDataDriverList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cpuArch: 'CpuArch',
            driverId: 'DriverId',
            driverName: 'DriverName',
            driverProtocol: 'DriverProtocol',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            isApply: 'IsApply',
            isBuiltIn: 'IsBuiltIn',
            runtime: 'Runtime',
            type: 'Type',
        };
    }
    static types() {
        return {
            cpuArch: 'string',
            driverId: 'string',
            driverName: 'string',
            driverProtocol: 'string',
            gmtCreateTimestamp: 'number',
            gmtModifiedTimestamp: 'number',
            isApply: 'boolean',
            isBuiltIn: 'boolean',
            runtime: 'string',
            type: 'number',
        };
    }
}
exports.QueryEdgeDriverResponseBodyDataDriverList = QueryEdgeDriverResponseBodyDataDriverList;
class QueryEdgeDriverResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            driverList: 'DriverList',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            driverList: { 'type': 'array', 'itemType': QueryEdgeDriverResponseBodyDataDriverList },
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryEdgeDriverResponseBodyData = QueryEdgeDriverResponseBodyData;
class QueryEdgeDriverVersionResponseBodyDataDriverVersionList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            argument: 'Argument',
            configCheckRule: 'ConfigCheckRule',
            containerConfig: 'ContainerConfig',
            description: 'Description',
            driverConfig: 'DriverConfig',
            driverId: 'DriverId',
            driverVersion: 'DriverVersion',
            edgeVersion: 'EdgeVersion',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            sourceConfig: 'SourceConfig',
            versionState: 'VersionState',
        };
    }
    static types() {
        return {
            argument: 'string',
            configCheckRule: 'string',
            containerConfig: 'string',
            description: 'string',
            driverConfig: 'string',
            driverId: 'string',
            driverVersion: 'string',
            edgeVersion: 'string',
            gmtCreateTimestamp: 'number',
            gmtModifiedTimestamp: 'number',
            sourceConfig: 'string',
            versionState: 'string',
        };
    }
}
exports.QueryEdgeDriverVersionResponseBodyDataDriverVersionList = QueryEdgeDriverVersionResponseBodyDataDriverVersionList;
class QueryEdgeDriverVersionResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            driverVersionList: 'DriverVersionList',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            driverVersionList: { 'type': 'array', 'itemType': QueryEdgeDriverVersionResponseBodyDataDriverVersionList },
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryEdgeDriverVersionResponseBodyData = QueryEdgeDriverVersionResponseBodyData;
class QueryEdgeInstanceResponseBodyDataInstanceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizEnable: 'BizEnable',
            gmtCreate: 'GmtCreate',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModified: 'GmtModified',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            instanceId: 'InstanceId',
            latestDeploymentStatus: 'LatestDeploymentStatus',
            latestDeploymentType: 'LatestDeploymentType',
            name: 'Name',
            roleArn: 'RoleArn',
            roleAttachTime: 'RoleAttachTime',
            roleAttachTimestamp: 'RoleAttachTimestamp',
            roleName: 'RoleName',
            spec: 'Spec',
            tags: 'Tags',
            type: 'Type',
        };
    }
    static types() {
        return {
            bizEnable: 'boolean',
            gmtCreate: 'string',
            gmtCreateTimestamp: 'number',
            gmtModified: 'string',
            gmtModifiedTimestamp: 'number',
            instanceId: 'string',
            latestDeploymentStatus: 'number',
            latestDeploymentType: 'string',
            name: 'string',
            roleArn: 'string',
            roleAttachTime: 'string',
            roleAttachTimestamp: 'number',
            roleName: 'string',
            spec: 'number',
            tags: 'string',
            type: 'number',
        };
    }
}
exports.QueryEdgeInstanceResponseBodyDataInstanceList = QueryEdgeInstanceResponseBodyDataInstanceList;
class QueryEdgeInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            instanceList: 'InstanceList',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            instanceList: { 'type': 'array', 'itemType': QueryEdgeInstanceResponseBodyDataInstanceList },
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryEdgeInstanceResponseBodyData = QueryEdgeInstanceResponseBodyData;
class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configId: 'ConfigId',
            content: 'Content',
            format: 'Format',
            key: 'Key',
        };
    }
    static types() {
        return {
            configId: 'string',
            content: 'string',
            format: 'string',
            key: 'string',
        };
    }
}
exports.QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig = QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig;
class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'Config',
        };
    }
    static types() {
        return {
            config: { 'type': 'array', 'itemType': QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig },
        };
    }
}
exports.QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList = QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList;
class QueryEdgeInstanceChannelResponseBodyDataChannelListChannel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelId: 'ChannelId',
            channelName: 'ChannelName',
            configList: 'ConfigList',
            gmtCreate: 'GmtCreate',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModified: 'GmtModified',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
        };
    }
    static types() {
        return {
            channelId: 'string',
            channelName: 'string',
            configList: QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList,
            gmtCreate: 'string',
            gmtCreateTimestamp: 'number',
            gmtModified: 'string',
            gmtModifiedTimestamp: 'number',
        };
    }
}
exports.QueryEdgeInstanceChannelResponseBodyDataChannelListChannel = QueryEdgeInstanceChannelResponseBodyDataChannelListChannel;
class QueryEdgeInstanceChannelResponseBodyDataChannelList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channel: 'Channel',
        };
    }
    static types() {
        return {
            channel: { 'type': 'array', 'itemType': QueryEdgeInstanceChannelResponseBodyDataChannelListChannel },
        };
    }
}
exports.QueryEdgeInstanceChannelResponseBodyDataChannelList = QueryEdgeInstanceChannelResponseBodyDataChannelList;
class QueryEdgeInstanceChannelResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channelList: 'ChannelList',
            currentPage: 'CurrentPage',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            channelList: QueryEdgeInstanceChannelResponseBodyDataChannelList,
            currentPage: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryEdgeInstanceChannelResponseBodyData = QueryEdgeInstanceChannelResponseBodyData;
class QueryEdgeInstanceDeviceResponseBodyDataDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            driverId: 'DriverId',
            iotId: 'IotId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            driverId: 'string',
            iotId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryEdgeInstanceDeviceResponseBodyDataDeviceList = QueryEdgeInstanceDeviceResponseBodyDataDeviceList;
class QueryEdgeInstanceDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            deviceList: 'DeviceList',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            deviceList: { 'type': 'array', 'itemType': QueryEdgeInstanceDeviceResponseBodyDataDeviceList },
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryEdgeInstanceDeviceResponseBodyData = QueryEdgeInstanceDeviceResponseBodyData;
class QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iotId: 'IotId',
        };
    }
    static types() {
        return {
            iotId: 'string',
        };
    }
}
exports.QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList = QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList;
class QueryEdgeInstanceDeviceByDriverResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            deviceList: 'DeviceList',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            deviceList: { 'type': 'array', 'itemType': QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList },
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryEdgeInstanceDeviceByDriverResponseBodyData = QueryEdgeInstanceDeviceByDriverResponseBodyData;
class QueryEdgeInstanceDriverResponseBodyDataDriverList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            driverId: 'DriverId',
            driverVersion: 'DriverVersion',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            driverId: 'string',
            driverVersion: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            orderId: 'string',
        };
    }
}
exports.QueryEdgeInstanceDriverResponseBodyDataDriverList = QueryEdgeInstanceDriverResponseBodyDataDriverList;
class QueryEdgeInstanceDriverResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            driverList: 'DriverList',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            driverList: { 'type': 'array', 'itemType': QueryEdgeInstanceDriverResponseBodyDataDriverList },
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryEdgeInstanceDriverResponseBodyData = QueryEdgeInstanceDriverResponseBodyData;
class QueryEdgeInstanceGatewayResponseBodyGatewayList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            edgeVersion: 'EdgeVersion',
            iotId: 'IotId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            edgeVersion: 'string',
            iotId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryEdgeInstanceGatewayResponseBodyGatewayList = QueryEdgeInstanceGatewayResponseBodyGatewayList;
class QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deploymentId: 'DeploymentId',
            description: 'Description',
            gmtCompleted: 'GmtCompleted',
            gmtCompletedTimestamp: 'GmtCompletedTimestamp',
            gmtCreate: 'GmtCreate',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModified: 'GmtModified',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            status: 'Status',
            type: 'Type',
        };
    }
    static types() {
        return {
            deploymentId: 'string',
            description: 'string',
            gmtCompleted: 'string',
            gmtCompletedTimestamp: 'number',
            gmtCreate: 'string',
            gmtCreateTimestamp: 'number',
            gmtModified: 'string',
            gmtModifiedTimestamp: 'number',
            status: 'number',
            type: 'string',
        };
    }
}
exports.QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList = QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList;
class QueryEdgeInstanceHistoricDeploymentResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            deploymentList: 'DeploymentList',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            deploymentList: { 'type': 'array', 'itemType': QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList },
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryEdgeInstanceHistoricDeploymentResponseBodyData = QueryEdgeInstanceHistoricDeploymentResponseBodyData;
class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qos: 'Qos',
            sourceApplicationName: 'SourceApplicationName',
            sourceFcFunctionName: 'SourceFcFunctionName',
            sourceFcServiceName: 'SourceFcServiceName',
            targetApplicationName: 'TargetApplicationName',
            targetFcFunctionName: 'TargetFcFunctionName',
            targetFcServiceName: 'TargetFcServiceName',
        };
    }
    static types() {
        return {
            qos: 'string',
            sourceApplicationName: 'string',
            sourceFcFunctionName: 'string',
            sourceFcServiceName: 'string',
            targetApplicationName: 'string',
            targetFcFunctionName: 'string',
            targetFcServiceName: 'string',
        };
    }
}
exports.QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext = QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext;
class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'GmtCreate',
            gmtCreateTimestamp: 'GmtCreateTimestamp',
            gmtModified: 'GmtModified',
            gmtModifiedTimestamp: 'GmtModifiedTimestamp',
            name: 'Name',
            routeContext: 'RouteContext',
            routeId: 'RouteId',
            sourceData: 'SourceData',
            sourceType: 'SourceType',
            targetData: 'TargetData',
            targetType: 'TargetType',
            topicFilter: 'TopicFilter',
        };
    }
    static types() {
        return {
            gmtCreate: 'string',
            gmtCreateTimestamp: 'number',
            gmtModified: 'string',
            gmtModifiedTimestamp: 'number',
            name: 'string',
            routeContext: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext,
            routeId: 'number',
            sourceData: 'string',
            sourceType: 'string',
            targetData: 'string',
            targetType: 'string',
            topicFilter: 'string',
        };
    }
}
exports.QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute = QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute;
class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageRoute: 'MessageRoute',
        };
    }
    static types() {
        return {
            messageRoute: { 'type': 'array', 'itemType': QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute },
        };
    }
}
exports.QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList = QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList;
class QueryEdgeInstanceMessageRoutingResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            messageRouteList: 'MessageRouteList',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            messageRouteList: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList,
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryEdgeInstanceMessageRoutingResponseBodyData = QueryEdgeInstanceMessageRoutingResponseBodyData;
class QueryEdgeInstanceSceneRuleResponseBodyDataRuleList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'GmtCreate',
            isExisted: 'IsExisted',
            ruleId: 'RuleId',
            ruleName: 'RuleName',
            status: 'Status',
        };
    }
    static types() {
        return {
            gmtCreate: 'number',
            isExisted: 'number',
            ruleId: 'string',
            ruleName: 'string',
            status: 'number',
        };
    }
}
exports.QueryEdgeInstanceSceneRuleResponseBodyDataRuleList = QueryEdgeInstanceSceneRuleResponseBodyDataRuleList;
class QueryEdgeInstanceSceneRuleResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            pageSize: 'PageSize',
            ruleList: 'RuleList',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            pageSize: 'number',
            ruleList: { 'type': 'array', 'itemType': QueryEdgeInstanceSceneRuleResponseBodyDataRuleList },
            total: 'number',
        };
    }
}
exports.QueryEdgeInstanceSceneRuleResponseBodyData = QueryEdgeInstanceSceneRuleResponseBodyData;
class QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            productKey: 'ProductKey',
            sn: 'Sn',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceSecret: 'string',
            productKey: 'string',
            sn: 'string',
        };
    }
}
exports.QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice = QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice;
class QueryImportedDeviceByApplyIdResponseBodyDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            device: 'device',
        };
    }
    static types() {
        return {
            device: { 'type': 'array', 'itemType': QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice },
        };
    }
}
exports.QueryImportedDeviceByApplyIdResponseBodyDeviceList = QueryImportedDeviceByApplyIdResponseBodyDeviceList;
class QueryJobResponseBodyDataJobFile extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileUrl: 'FileUrl',
            sign: 'Sign',
            signMethod: 'SignMethod',
        };
    }
    static types() {
        return {
            fileUrl: 'string',
            sign: 'string',
            signMethod: 'string',
        };
    }
}
exports.QueryJobResponseBodyDataJobFile = QueryJobResponseBodyDataJobFile;
class QueryJobResponseBodyDataRolloutConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maximumPerMinute: 'MaximumPerMinute',
            messageQoS: 'MessageQoS',
        };
    }
    static types() {
        return {
            maximumPerMinute: 'number',
            messageQoS: 'string',
        };
    }
}
exports.QueryJobResponseBodyDataRolloutConfig = QueryJobResponseBodyDataRolloutConfig;
class QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices = QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices;
class QueryJobResponseBodyDataTargetConfigTargetDevices extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetDevices: 'targetDevices',
        };
    }
    static types() {
        return {
            targetDevices: { 'type': 'array', 'itemType': QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices },
        };
    }
}
exports.QueryJobResponseBodyDataTargetConfigTargetDevices = QueryJobResponseBodyDataTargetConfigTargetDevices;
class QueryJobResponseBodyDataTargetConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetDevices: 'TargetDevices',
            targetGroup: 'TargetGroup',
            targetProduct: 'TargetProduct',
            targetType: 'TargetType',
        };
    }
    static types() {
        return {
            targetDevices: QueryJobResponseBodyDataTargetConfigTargetDevices,
            targetGroup: 'string',
            targetProduct: 'string',
            targetType: 'string',
        };
    }
}
exports.QueryJobResponseBodyDataTargetConfig = QueryJobResponseBodyDataTargetConfig;
class QueryJobResponseBodyDataTimeoutConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            inProgressTimeoutInMinutes: 'InProgressTimeoutInMinutes',
        };
    }
    static types() {
        return {
            inProgressTimeoutInMinutes: 'number',
        };
    }
}
exports.QueryJobResponseBodyDataTimeoutConfig = QueryJobResponseBodyDataTimeoutConfig;
class QueryJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            jobDocument: 'JobDocument',
            jobFile: 'JobFile',
            jobId: 'JobId',
            jobName: 'JobName',
            rolloutConfig: 'RolloutConfig',
            scheduledTime: 'ScheduledTime',
            status: 'Status',
            targetConfig: 'TargetConfig',
            timeoutConfig: 'TimeoutConfig',
            type: 'Type',
            utcCreate: 'UtcCreate',
            utcModified: 'UtcModified',
        };
    }
    static types() {
        return {
            description: 'string',
            jobDocument: 'string',
            jobFile: QueryJobResponseBodyDataJobFile,
            jobId: 'string',
            jobName: 'string',
            rolloutConfig: QueryJobResponseBodyDataRolloutConfig,
            scheduledTime: 'number',
            status: 'string',
            targetConfig: QueryJobResponseBodyDataTargetConfig,
            timeoutConfig: QueryJobResponseBodyDataTimeoutConfig,
            type: 'string',
            utcCreate: 'string',
            utcModified: 'string',
        };
    }
}
exports.QueryJobResponseBodyData = QueryJobResponseBodyData;
class QueryJobStatisticsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cancelled: 'Cancelled',
            failed: 'Failed',
            inProgress: 'InProgress',
            queued: 'Queued',
            rejected: 'Rejected',
            sent: 'Sent',
            succeeded: 'Succeeded',
            timeOut: 'TimeOut',
            total: 'Total',
        };
    }
    static types() {
        return {
            cancelled: 'number',
            failed: 'number',
            inProgress: 'number',
            queued: 'number',
            rejected: 'number',
            sent: 'number',
            succeeded: 'number',
            timeOut: 'number',
            total: 'number',
        };
    }
}
exports.QueryJobStatisticsResponseBodyData = QueryJobStatisticsResponseBodyData;
class QueryLicenseDeviceListResponseBodyDataDeviceListItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            expiryTime: 'ExpiryTime',
            gmtCreate: 'GmtCreate',
            iotId: 'IotId',
            licenseCode: 'LicenseCode',
            productKey: 'ProductKey',
            productName: 'ProductName',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            expiryTime: 'number',
            gmtCreate: 'number',
            iotId: 'string',
            licenseCode: 'string',
            productKey: 'string',
            productName: 'string',
        };
    }
}
exports.QueryLicenseDeviceListResponseBodyDataDeviceListItem = QueryLicenseDeviceListResponseBodyDataDeviceListItem;
class QueryLicenseDeviceListResponseBodyDataDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': QueryLicenseDeviceListResponseBodyDataDeviceListItem },
        };
    }
}
exports.QueryLicenseDeviceListResponseBodyDataDeviceList = QueryLicenseDeviceListResponseBodyDataDeviceList;
class QueryLicenseDeviceListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceList: 'DeviceList',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            deviceList: QueryLicenseDeviceListResponseBodyDataDeviceList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryLicenseDeviceListResponseBodyData = QueryLicenseDeviceListResponseBodyData;
class QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classMode: 'ClassMode',
            enabled: 'Enabled',
            joinPermissionId: 'JoinPermissionId',
            joinPermissionName: 'JoinPermissionName',
            joinPermissionType: 'JoinPermissionType',
            ownerAliyunPk: 'OwnerAliyunPk',
        };
    }
    static types() {
        return {
            classMode: 'string',
            enabled: 'boolean',
            joinPermissionId: 'string',
            joinPermissionName: 'string',
            joinPermissionType: 'string',
            ownerAliyunPk: 'string',
        };
    }
}
exports.QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission = QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission;
class QueryLoRaJoinPermissionsResponseBodyJoinPermissions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            joinPermission: 'JoinPermission',
        };
    }
    static types() {
        return {
            joinPermission: { 'type': 'array', 'itemType': QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission },
        };
    }
}
exports.QueryLoRaJoinPermissionsResponseBodyJoinPermissions = QueryLoRaJoinPermissionsResponseBodyJoinPermissions;
class QueryMessageInfoResponseBodyMessageUserProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.QueryMessageInfoResponseBodyMessageUserProperties = QueryMessageInfoResponseBodyMessageUserProperties;
class QueryMessageInfoResponseBodyMessage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            generateTime: 'GenerateTime',
            messageContent: 'MessageContent',
            topicFullName: 'TopicFullName',
            uniMsgId: 'UniMsgId',
            userProperties: 'UserProperties',
        };
    }
    static types() {
        return {
            generateTime: 'number',
            messageContent: 'string',
            topicFullName: 'string',
            uniMsgId: 'string',
            userProperties: { 'type': 'array', 'itemType': QueryMessageInfoResponseBodyMessageUserProperties },
        };
    }
}
exports.QueryMessageInfoResponseBodyMessage = QueryMessageInfoResponseBodyMessage;
class QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileMd5: 'FileMd5',
            name: 'Name',
            signValue: 'SignValue',
            size: 'Size',
            url: 'Url',
        };
    }
    static types() {
        return {
            fileMd5: 'string',
            name: 'string',
            signValue: 'string',
            size: 'number',
            url: 'string',
        };
    }
}
exports.QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles = QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles;
class QueryOTAFirmwareResponseBodyFirmwareInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destVersion: 'DestVersion',
            firmwareDesc: 'FirmwareDesc',
            firmwareId: 'FirmwareId',
            firmwareName: 'FirmwareName',
            firmwareSign: 'FirmwareSign',
            firmwareSize: 'FirmwareSize',
            firmwareUrl: 'FirmwareUrl',
            moduleName: 'ModuleName',
            multiFiles: 'MultiFiles',
            productKey: 'ProductKey',
            productName: 'ProductName',
            signMethod: 'SignMethod',
            srcVersion: 'SrcVersion',
            status: 'Status',
            type: 'Type',
            udi: 'Udi',
            utcCreate: 'UtcCreate',
            utcModified: 'UtcModified',
            verifyProgress: 'VerifyProgress',
        };
    }
    static types() {
        return {
            destVersion: 'string',
            firmwareDesc: 'string',
            firmwareId: 'string',
            firmwareName: 'string',
            firmwareSign: 'string',
            firmwareSize: 'number',
            firmwareUrl: 'string',
            moduleName: 'string',
            multiFiles: { 'type': 'array', 'itemType': QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles },
            productKey: 'string',
            productName: 'string',
            signMethod: 'string',
            srcVersion: 'string',
            status: 'number',
            type: 'number',
            udi: 'string',
            utcCreate: 'string',
            utcModified: 'string',
            verifyProgress: 'number',
        };
    }
}
exports.QueryOTAFirmwareResponseBodyFirmwareInfo = QueryOTAFirmwareResponseBodyFirmwareInfo;
class QueryOTAJobResponseBodyDataSrcVersions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            srcVersion: 'SrcVersion',
        };
    }
    static types() {
        return {
            srcVersion: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryOTAJobResponseBodyDataSrcVersions = QueryOTAJobResponseBodyDataSrcVersions;
class QueryOTAJobResponseBodyDataTagsOtaTagDTO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.QueryOTAJobResponseBodyDataTagsOtaTagDTO = QueryOTAJobResponseBodyDataTagsOtaTagDTO;
class QueryOTAJobResponseBodyDataTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            otaTagDTO: 'OtaTagDTO',
        };
    }
    static types() {
        return {
            otaTagDTO: { 'type': 'array', 'itemType': QueryOTAJobResponseBodyDataTagsOtaTagDTO },
        };
    }
}
exports.QueryOTAJobResponseBodyDataTags = QueryOTAJobResponseBodyDataTags;
class QueryOTAJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destVersion: 'DestVersion',
            downloadProtocol: 'DownloadProtocol',
            dynamicMode: 'DynamicMode',
            firmwareId: 'FirmwareId',
            grayPercent: 'GrayPercent',
            groupId: 'GroupId',
            groupName: 'GroupName',
            jobDesc: 'JobDesc',
            jobId: 'JobId',
            jobStatus: 'JobStatus',
            jobType: 'JobType',
            maximumPerMinute: 'MaximumPerMinute',
            multiModuleMode: 'MultiModuleMode',
            name: 'Name',
            needConfirm: 'NeedConfirm',
            needPush: 'NeedPush',
            overwriteMode: 'OverwriteMode',
            productKey: 'ProductKey',
            retryCount: 'RetryCount',
            retryInterval: 'RetryInterval',
            selectionType: 'SelectionType',
            srcVersions: 'SrcVersions',
            tags: 'Tags',
            targetSelection: 'TargetSelection',
            timeoutInMinutes: 'TimeoutInMinutes',
            utcCreate: 'UtcCreate',
            utcEndTime: 'UtcEndTime',
            utcModified: 'UtcModified',
            utcScheduleFinishTime: 'UtcScheduleFinishTime',
            utcScheduleTime: 'UtcScheduleTime',
            utcStartTime: 'UtcStartTime',
        };
    }
    static types() {
        return {
            destVersion: 'string',
            downloadProtocol: 'string',
            dynamicMode: 'number',
            firmwareId: 'string',
            grayPercent: 'string',
            groupId: 'string',
            groupName: 'string',
            jobDesc: 'string',
            jobId: 'string',
            jobStatus: 'string',
            jobType: 'string',
            maximumPerMinute: 'number',
            multiModuleMode: 'boolean',
            name: 'string',
            needConfirm: 'boolean',
            needPush: 'boolean',
            overwriteMode: 'number',
            productKey: 'string',
            retryCount: 'number',
            retryInterval: 'number',
            selectionType: 'string',
            srcVersions: QueryOTAJobResponseBodyDataSrcVersions,
            tags: QueryOTAJobResponseBodyDataTags,
            targetSelection: 'string',
            timeoutInMinutes: 'number',
            utcCreate: 'string',
            utcEndTime: 'string',
            utcModified: 'string',
            utcScheduleFinishTime: 'string',
            utcScheduleTime: 'string',
            utcStartTime: 'string',
        };
    }
}
exports.QueryOTAJobResponseBodyData = QueryOTAJobResponseBodyData;
class QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceId: 'DeviceId',
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            iotId: 'IotId',
        };
    }
    static types() {
        return {
            deviceId: 'string',
            deviceName: 'string',
            deviceSecret: 'string',
            iotId: 'string',
        };
    }
}
exports.QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo = QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo;
class QueryPageByApplyIdResponseBodyApplyDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyDeviceInfo: 'ApplyDeviceInfo',
        };
    }
    static types() {
        return {
            applyDeviceInfo: { 'type': 'array', 'itemType': QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo },
        };
    }
}
exports.QueryPageByApplyIdResponseBodyApplyDeviceList = QueryPageByApplyIdResponseBodyApplyDeviceList;
class QueryProductResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliyunCommodityCode: 'AliyunCommodityCode',
            authType: 'AuthType',
            categoryKey: 'CategoryKey',
            categoryName: 'CategoryName',
            dataFormat: 'DataFormat',
            description: 'Description',
            deviceCount: 'DeviceCount',
            gmtCreate: 'GmtCreate',
            id2: 'Id2',
            netType: 'NetType',
            nodeType: 'NodeType',
            owner: 'Owner',
            productKey: 'ProductKey',
            productName: 'ProductName',
            productSecret: 'ProductSecret',
            productStatus: 'ProductStatus',
            protocolType: 'ProtocolType',
            validateType: 'ValidateType',
        };
    }
    static types() {
        return {
            aliyunCommodityCode: 'string',
            authType: 'string',
            categoryKey: 'string',
            categoryName: 'string',
            dataFormat: 'number',
            description: 'string',
            deviceCount: 'number',
            gmtCreate: 'number',
            id2: 'boolean',
            netType: 'number',
            nodeType: 'number',
            owner: 'boolean',
            productKey: 'string',
            productName: 'string',
            productSecret: 'string',
            productStatus: 'string',
            protocolType: 'string',
            validateType: 'number',
        };
    }
}
exports.QueryProductResponseBodyData = QueryProductResponseBodyData;
class QueryProductCertInfoResponseBodyProductCertInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            issueModel: 'IssueModel',
        };
    }
    static types() {
        return {
            issueModel: 'number',
        };
    }
}
exports.QueryProductCertInfoResponseBodyProductCertInfo = QueryProductCertInfoResponseBodyProductCertInfo;
class QueryProductListResponseBodyDataListProductInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authType: 'AuthType',
            dataFormat: 'DataFormat',
            description: 'Description',
            deviceCount: 'DeviceCount',
            gmtCreate: 'GmtCreate',
            nodeType: 'NodeType',
            productKey: 'ProductKey',
            productName: 'ProductName',
        };
    }
    static types() {
        return {
            authType: 'string',
            dataFormat: 'number',
            description: 'string',
            deviceCount: 'number',
            gmtCreate: 'number',
            nodeType: 'number',
            productKey: 'string',
            productName: 'string',
        };
    }
}
exports.QueryProductListResponseBodyDataListProductInfo = QueryProductListResponseBodyDataListProductInfo;
class QueryProductListResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            productInfo: 'ProductInfo',
        };
    }
    static types() {
        return {
            productInfo: { 'type': 'array', 'itemType': QueryProductListResponseBodyDataListProductInfo },
        };
    }
}
exports.QueryProductListResponseBodyDataList = QueryProductListResponseBodyDataList;
class QueryProductListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            list: 'List',
            pageCount: 'PageCount',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            list: QueryProductListResponseBodyDataList,
            pageCount: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryProductListResponseBodyData = QueryProductListResponseBodyData;
class QueryProductTopicResponseBodyDataProductTopicInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            codec: 'Codec',
            desc: 'Desc',
            enableProxySubscribe: 'EnableProxySubscribe',
            id: 'Id',
            operation: 'Operation',
            productKey: 'ProductKey',
            topicShortName: 'TopicShortName',
        };
    }
    static types() {
        return {
            codec: 'string',
            desc: 'string',
            enableProxySubscribe: 'boolean',
            id: 'string',
            operation: 'string',
            productKey: 'string',
            topicShortName: 'string',
        };
    }
}
exports.QueryProductTopicResponseBodyDataProductTopicInfo = QueryProductTopicResponseBodyDataProductTopicInfo;
class QueryProductTopicResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            productTopicInfo: 'ProductTopicInfo',
        };
    }
    static types() {
        return {
            productTopicInfo: { 'type': 'array', 'itemType': QueryProductTopicResponseBodyDataProductTopicInfo },
        };
    }
}
exports.QueryProductTopicResponseBodyData = QueryProductTopicResponseBodyData;
class QueryProjectShareDeviceListResponseBodyDataDeviceListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            productKey: 'ProductKey',
            sharable: 'Sharable',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            productKey: 'string',
            sharable: 'number',
        };
    }
}
exports.QueryProjectShareDeviceListResponseBodyDataDeviceListItems = QueryProjectShareDeviceListResponseBodyDataDeviceListItems;
class QueryProjectShareDeviceListResponseBodyDataDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QueryProjectShareDeviceListResponseBodyDataDeviceListItems },
        };
    }
}
exports.QueryProjectShareDeviceListResponseBodyDataDeviceList = QueryProjectShareDeviceListResponseBodyDataDeviceList;
class QueryProjectShareDeviceListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceList: 'DeviceList',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            deviceList: QueryProjectShareDeviceListResponseBodyDataDeviceList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryProjectShareDeviceListResponseBodyData = QueryProjectShareDeviceListResponseBodyData;
class QuerySceneRuleResponseBodyDataRuleList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            ruleDescription: 'RuleDescription',
            ruleId: 'RuleId',
            ruleName: 'RuleName',
            ruleStatus: 'RuleStatus',
        };
    }
    static types() {
        return {
            gmtCreate: 'number',
            gmtModified: 'number',
            ruleDescription: 'string',
            ruleId: 'string',
            ruleName: 'string',
            ruleStatus: 'number',
        };
    }
}
exports.QuerySceneRuleResponseBodyDataRuleList = QuerySceneRuleResponseBodyDataRuleList;
class QuerySceneRuleResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            pageSize: 'PageSize',
            ruleList: 'RuleList',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            pageSize: 'number',
            ruleList: { 'type': 'array', 'itemType': QuerySceneRuleResponseBodyDataRuleList },
            total: 'number',
        };
    }
}
exports.QuerySceneRuleResponseBodyData = QuerySceneRuleResponseBodyData;
class QuerySchedulePeriodListResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            endTime: 'EndTime',
            periodCode: 'PeriodCode',
            soundCodeContent: 'SoundCodeContent',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            description: 'string',
            endTime: 'string',
            periodCode: 'string',
            soundCodeContent: 'string',
            startTime: 'string',
        };
    }
}
exports.QuerySchedulePeriodListResponseBodyDataListItems = QuerySchedulePeriodListResponseBodyDataListItems;
class QuerySchedulePeriodListResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySchedulePeriodListResponseBodyDataListItems },
        };
    }
}
exports.QuerySchedulePeriodListResponseBodyDataList = QuerySchedulePeriodListResponseBodyDataList;
class QuerySchedulePeriodListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySchedulePeriodListResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySchedulePeriodListResponseBodyData = QuerySchedulePeriodListResponseBodyData;
class QueryShareTaskDeviceListResponseBodyDataDeviceListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            gmtAdded: 'GmtAdded',
            iotId: 'IotId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            gmtAdded: 'number',
            iotId: 'string',
            productKey: 'string',
        };
    }
}
exports.QueryShareTaskDeviceListResponseBodyDataDeviceListItems = QueryShareTaskDeviceListResponseBodyDataDeviceListItems;
class QueryShareTaskDeviceListResponseBodyDataDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QueryShareTaskDeviceListResponseBodyDataDeviceListItems },
        };
    }
}
exports.QueryShareTaskDeviceListResponseBodyDataDeviceList = QueryShareTaskDeviceListResponseBodyDataDeviceList;
class QueryShareTaskDeviceListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceList: 'DeviceList',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            deviceList: QueryShareTaskDeviceListResponseBodyDataDeviceList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QueryShareTaskDeviceListResponseBodyData = QueryShareTaskDeviceListResponseBodyData;
class QuerySolutionDeviceGroupPageResponseBodyDataListItemName extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceCount: 'DeviceCount',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            groupDesc: 'GroupDesc',
            groupId: 'GroupId',
            groupName: 'GroupName',
        };
    }
    static types() {
        return {
            deviceCount: 'number',
            gmtCreate: 'number',
            gmtModified: 'number',
            groupDesc: 'string',
            groupId: 'string',
            groupName: 'string',
        };
    }
}
exports.QuerySolutionDeviceGroupPageResponseBodyDataListItemName = QuerySolutionDeviceGroupPageResponseBodyDataListItemName;
class QuerySolutionDeviceGroupPageResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            itemName: 'itemName',
        };
    }
    static types() {
        return {
            itemName: { 'type': 'array', 'itemType': QuerySolutionDeviceGroupPageResponseBodyDataListItemName },
        };
    }
}
exports.QuerySolutionDeviceGroupPageResponseBodyDataList = QuerySolutionDeviceGroupPageResponseBodyDataList;
class QuerySolutionDeviceGroupPageResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySolutionDeviceGroupPageResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySolutionDeviceGroupPageResponseBodyData = QuerySolutionDeviceGroupPageResponseBodyData;
class QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorMessage: 'ErrorMessage',
            label: 'Label',
            resultCode: 'ResultCode',
        };
    }
    static types() {
        return {
            errorMessage: 'string',
            label: 'string',
            resultCode: 'string',
        };
    }
}
exports.QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems = QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems;
class QuerySoundCodeLabelBatchFailedResultResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems },
        };
    }
}
exports.QuerySoundCodeLabelBatchFailedResultResponseBodyData = QuerySoundCodeLabelBatchFailedResultResponseBodyData;
class QuerySoundCodeLabelBatchListResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            batchCode: 'BatchCode',
            description: 'Description',
            gmtCreate: 'GmtCreate',
            status: 'Status',
            successNum: 'SuccessNum',
            total: 'Total',
        };
    }
    static types() {
        return {
            batchCode: 'string',
            description: 'string',
            gmtCreate: 'number',
            status: 'string',
            successNum: 'number',
            total: 'number',
        };
    }
}
exports.QuerySoundCodeLabelBatchListResponseBodyDataListItems = QuerySoundCodeLabelBatchListResponseBodyDataListItems;
class QuerySoundCodeLabelBatchListResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySoundCodeLabelBatchListResponseBodyDataListItems },
        };
    }
}
exports.QuerySoundCodeLabelBatchListResponseBodyDataList = QuerySoundCodeLabelBatchListResponseBodyDataList;
class QuerySoundCodeLabelBatchListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySoundCodeLabelBatchListResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySoundCodeLabelBatchListResponseBodyData = QuerySoundCodeLabelBatchListResponseBodyData;
class QuerySoundCodeLabelListResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            label: 'Label',
            soundCode: 'SoundCode',
        };
    }
    static types() {
        return {
            label: 'string',
            soundCode: 'string',
        };
    }
}
exports.QuerySoundCodeLabelListResponseBodyDataListItems = QuerySoundCodeLabelListResponseBodyDataListItems;
class QuerySoundCodeLabelListResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySoundCodeLabelListResponseBodyDataListItems },
        };
    }
}
exports.QuerySoundCodeLabelListResponseBodyDataList = QuerySoundCodeLabelListResponseBodyDataList;
class QuerySoundCodeLabelListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySoundCodeLabelListResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySoundCodeLabelListResponseBodyData = QuerySoundCodeLabelListResponseBodyData;
class QuerySoundCodeListResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'Duration',
            gmtCreate: 'GmtCreate',
            name: 'Name',
            openType: 'OpenType',
            soundCode: 'SoundCode',
            soundCodeContent: 'SoundCodeContent',
        };
    }
    static types() {
        return {
            duration: 'number',
            gmtCreate: 'number',
            name: 'string',
            openType: 'string',
            soundCode: 'string',
            soundCodeContent: 'string',
        };
    }
}
exports.QuerySoundCodeListResponseBodyDataListItems = QuerySoundCodeListResponseBodyDataListItems;
class QuerySoundCodeListResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySoundCodeListResponseBodyDataListItems },
        };
    }
}
exports.QuerySoundCodeListResponseBodyDataList = QuerySoundCodeListResponseBodyDataList;
class QuerySoundCodeListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySoundCodeListResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySoundCodeListResponseBodyData = QuerySoundCodeListResponseBodyData;
class QuerySoundCodeScheduleListResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            endDate: 'EndDate',
            endTime: 'EndTime',
            gmtCreate: 'GmtCreate',
            name: 'Name',
            openType: 'OpenType',
            scheduleCode: 'ScheduleCode',
            startDate: 'StartDate',
            startTime: 'StartTime',
            status: 'Status',
        };
    }
    static types() {
        return {
            description: 'string',
            endDate: 'string',
            endTime: 'string',
            gmtCreate: 'number',
            name: 'string',
            openType: 'string',
            scheduleCode: 'string',
            startDate: 'string',
            startTime: 'string',
            status: 'string',
        };
    }
}
exports.QuerySoundCodeScheduleListResponseBodyDataListItems = QuerySoundCodeScheduleListResponseBodyDataListItems;
class QuerySoundCodeScheduleListResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySoundCodeScheduleListResponseBodyDataListItems },
        };
    }
}
exports.QuerySoundCodeScheduleListResponseBodyDataList = QuerySoundCodeScheduleListResponseBodyDataList;
class QuerySoundCodeScheduleListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySoundCodeScheduleListResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySoundCodeScheduleListResponseBodyData = QuerySoundCodeScheduleListResponseBodyData;
class QuerySpeechResponseBodyDataSoundCodeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            additionalDuration: 'AdditionalDuration',
            soundCodeContent: 'SoundCodeContent',
        };
    }
    static types() {
        return {
            additionalDuration: 'number',
            soundCodeContent: 'string',
        };
    }
}
exports.QuerySpeechResponseBodyDataSoundCodeConfig = QuerySpeechResponseBodyDataSoundCodeConfig;
class QuerySpeechResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            bizCode: 'BizCode',
            enableSoundCode: 'EnableSoundCode',
            soundCodeConfig: 'SoundCodeConfig',
            speechCode: 'SpeechCode',
            speechRate: 'SpeechRate',
            speechType: 'SpeechType',
            text: 'Text',
            voice: 'Voice',
            volume: 'Volume',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            bizCode: 'string',
            enableSoundCode: 'boolean',
            soundCodeConfig: QuerySpeechResponseBodyDataSoundCodeConfig,
            speechCode: 'string',
            speechRate: 'number',
            speechType: 'string',
            text: 'string',
            voice: 'string',
            volume: 'number',
        };
    }
}
exports.QuerySpeechResponseBodyData = QuerySpeechResponseBodyData;
class QuerySpeechDeviceResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableSpace: 'AvailableSpace',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            availableSpace: 'number',
            deviceName: 'string',
            iotId: 'string',
            productKey: 'string',
        };
    }
}
exports.QuerySpeechDeviceResponseBodyDataListItems = QuerySpeechDeviceResponseBodyDataListItems;
class QuerySpeechDeviceResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySpeechDeviceResponseBodyDataListItems },
        };
    }
}
exports.QuerySpeechDeviceResponseBodyDataList = QuerySpeechDeviceResponseBodyDataList;
class QuerySpeechDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySpeechDeviceResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySpeechDeviceResponseBodyData = QuerySpeechDeviceResponseBodyData;
class QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            deviceStatus: 'DeviceStatus',
            expiryTime: 'ExpiryTime',
            inSpecifiedGroup: 'InSpecifiedGroup',
            iotId: 'IotId',
            licenseStatus: 'LicenseStatus',
            productKey: 'ProductKey',
            productName: 'ProductName',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            deviceStatus: 'string',
            expiryTime: 'number',
            inSpecifiedGroup: 'boolean',
            iotId: 'string',
            licenseStatus: 'string',
            productKey: 'string',
            productName: 'string',
        };
    }
}
exports.QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem = QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem;
class QuerySpeechLicenseDeviceListResponseBodyDataDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem },
        };
    }
}
exports.QuerySpeechLicenseDeviceListResponseBodyDataDeviceList = QuerySpeechLicenseDeviceListResponseBodyDataDeviceList;
class QuerySpeechLicenseDeviceListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceList: 'DeviceList',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            deviceList: QuerySpeechLicenseDeviceListResponseBodyDataDeviceList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySpeechLicenseDeviceListResponseBodyData = QuerySpeechLicenseDeviceListResponseBodyData;
class QuerySpeechListResponseBodyDataListItemsSpeechListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'BizCode',
            speechCode: 'SpeechCode',
            text: 'Text',
            voice: 'Voice',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            speechCode: 'string',
            text: 'string',
            voice: 'string',
        };
    }
}
exports.QuerySpeechListResponseBodyDataListItemsSpeechListItems = QuerySpeechListResponseBodyDataListItemsSpeechListItems;
class QuerySpeechListResponseBodyDataListItemsSpeechList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySpeechListResponseBodyDataListItemsSpeechListItems },
        };
    }
}
exports.QuerySpeechListResponseBodyDataListItemsSpeechList = QuerySpeechListResponseBodyDataListItemsSpeechList;
class QuerySpeechListResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioFormat: 'AudioFormat',
            bizCode: 'BizCode',
            speechCode: 'SpeechCode',
            speechList: 'SpeechList',
            speechType: 'SpeechType',
            text: 'Text',
            voice: 'Voice',
        };
    }
    static types() {
        return {
            audioFormat: 'string',
            bizCode: 'string',
            speechCode: 'string',
            speechList: QuerySpeechListResponseBodyDataListItemsSpeechList,
            speechType: 'string',
            text: 'string',
            voice: 'string',
        };
    }
}
exports.QuerySpeechListResponseBodyDataListItems = QuerySpeechListResponseBodyDataListItems;
class QuerySpeechListResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySpeechListResponseBodyDataListItems },
        };
    }
}
exports.QuerySpeechListResponseBodyDataList = QuerySpeechListResponseBodyDataList;
class QuerySpeechListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySpeechListResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySpeechListResponseBodyData = QuerySpeechListResponseBodyData;
class QuerySpeechPushJobResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            createdTime: 'CreatedTime',
            deviceName: 'DeviceName',
            expiredTime: 'ExpiredTime',
            failDeviceNum: 'FailDeviceNum',
            groupId: 'GroupId',
            groupName: 'GroupName',
            iotId: 'IotId',
            productKey: 'ProductKey',
            pushMode: 'PushMode',
            runningDeviceNum: 'RunningDeviceNum',
            speechNum: 'SpeechNum',
            speechStatus: 'SpeechStatus',
            status: 'Status',
            successDeviceNum: 'SuccessDeviceNum',
            totalDeviceNum: 'TotalDeviceNum',
        };
    }
    static types() {
        return {
            code: 'string',
            createdTime: 'number',
            deviceName: 'string',
            expiredTime: 'number',
            failDeviceNum: 'number',
            groupId: 'string',
            groupName: 'string',
            iotId: 'string',
            productKey: 'string',
            pushMode: 'string',
            runningDeviceNum: 'number',
            speechNum: 'number',
            speechStatus: 'boolean',
            status: 'string',
            successDeviceNum: 'number',
            totalDeviceNum: 'number',
        };
    }
}
exports.QuerySpeechPushJobResponseBodyDataListItems = QuerySpeechPushJobResponseBodyDataListItems;
class QuerySpeechPushJobResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySpeechPushJobResponseBodyDataListItems },
        };
    }
}
exports.QuerySpeechPushJobResponseBodyDataList = QuerySpeechPushJobResponseBodyDataList;
class QuerySpeechPushJobResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySpeechPushJobResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySpeechPushJobResponseBodyData = QuerySpeechPushJobResponseBodyData;
class QuerySpeechPushJobDeviceResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            errorCode: 'ErrorCode',
            errorMessage: 'ErrorMessage',
            gmtModified: 'GmtModified',
            status: 'Status',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            errorCode: 'string',
            errorMessage: 'string',
            gmtModified: 'number',
            status: 'string',
        };
    }
}
exports.QuerySpeechPushJobDeviceResponseBodyDataListItems = QuerySpeechPushJobDeviceResponseBodyDataListItems;
class QuerySpeechPushJobDeviceResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySpeechPushJobDeviceResponseBodyDataListItems },
        };
    }
}
exports.QuerySpeechPushJobDeviceResponseBodyDataList = QuerySpeechPushJobDeviceResponseBodyDataList;
class QuerySpeechPushJobDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySpeechPushJobDeviceResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySpeechPushJobDeviceResponseBodyData = QuerySpeechPushJobDeviceResponseBodyData;
class QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'BizCode',
            text: 'Text',
            voice: 'Voice',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            text: 'string',
            voice: 'string',
        };
    }
}
exports.QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems = QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems;
class QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems },
        };
    }
}
exports.QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList = QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList;
class QuerySpeechPushJobSpeechResponseBodyDataListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'BizCode',
            speechList: 'SpeechList',
            speechType: 'SpeechType',
            text: 'Text',
            voice: 'Voice',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            speechList: QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList,
            speechType: 'string',
            text: 'string',
            voice: 'string',
        };
    }
}
exports.QuerySpeechPushJobSpeechResponseBodyDataListItems = QuerySpeechPushJobSpeechResponseBodyDataListItems;
class QuerySpeechPushJobSpeechResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySpeechPushJobSpeechResponseBodyDataListItems },
        };
    }
}
exports.QuerySpeechPushJobSpeechResponseBodyDataList = QuerySpeechPushJobSpeechResponseBodyDataList;
class QuerySpeechPushJobSpeechResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageId: 'PageId',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            list: QuerySpeechPushJobSpeechResponseBodyDataList,
            pageId: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySpeechPushJobSpeechResponseBodyData = QuerySpeechPushJobSpeechResponseBodyData;
class QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            host: 'Host',
            id: 'Id',
            isBeian: 'IsBeian',
            projectId: 'ProjectId',
            protocol: 'Protocol',
            tenantId: 'TenantId',
        };
    }
    static types() {
        return {
            appId: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            host: 'string',
            id: 'number',
            isBeian: 'string',
            projectId: 'string',
            protocol: 'string',
            tenantId: 'string',
        };
    }
}
exports.QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo = QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo;
class QueryStudioAppDomainListOpenResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            domainInfo: 'DomainInfo',
        };
    }
    static types() {
        return {
            domainInfo: { 'type': 'array', 'itemType': QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo },
        };
    }
}
exports.QueryStudioAppDomainListOpenResponseBodyDataList = QueryStudioAppDomainListOpenResponseBodyDataList;
class QueryStudioAppDomainListOpenResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            total: 'Total',
            totalPage: 'TotalPage',
        };
    }
    static types() {
        return {
            list: QueryStudioAppDomainListOpenResponseBodyDataList,
            pageNo: 'number',
            pageSize: 'number',
            total: 'number',
            totalPage: 'number',
        };
    }
}
exports.QueryStudioAppDomainListOpenResponseBodyData = QueryStudioAppDomainListOpenResponseBodyData;
class QueryStudioAppListResponseBodyDataListAppInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'AppId',
            appKey: 'AppKey',
            appSecret: 'AppSecret',
            description: 'Description',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            gmtRelease: 'GmtRelease',
            name: 'Name',
            projectId: 'ProjectId',
            type: 'Type',
        };
    }
    static types() {
        return {
            appId: 'string',
            appKey: 'string',
            appSecret: 'string',
            description: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            gmtRelease: 'string',
            name: 'string',
            projectId: 'string',
            type: 'string',
        };
    }
}
exports.QueryStudioAppListResponseBodyDataListAppInfo = QueryStudioAppListResponseBodyDataListAppInfo;
class QueryStudioAppListResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appInfo: 'AppInfo',
        };
    }
    static types() {
        return {
            appInfo: { 'type': 'array', 'itemType': QueryStudioAppListResponseBodyDataListAppInfo },
        };
    }
}
exports.QueryStudioAppListResponseBodyDataList = QueryStudioAppListResponseBodyDataList;
class QueryStudioAppListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            total: 'Total',
            totalPage: 'TotalPage',
        };
    }
    static types() {
        return {
            list: QueryStudioAppListResponseBodyDataList,
            pageNo: 'number',
            pageSize: 'number',
            total: 'number',
            totalPage: 'number',
        };
    }
}
exports.QueryStudioAppListResponseBodyData = QueryStudioAppListResponseBodyData;
class QueryStudioAppPageListOpenResponseBodyDataListPageInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            id: 'Id',
            isHidden: 'IsHidden',
            isHome: 'IsHome',
            isLoginPage: 'IsLoginPage',
            name: 'Name',
            pageId: 'PageId',
            path: 'Path',
        };
    }
    static types() {
        return {
            gmtCreate: 'string',
            gmtModified: 'string',
            id: 'number',
            isHidden: 'number',
            isHome: 'number',
            isLoginPage: 'number',
            name: 'string',
            pageId: 'string',
            path: 'string',
        };
    }
}
exports.QueryStudioAppPageListOpenResponseBodyDataListPageInfo = QueryStudioAppPageListOpenResponseBodyDataListPageInfo;
class QueryStudioAppPageListOpenResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageInfo: 'PageInfo',
        };
    }
    static types() {
        return {
            pageInfo: { 'type': 'array', 'itemType': QueryStudioAppPageListOpenResponseBodyDataListPageInfo },
        };
    }
}
exports.QueryStudioAppPageListOpenResponseBodyDataList = QueryStudioAppPageListOpenResponseBodyDataList;
class QueryStudioAppPageListOpenResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            total: 'Total',
            totalPage: 'TotalPage',
        };
    }
    static types() {
        return {
            list: QueryStudioAppPageListOpenResponseBodyDataList,
            pageNo: 'number',
            pageSize: 'number',
            total: 'number',
            totalPage: 'number',
        };
    }
}
exports.QueryStudioAppPageListOpenResponseBodyData = QueryStudioAppPageListOpenResponseBodyData;
class QueryStudioProjectListResponseBodyDataListProjectInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            name: 'Name',
            projectId: 'ProjectId',
        };
    }
    static types() {
        return {
            description: 'string',
            gmtCreate: 'number',
            gmtModified: 'number',
            name: 'string',
            projectId: 'string',
        };
    }
}
exports.QueryStudioProjectListResponseBodyDataListProjectInfo = QueryStudioProjectListResponseBodyDataListProjectInfo;
class QueryStudioProjectListResponseBodyDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            projectInfo: 'ProjectInfo',
        };
    }
    static types() {
        return {
            projectInfo: { 'type': 'array', 'itemType': QueryStudioProjectListResponseBodyDataListProjectInfo },
        };
    }
}
exports.QueryStudioProjectListResponseBodyDataList = QueryStudioProjectListResponseBodyDataList;
class QueryStudioProjectListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'List',
            pageNo: 'PageNo',
            pageSize: 'PageSize',
            total: 'Total',
            totalPage: 'TotalPage',
        };
    }
    static types() {
        return {
            list: QueryStudioProjectListResponseBodyDataList,
            pageNo: 'number',
            pageSize: 'number',
            total: 'number',
            totalPage: 'number',
        };
    }
}
exports.QueryStudioProjectListResponseBodyData = QueryStudioProjectListResponseBodyData;
class QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            logTime: 'LogTime',
            result: 'Result',
            traceId: 'TraceId',
        };
    }
    static types() {
        return {
            logTime: 'number',
            result: 'string',
            traceId: 'string',
        };
    }
}
exports.QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo = QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo;
class QuerySummarySceneRuleLogResponseBodyDataLogList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            logInfo: 'LogInfo',
        };
    }
    static types() {
        return {
            logInfo: { 'type': 'array', 'itemType': QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo },
        };
    }
}
exports.QuerySummarySceneRuleLogResponseBodyDataLogList = QuerySummarySceneRuleLogResponseBodyDataLogList;
class QuerySummarySceneRuleLogResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentPage: 'CurrentPage',
            logList: 'LogList',
            pageSize: 'PageSize',
            total: 'Total',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            logList: QuerySummarySceneRuleLogResponseBodyDataLogList,
            pageSize: 'number',
            total: 'number',
        };
    }
}
exports.QuerySummarySceneRuleLogResponseBodyData = QuerySummarySceneRuleLogResponseBodyData;
class QuerySuperDeviceGroupResponseBodyDataGroupInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupDesc: 'GroupDesc',
            groupId: 'GroupId',
            groupName: 'GroupName',
        };
    }
    static types() {
        return {
            groupDesc: 'string',
            groupId: 'string',
            groupName: 'string',
        };
    }
}
exports.QuerySuperDeviceGroupResponseBodyDataGroupInfo = QuerySuperDeviceGroupResponseBodyDataGroupInfo;
class QuerySuperDeviceGroupResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupInfo: 'GroupInfo',
        };
    }
    static types() {
        return {
            groupInfo: { 'type': 'array', 'itemType': QuerySuperDeviceGroupResponseBodyDataGroupInfo },
        };
    }
}
exports.QuerySuperDeviceGroupResponseBodyData = QuerySuperDeviceGroupResponseBodyData;
class QueryTaskResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'DeviceName',
            iotId: 'IotId',
            jobId: 'JobId',
            jobName: 'JobName',
            message: 'Message',
            productKey: 'ProductKey',
            progress: 'Progress',
            status: 'Status',
            statusDetail: 'StatusDetail',
            taskId: 'TaskId',
            utcModified: 'UtcModified',
            utcQueueTime: 'UtcQueueTime',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            iotId: 'string',
            jobId: 'string',
            jobName: 'string',
            message: 'string',
            productKey: 'string',
            progress: 'string',
            status: 'string',
            statusDetail: 'string',
            taskId: 'string',
            utcModified: 'string',
            utcQueueTime: 'string',
        };
    }
}
exports.QueryTaskResponseBodyData = QueryTaskResponseBodyData;
class QueryThingModelResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            thingModelJson: 'ThingModelJson',
        };
    }
    static types() {
        return {
            thingModelJson: 'string',
        };
    }
}
exports.QueryThingModelResponseBodyData = QueryThingModelResponseBodyData;
class QueryThingModelExtendConfigResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
        };
    }
    static types() {
        return {
            configuration: 'string',
        };
    }
}
exports.QueryThingModelExtendConfigResponseBodyData = QueryThingModelExtendConfigResponseBodyData;
class QueryThingModelExtendConfigPublishedResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configuration: 'Configuration',
        };
    }
    static types() {
        return {
            configuration: 'string',
        };
    }
}
exports.QueryThingModelExtendConfigPublishedResponseBodyData = QueryThingModelExtendConfigPublishedResponseBodyData;
class QueryThingModelPublishedResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            thingModelJson: 'ThingModelJson',
        };
    }
    static types() {
        return {
            thingModelJson: 'string',
        };
    }
}
exports.QueryThingModelPublishedResponseBodyData = QueryThingModelPublishedResponseBodyData;
class QueryTopicConfigResponseBodyDataTopicConfigInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            codec: 'Codec',
            description: 'Description',
            enableBroadcast: 'EnableBroadcast',
            enableProxySubscribe: 'EnableProxySubscribe',
            operation: 'Operation',
            productKey: 'ProductKey',
            topicFullName: 'TopicFullName',
        };
    }
    static types() {
        return {
            codec: 'string',
            description: 'string',
            enableBroadcast: 'boolean',
            enableProxySubscribe: 'boolean',
            operation: 'string',
            productKey: 'string',
            topicFullName: 'string',
        };
    }
}
exports.QueryTopicConfigResponseBodyDataTopicConfigInfo = QueryTopicConfigResponseBodyDataTopicConfigInfo;
class QueryTopicConfigResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            topicConfigInfo: 'TopicConfigInfo',
        };
    }
    static types() {
        return {
            topicConfigInfo: { 'type': 'array', 'itemType': QueryTopicConfigResponseBodyDataTopicConfigInfo },
        };
    }
}
exports.QueryTopicConfigResponseBodyData = QueryTopicConfigResponseBodyData;
class QueryTopicReverseRouteTableResponseBodySrcTopics extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            topic: 'Topic',
        };
    }
    static types() {
        return {
            topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
}
exports.QueryTopicReverseRouteTableResponseBodySrcTopics = QueryTopicReverseRouteTableResponseBodySrcTopics;
class QueryTopicRouteTableResponseBodyDstTopics extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            topic: 'Topic',
        };
    }
    static types() {
        return {
            topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
}
exports.QueryTopicRouteTableResponseBodyDstTopics = QueryTopicRouteTableResponseBodyDstTopics;
class QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authCode: 'AuthCode',
            city: 'City',
            deviceId: 'DeviceId',
            deviceModel: 'DeviceModel',
            manufacturer: 'Manufacturer',
            province: 'Province',
            registerTime: 'RegisterTime',
            status: 'Status',
            vehicleColour: 'VehicleColour',
            vehicleNumber: 'VehicleNumber',
        };
    }
    static types() {
        return {
            authCode: 'string',
            city: 'string',
            deviceId: 'string',
            deviceModel: 'string',
            manufacturer: 'string',
            province: 'string',
            registerTime: 'string',
            status: 'string',
            vehicleColour: 'string',
            vehicleNumber: 'string',
        };
    }
}
exports.QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData = QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData;
class QueryVehicleDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'CreateTime',
            deviceName: 'DeviceName',
            iotId: 'IotId',
            jtProtocolDeviceData: 'JtProtocolDeviceData',
            modifiedTime: 'ModifiedTime',
            productKey: 'ProductKey',
            protocol: 'Protocol',
        };
    }
    static types() {
        return {
            createTime: 'number',
            deviceName: 'string',
            iotId: 'string',
            jtProtocolDeviceData: QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData,
            modifiedTime: 'number',
            productKey: 'string',
            protocol: 'string',
        };
    }
}
exports.QueryVehicleDeviceResponseBodyData = QueryVehicleDeviceResponseBodyData;
class ReBindLicenseDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkProgressId: 'CheckProgressId',
            failSum: 'FailSum',
            progress: 'Progress',
            resultCsvFile: 'ResultCsvFile',
            successSum: 'SuccessSum',
        };
    }
    static types() {
        return {
            checkProgressId: 'string',
            failSum: 'number',
            progress: 'number',
            resultCsvFile: 'string',
            successSum: 'number',
        };
    }
}
exports.ReBindLicenseDeviceResponseBodyData = ReBindLicenseDeviceResponseBodyData;
class RefreshStudioAppTokenOpenResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizId: 'BizId',
            bizType: 'BizType',
            isEnable: 'IsEnable',
            token: 'Token',
            type: 'Type',
        };
    }
    static types() {
        return {
            bizId: 'string',
            bizType: 'string',
            isEnable: 'string',
            token: 'string',
            type: 'string',
        };
    }
}
exports.RefreshStudioAppTokenOpenResponseBodyData = RefreshStudioAppTokenOpenResponseBodyData;
class RegisterDeviceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            devEui: 'DevEui',
            deviceName: 'DeviceName',
            deviceSecret: 'DeviceSecret',
            iotId: 'IotId',
            joinEui: 'JoinEui',
            nickname: 'Nickname',
            productKey: 'ProductKey',
        };
    }
    static types() {
        return {
            devEui: 'string',
            deviceName: 'string',
            deviceSecret: 'string',
            iotId: 'string',
            joinEui: 'string',
            nickname: 'string',
            productKey: 'string',
        };
    }
}
exports.RegisterDeviceResponseBodyData = RegisterDeviceResponseBodyData;
class SetDeviceDesiredPropertyResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageId: 'MessageId',
            versions: 'Versions',
        };
    }
    static types() {
        return {
            messageId: 'string',
            versions: 'string',
        };
    }
}
exports.SetDeviceDesiredPropertyResponseBodyData = SetDeviceDesiredPropertyResponseBodyData;
class SetDevicePropertyResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageId: 'MessageId',
        };
    }
    static types() {
        return {
            messageId: 'string',
        };
    }
}
exports.SetDevicePropertyResponseBodyData = SetDevicePropertyResponseBodyData;
class SetEdgeInstanceDriverConfigsRequestConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'Content',
            format: 'Format',
            key: 'Key',
        };
    }
    static types() {
        return {
            content: 'string',
            format: 'string',
            key: 'string',
        };
    }
}
exports.SetEdgeInstanceDriverConfigsRequestConfigs = SetEdgeInstanceDriverConfigsRequestConfigs;
class SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizId: 'BizId',
            bizType: 'BizType',
            isEnable: 'IsEnable',
            token: 'Token',
            type: 'Type',
        };
    }
    static types() {
        return {
            bizId: 'string',
            bizType: 'string',
            isEnable: 'string',
            token: 'string',
            type: 'string',
        };
    }
}
exports.SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo = SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo;
class SetupStudioAppAuthModeOpenResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authMode: 'AuthMode',
            tokenInfo: 'TokenInfo',
        };
    }
    static types() {
        return {
            authMode: 'number',
            tokenInfo: SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo,
        };
    }
}
exports.SetupStudioAppAuthModeOpenResponseBodyData = SetupStudioAppAuthModeOpenResponseBodyData;
class SyncSpeechByCombinationResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            detail: 'Detail',
            deviceErrorCode: 'DeviceErrorCode',
            deviceErrorMessage: 'DeviceErrorMessage',
            id: 'Id',
            maxRetryCount: 'MaxRetryCount',
            retryCount: 'RetryCount',
            success: 'Success',
        };
    }
    static types() {
        return {
            detail: 'string',
            deviceErrorCode: 'string',
            deviceErrorMessage: 'string',
            id: 'string',
            maxRetryCount: 'number',
            retryCount: 'number',
            success: 'boolean',
        };
    }
}
exports.SyncSpeechByCombinationResponseBodyData = SyncSpeechByCombinationResponseBodyData;
class TestSpeechResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.TestSpeechResponseBodyData = TestSpeechResponseBodyData;
class UpdateEdgeInstanceChannelRequestConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'Content',
            format: 'Format',
            key: 'Key',
        };
    }
    static types() {
        return {
            content: 'string',
            format: 'string',
            key: 'string',
        };
    }
}
exports.UpdateEdgeInstanceChannelRequestConfigs = UpdateEdgeInstanceChannelRequestConfigs;
class UpdateProductTagsRequestProductTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.UpdateProductTagsRequestProductTag = UpdateProductTagsRequestProductTag;
class UpdateProductTagsResponseBodyInvalidProductTagsProductTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.UpdateProductTagsResponseBodyInvalidProductTagsProductTag = UpdateProductTagsResponseBodyInvalidProductTagsProductTag;
class UpdateProductTagsResponseBodyInvalidProductTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            productTag: 'ProductTag',
        };
    }
    static types() {
        return {
            productTag: { 'type': 'array', 'itemType': UpdateProductTagsResponseBodyInvalidProductTagsProductTag },
        };
    }
}
exports.UpdateProductTagsResponseBodyInvalidProductTags = UpdateProductTagsResponseBodyInvalidProductTags;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "regional";
        this._endpointMap = {
            'ap-northeast-2-pop': "iot.aliyuncs.com",
            'ap-south-1': "iot.aliyuncs.com",
            'ap-southeast-2': "iot.aliyuncs.com",
            'ap-southeast-3': "iot.aliyuncs.com",
            'ap-southeast-5': "iot.aliyuncs.com",
            'cn-beijing-finance-1': "iot.aliyuncs.com",
            'cn-beijing-finance-pop': "iot.aliyuncs.com",
            'cn-beijing-gov-1': "iot.aliyuncs.com",
            'cn-beijing-nu16-b01': "iot.aliyuncs.com",
            'cn-chengdu': "iot.aliyuncs.com",
            'cn-edge-1': "iot.aliyuncs.com",
            'cn-fujian': "iot.aliyuncs.com",
            'cn-haidian-cm12-c01': "iot.aliyuncs.com",
            'cn-hangzhou-bj-b01': "iot.aliyuncs.com",
            'cn-hangzhou-finance': "iot.aliyuncs.com",
            'cn-hangzhou-internal-prod-1': "iot.aliyuncs.com",
            'cn-hangzhou-internal-test-1': "iot.aliyuncs.com",
            'cn-hangzhou-internal-test-2': "iot.aliyuncs.com",
            'cn-hangzhou-internal-test-3': "iot.aliyuncs.com",
            'cn-hangzhou-test-306': "iot.aliyuncs.com",
            'cn-hongkong': "iot.aliyuncs.com",
            'cn-hongkong-finance-pop': "iot.aliyuncs.com",
            'cn-huhehaote': "iot.aliyuncs.com",
            'cn-huhehaote-nebula-1': "iot.aliyuncs.com",
            'cn-qingdao': "iot.aliyuncs.com",
            'cn-qingdao-nebula': "iot.aliyuncs.com",
            'cn-shanghai-et15-b01': "iot.aliyuncs.com",
            'cn-shanghai-et2-b01': "iot.aliyuncs.com",
            'cn-shanghai-finance-1': "iot.aliyuncs.com",
            'cn-shanghai-inner': "iot.aliyuncs.com",
            'cn-shanghai-internal-test-1': "iot.aliyuncs.com",
            'cn-shenzhen-finance-1': "iot.aliyuncs.com",
            'cn-shenzhen-inner': "iot.aliyuncs.com",
            'cn-shenzhen-st4-d01': "iot.aliyuncs.com",
            'cn-shenzhen-su18-b01': "iot.aliyuncs.com",
            'cn-wuhan': "iot.aliyuncs.com",
            'cn-wulanchabu': "iot.aliyuncs.com",
            'cn-yushanfang': "iot.aliyuncs.com",
            'cn-zhangbei': "iot.aliyuncs.com",
            'cn-zhangbei-na61-b01': "iot.aliyuncs.com",
            'cn-zhangjiakou': "iot.aliyuncs.com",
            'cn-zhangjiakou-na62-a01': "iot.aliyuncs.com",
            'cn-zhengzhou-nebula-1': "iot.aliyuncs.com",
            'eu-west-1': "iot.aliyuncs.com",
            'eu-west-1-oxs': "iot.aliyuncs.com",
            'me-east-1': "iot.aliyuncs.com",
            'rus-west-1-pop': "iot.aliyuncs.com",
        };
        this.checkConfig(config);
        this._endpoint = this.getEndpoint("iot", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!tea_util_1.default.empty(endpoint)) {
            return endpoint;
        }
        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    async addDataForApiSourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.apiId)) {
            query["ApiId"] = request.apiId;
        }
        if (!tea_util_1.default.isUnset(request.content)) {
            query["Content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "AddDataForApiSource",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AddDataForApiSourceResponse({}));
    }
    async addDataForApiSource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.addDataForApiSourceWithOptions(request, runtime);
    }
    async addShareTaskDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotIdList)) {
            body["IotIdList"] = request.iotIdList;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.shareTaskId)) {
            body["ShareTaskId"] = request.shareTaskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddShareTaskDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AddShareTaskDeviceResponse({}));
    }
    async addShareTaskDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.addShareTaskDeviceWithOptions(request, runtime);
    }
    async asyncRRpcWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.extInfo)) {
            query["ExtInfo"] = request.extInfo;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.topicFullName)) {
            query["TopicFullName"] = request.topicFullName;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.messageContent)) {
            body["MessageContent"] = request.messageContent;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AsyncRRpc",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AsyncRRpcResponse({}));
    }
    async asyncRRpc(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.asyncRRpcWithOptions(request, runtime);
    }
    async attachDestinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.destinationId)) {
            query["DestinationId"] = request.destinationId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.isFailover)) {
            query["IsFailover"] = request.isFailover;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "AttachDestination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AttachDestinationResponse({}));
    }
    async attachDestination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.attachDestinationWithOptions(request, runtime);
    }
    async attachParserDataSourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dataSourceId)) {
            query["DataSourceId"] = request.dataSourceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "AttachParserDataSource",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AttachParserDataSourceResponse({}));
    }
    async attachParserDataSource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.attachParserDataSourceWithOptions(request, runtime);
    }
    async batchAddDataForApiSourceWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new BatchAddDataForApiSourceShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.contentList)) {
            request.contentListShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.contentList, "ContentList", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.apiId)) {
            query["ApiId"] = request.apiId;
        }
        if (!tea_util_1.default.isUnset(request.contentListShrink)) {
            query["ContentList"] = request.contentListShrink;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchAddDataForApiSource",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchAddDataForApiSourceResponse({}));
    }
    async batchAddDataForApiSource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchAddDataForApiSourceWithOptions(request, runtime);
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
      *
      * @param request BatchAddDeviceGroupRelationsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchAddDeviceGroupRelationsResponse
     */
    async batchAddDeviceGroupRelationsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.device)) {
            query["Device"] = request.device;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchAddDeviceGroupRelations",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchAddDeviceGroupRelationsResponse({}));
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
      *
      * @param request BatchAddDeviceGroupRelationsRequest
      * @return BatchAddDeviceGroupRelationsResponse
     */
    async batchAddDeviceGroupRelations(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchAddDeviceGroupRelationsWithOptions(request, runtime);
    }
    /**
      * *   You can attach up to 10 sub-devices to a gateway in a single call.
      * *   The API operation caller must be the gateway owner.
      * *   If you specify a sub-device that is already attached to a gateway, the original gateway is replaced with the specified gateway.
      * *   If one of the specified sub-devices fails to establish a topological relationship with the gateway, the system rolls back, and all specified sub-devices fail to establish topological relationships with the gateway.
      * *   After you call this operation to establish topological relationships between sub-devices and the gateway, IoT Platform uses the `/sys/${productKey}/${deviceName}/thing/topo/change` topic to push information that includes the result of this operation to the gateway. For more information, see [Notify gateways of changes of topological relationships](~~89299~~).
      * ## QPS limits
      * You can call this API operation up to 10 times per second per Alibaba Cloud account.
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchAddThingTopoRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchAddThingTopoResponse
     */
    async batchAddThingTopoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.gwDeviceName)) {
            query["GwDeviceName"] = request.gwDeviceName;
        }
        if (!tea_util_1.default.isUnset(request.gwProductKey)) {
            query["GwProductKey"] = request.gwProductKey;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.topoAddItem)) {
            query["TopoAddItem"] = request.topoAddItem;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchAddThingTopo",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchAddThingTopoResponse({}));
    }
    /**
      * *   You can attach up to 10 sub-devices to a gateway in a single call.
      * *   The API operation caller must be the gateway owner.
      * *   If you specify a sub-device that is already attached to a gateway, the original gateway is replaced with the specified gateway.
      * *   If one of the specified sub-devices fails to establish a topological relationship with the gateway, the system rolls back, and all specified sub-devices fail to establish topological relationships with the gateway.
      * *   After you call this operation to establish topological relationships between sub-devices and the gateway, IoT Platform uses the `/sys/${productKey}/${deviceName}/thing/topo/change` topic to push information that includes the result of this operation to the gateway. For more information, see [Notify gateways of changes of topological relationships](~~89299~~).
      * ## QPS limits
      * You can call this API operation up to 10 times per second per Alibaba Cloud account.
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchAddThingTopoRequest
      * @return BatchAddThingTopoResponse
     */
    async batchAddThingTopo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchAddThingTopoWithOptions(request, runtime);
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information about common request parameters, see [Common parameters](~~30561~~).
      *
      * @param request BatchBindDeviceToEdgeInstanceWithDriverRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchBindDeviceToEdgeInstanceWithDriverResponse
     */
    async batchBindDeviceToEdgeInstanceWithDriverWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotIds)) {
            query["IotIds"] = request.iotIds;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchBindDeviceToEdgeInstanceWithDriver",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchBindDeviceToEdgeInstanceWithDriverResponse({}));
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information about common request parameters, see [Common parameters](~~30561~~).
      *
      * @param request BatchBindDeviceToEdgeInstanceWithDriverRequest
      * @return BatchBindDeviceToEdgeInstanceWithDriverResponse
     */
    async batchBindDeviceToEdgeInstanceWithDriver(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchBindDeviceToEdgeInstanceWithDriverWithOptions(request, runtime);
    }
    async batchBindDevicesIntoProjectWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.devices)) {
            body["Devices"] = request.devices;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchBindDevicesIntoProject",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchBindDevicesIntoProjectResponse({}));
    }
    async batchBindDevicesIntoProject(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchBindDevicesIntoProjectWithOptions(request, runtime);
    }
    async batchBindProductsIntoProjectWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKeys)) {
            body["ProductKeys"] = request.productKeys;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchBindProductsIntoProject",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchBindProductsIntoProjectResponse({}));
    }
    async batchBindProductsIntoProject(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchBindProductsIntoProjectWithOptions(request, runtime);
    }
    /**
      * You can call this operation with the **BatchRegisterDeviceWithApplyId** operation to register multiple devices under a product. Each device carries a unique DeviceName.
      * Procedure:
      * 1\\. Call this operation to specify the DeviceNames of the devices to be registered. IoT Platform returns an application ID (**ApplyId**). A successful response indicates that the request to verify the DeviceNames is submitted. The actual registration process is asynchronously implemented and takes some minutes.
      * 2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
      * 3\\. Call the [BatchRegisterDeviceWithApplyId](~~69514~~) operation to register multiple devices.
      * 4\\. Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to view the registration result.
      * 5\\. Call the [QueryPageByApplyId](~~69518~~) operation to query the information about the registered devices.
      * ## Limits
      * - You can specify a maximum of 10,000 DeviceNames in a single call.
      * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchCheckDeviceNamesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchCheckDeviceNamesResponse
     */
    async batchCheckDeviceNamesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.deviceNameList)) {
            body["DeviceNameList"] = request.deviceNameList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchCheckDeviceNames",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchCheckDeviceNamesResponse({}));
    }
    /**
      * You can call this operation with the **BatchRegisterDeviceWithApplyId** operation to register multiple devices under a product. Each device carries a unique DeviceName.
      * Procedure:
      * 1\\. Call this operation to specify the DeviceNames of the devices to be registered. IoT Platform returns an application ID (**ApplyId**). A successful response indicates that the request to verify the DeviceNames is submitted. The actual registration process is asynchronously implemented and takes some minutes.
      * 2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
      * 3\\. Call the [BatchRegisterDeviceWithApplyId](~~69514~~) operation to register multiple devices.
      * 4\\. Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to view the registration result.
      * 5\\. Call the [QueryPageByApplyId](~~69518~~) operation to query the information about the registered devices.
      * ## Limits
      * - You can specify a maximum of 10,000 DeviceNames in a single call.
      * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchCheckDeviceNamesRequest
      * @return BatchCheckDeviceNamesResponse
     */
    async batchCheckDeviceNames(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchCheckDeviceNamesWithOptions(request, runtime);
    }
    async batchCheckImportDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceList)) {
            body["DeviceList"] = request.deviceList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchCheckImportDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchCheckImportDeviceResponse({}));
    }
    async batchCheckImportDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchCheckImportDeviceWithOptions(request, runtime);
    }
    /**
      * The invalid device models returned if the call fails.
      *
      * @param request BatchCheckVehicleDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchCheckVehicleDeviceResponse
     */
    async batchCheckVehicleDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceList)) {
            body["DeviceList"] = request.deviceList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchCheckVehicleDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchCheckVehicleDeviceResponse({}));
    }
    /**
      * The invalid device models returned if the call fails.
      *
      * @param request BatchCheckVehicleDeviceRequest
      * @return BatchCheckVehicleDeviceResponse
     */
    async batchCheckVehicleDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchCheckVehicleDeviceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchClearEdgeInstanceDeviceConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchClearEdgeInstanceDeviceConfigResponse
     */
    async batchClearEdgeInstanceDeviceConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotIds)) {
            query["IotIds"] = request.iotIds;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchClearEdgeInstanceDeviceConfig",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchClearEdgeInstanceDeviceConfigResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchClearEdgeInstanceDeviceConfigRequest
      * @return BatchClearEdgeInstanceDeviceConfigResponse
     */
    async batchClearEdgeInstanceDeviceConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchClearEdgeInstanceDeviceConfigWithOptions(request, runtime);
    }
    async batchCreateSoundCodeLabelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.scheduleCode)) {
            body["ScheduleCode"] = request.scheduleCode;
        }
        if (!tea_util_1.default.isUnset(request.total)) {
            body["Total"] = request.total;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchCreateSoundCodeLabel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchCreateSoundCodeLabelResponse({}));
    }
    async batchCreateSoundCodeLabel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchCreateSoundCodeLabelWithOptions(request, runtime);
    }
    async batchCreateSoundCodeLabelWithLabelsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.labels)) {
            body["Labels"] = request.labels;
        }
        if (!tea_util_1.default.isUnset(request.scheduleCode)) {
            body["ScheduleCode"] = request.scheduleCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchCreateSoundCodeLabelWithLabels",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchCreateSoundCodeLabelWithLabelsResponse({}));
    }
    async batchCreateSoundCodeLabelWithLabels(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchCreateSoundCodeLabelWithLabelsWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchDeleteDeviceGroupRelationsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchDeleteDeviceGroupRelationsResponse
     */
    async batchDeleteDeviceGroupRelationsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.device)) {
            query["Device"] = request.device;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchDeleteDeviceGroupRelations",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchDeleteDeviceGroupRelationsResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchDeleteDeviceGroupRelationsRequest
      * @return BatchDeleteDeviceGroupRelationsResponse
     */
    async batchDeleteDeviceGroupRelations(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchDeleteDeviceGroupRelationsWithOptions(request, runtime);
    }
    async batchDeleteEdgeInstanceChannelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.channelIds)) {
            query["ChannelIds"] = request.channelIds;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchDeleteEdgeInstanceChannel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchDeleteEdgeInstanceChannelResponse({}));
    }
    async batchDeleteEdgeInstanceChannel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchDeleteEdgeInstanceChannelWithOptions(request, runtime);
    }
    async batchGetDeviceBindStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotIds)) {
            query["IotIds"] = request.iotIds;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetDeviceBindStatus",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchGetDeviceBindStatusResponse({}));
    }
    async batchGetDeviceBindStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchGetDeviceBindStatusWithOptions(request, runtime);
    }
    /**
      * When you call this operation, you can perform the following operations:
      * *   You can specify a value for the **ProductKey** parameter and multiple values for the **DeviceName** parameter to query the status of devices that belong to a product.
      * *   You can specify multiple values for the **IotId** parameter to query the status of devices that belong to different products.****
      * >You can query the status of up to 50 devices in a call.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchGetDeviceStateRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchGetDeviceStateResponse
     */
    async batchGetDeviceStateWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetDeviceState",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchGetDeviceStateResponse({}));
    }
    /**
      * When you call this operation, you can perform the following operations:
      * *   You can specify a value for the **ProductKey** parameter and multiple values for the **DeviceName** parameter to query the status of devices that belong to a product.
      * *   You can specify multiple values for the **IotId** parameter to query the status of devices that belong to different products.****
      * >You can query the status of up to 50 devices in a call.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchGetDeviceStateRequest
      * @return BatchGetDeviceStateResponse
     */
    async batchGetDeviceState(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchGetDeviceStateWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users share the quota of the Alibaba Cloud account.
      *
      * @param request BatchGetEdgeDriverRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchGetEdgeDriverResponse
     */
    async batchGetEdgeDriverWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverIds)) {
            query["DriverIds"] = request.driverIds;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetEdgeDriver",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchGetEdgeDriverResponse({}));
    }
    /**
      * ## Limits
      * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users share the quota of the Alibaba Cloud account.
      *
      * @param request BatchGetEdgeDriverRequest
      * @return BatchGetEdgeDriverResponse
     */
    async batchGetEdgeDriver(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchGetEdgeDriverWithOptions(request, runtime);
    }
    async batchGetEdgeInstanceChannelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.channelIds)) {
            query["ChannelIds"] = request.channelIds;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetEdgeInstanceChannel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceChannelResponse({}));
    }
    async batchGetEdgeInstanceChannel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchGetEdgeInstanceChannelWithOptions(request, runtime);
    }
    async batchGetEdgeInstanceDeviceChannelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotIds)) {
            query["IotIds"] = request.iotIds;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetEdgeInstanceDeviceChannel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDeviceChannelResponse({}));
    }
    async batchGetEdgeInstanceDeviceChannel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchGetEdgeInstanceDeviceChannelWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchGetEdgeInstanceDeviceConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchGetEdgeInstanceDeviceConfigResponse
     */
    async batchGetEdgeInstanceDeviceConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotIds)) {
            query["IotIds"] = request.iotIds;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetEdgeInstanceDeviceConfig",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDeviceConfigResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchGetEdgeInstanceDeviceConfigRequest
      * @return BatchGetEdgeInstanceDeviceConfigResponse
     */
    async batchGetEdgeInstanceDeviceConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchGetEdgeInstanceDeviceConfigWithOptions(request, runtime);
    }
    async batchGetEdgeInstanceDeviceDriverWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotIds)) {
            query["IotIds"] = request.iotIds;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetEdgeInstanceDeviceDriver",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDeviceDriverResponse({}));
    }
    async batchGetEdgeInstanceDeviceDriver(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchGetEdgeInstanceDeviceDriverWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchGetEdgeInstanceDriverConfigsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchGetEdgeInstanceDriverConfigsResponse
     */
    async batchGetEdgeInstanceDriverConfigsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverIds)) {
            query["DriverIds"] = request.driverIds;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetEdgeInstanceDriverConfigs",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDriverConfigsResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchGetEdgeInstanceDriverConfigsRequest
      * @return BatchGetEdgeInstanceDriverConfigsResponse
     */
    async batchGetEdgeInstanceDriverConfigs(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchGetEdgeInstanceDriverConfigsWithOptions(request, runtime);
    }
    async batchGrayMigrationDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceNames)) {
            body["DeviceNames"] = request.deviceNames;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchGrayMigrationDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchGrayMigrationDeviceResponse({}));
    }
    async batchGrayMigrationDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchGrayMigrationDeviceWithOptions(request, runtime);
    }
    async batchImportDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceList)) {
            body["DeviceList"] = request.deviceList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchImportDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchImportDeviceResponse({}));
    }
    async batchImportDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchImportDeviceWithOptions(request, runtime);
    }
    /**
      * Indicates whether the call was successful. Valid values:
      * - **true**: The call was successful.
      * - **false**: The call failed.
      *
      * @param request BatchImportVehicleDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchImportVehicleDeviceResponse
     */
    async batchImportVehicleDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceList)) {
            body["DeviceList"] = request.deviceList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchImportVehicleDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchImportVehicleDeviceResponse({}));
    }
    /**
      * Indicates whether the call was successful. Valid values:
      * - **true**: The call was successful.
      * - **false**: The call failed.
      *
      * @param request BatchImportVehicleDeviceRequest
      * @return BatchImportVehicleDeviceResponse
     */
    async batchImportVehicleDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchImportVehicleDeviceWithOptions(request, runtime);
    }
    /**
      * *   You can call this operation to publish a message to a maximum of 100 devices of a product at a time.
      * *   The BatchPub operation cannot be used to send commands of setting properties or calling services. If you need to set properties, use the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation. If you need to call services, use the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchPubRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchPubResponse
     */
    async batchPubWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.messageContent)) {
            query["MessageContent"] = request.messageContent;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.qos)) {
            query["Qos"] = request.qos;
        }
        if (!tea_util_1.default.isUnset(request.topicShortName)) {
            query["TopicShortName"] = request.topicShortName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchPub",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchPubResponse({}));
    }
    /**
      * *   You can call this operation to publish a message to a maximum of 100 devices of a product at a time.
      * *   The BatchPub operation cannot be used to send commands of setting properties or calling services. If you need to set properties, use the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation. If you need to call services, use the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchPubRequest
      * @return BatchPubResponse
     */
    async batchPub(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchPubWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You can query a maximum of 100 devices in a single call.
      * *   You can query the details of devices that belong only to the current Alibaba Cloud account. If you specify a device that does not belong to the current account, an error message is returned.
      * *   If you specify multiple devices and some devices do not exist, only the details of existing devices are returned.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchQueryDeviceDetailRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchQueryDeviceDetailResponse
     */
    async batchQueryDeviceDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchQueryDeviceDetail",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchQueryDeviceDetailResponse({}));
    }
    /**
      * ## Limits
      * *   You can query a maximum of 100 devices in a single call.
      * *   You can query the details of devices that belong only to the current Alibaba Cloud account. If you specify a device that does not belong to the current account, an error message is returned.
      * *   If you specify multiple devices and some devices do not exist, only the details of existing devices are returned.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchQueryDeviceDetailRequest
      * @return BatchQueryDeviceDetailResponse
     */
    async batchQueryDeviceDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchQueryDeviceDetailWithOptions(request, runtime);
    }
    /**
      * You can use one of the following methods to register multiple devices:
      * *   If you want to generate random DeviceNames, call the BatchRegisterDevice operation.
      *     Perform the following steps to register devices and view the result:
      *     1\\. Call the BatchRegisterDevice operation to register multiple devices. A successful response indicates that the registration request is submitted. The actual registration process is asynchronously implemented and takes some minutes.
      *     2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
      *     3\\. Call the [QueryPageByApplyId](~~69518~~) operation to view the details of registered devices. The details include the DeviceName, DeviceSecret, and IotId parameters.
      * *   If you want to specify custom DeviceNames, call the BatchRegisterDeviceWithApplyId operation. For more information, see [BatchRegisterDeviceWithApplyId](~~69514~~).
      * ## Limits
      * - You can create a maximum of 10,000 devices in a single call.
      * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchRegisterDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchRegisterDeviceResponse
     */
    async batchRegisterDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.count)) {
            query["Count"] = request.count;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchRegisterDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchRegisterDeviceResponse({}));
    }
    /**
      * You can use one of the following methods to register multiple devices:
      * *   If you want to generate random DeviceNames, call the BatchRegisterDevice operation.
      *     Perform the following steps to register devices and view the result:
      *     1\\. Call the BatchRegisterDevice operation to register multiple devices. A successful response indicates that the registration request is submitted. The actual registration process is asynchronously implemented and takes some minutes.
      *     2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
      *     3\\. Call the [QueryPageByApplyId](~~69518~~) operation to view the details of registered devices. The details include the DeviceName, DeviceSecret, and IotId parameters.
      * *   If you want to specify custom DeviceNames, call the BatchRegisterDeviceWithApplyId operation. For more information, see [BatchRegisterDeviceWithApplyId](~~69514~~).
      * ## Limits
      * - You can create a maximum of 10,000 devices in a single call.
      * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchRegisterDeviceRequest
      * @return BatchRegisterDeviceResponse
     */
    async batchRegisterDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchRegisterDeviceWithOptions(request, runtime);
    }
    /**
      * You can use one of the following methods to register multiple devices at a time:
      * *   Call the [BatchRegisterDevice](~~69473~~) operation to generate random DeviceNames.
      * *   Call the BatchRegisterDeviceWithApplyId and **BatchCheckDeviceNames** operations to specify custom DeviceNames. Procedure:
      *     Call the [BatchCheckDeviceNames](~~69482~~) operation and specify the names of devices that you want to register. If the DeviceNames are valid, IoT Platform returns an application ID that is specified by the **ApplyId** parameter. You can query the DeviceName setting results, device registration results, and device details by **ApplyId**.
      *     Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
      *     Call the BatchRegisterDeviceWithApplyId operation to register multiple devices. The successful result that is returned by this operation indicates that only the batch registration request is submitted. In actual scenarios, the registration process takes a few minutes.
      *     Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
      *     Call the [QueryPageByApplyId](~~69518~~) operation to view the details of devices that are registered in batches.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request BatchRegisterDeviceWithApplyIdRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchRegisterDeviceWithApplyIdResponse
     */
    async batchRegisterDeviceWithApplyIdWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.applyId)) {
            query["ApplyId"] = request.applyId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchRegisterDeviceWithApplyId",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchRegisterDeviceWithApplyIdResponse({}));
    }
    /**
      * You can use one of the following methods to register multiple devices at a time:
      * *   Call the [BatchRegisterDevice](~~69473~~) operation to generate random DeviceNames.
      * *   Call the BatchRegisterDeviceWithApplyId and **BatchCheckDeviceNames** operations to specify custom DeviceNames. Procedure:
      *     Call the [BatchCheckDeviceNames](~~69482~~) operation and specify the names of devices that you want to register. If the DeviceNames are valid, IoT Platform returns an application ID that is specified by the **ApplyId** parameter. You can query the DeviceName setting results, device registration results, and device details by **ApplyId**.
      *     Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
      *     Call the BatchRegisterDeviceWithApplyId operation to register multiple devices. The successful result that is returned by this operation indicates that only the batch registration request is submitted. In actual scenarios, the registration process takes a few minutes.
      *     Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
      *     Call the [QueryPageByApplyId](~~69518~~) operation to view the details of devices that are registered in batches.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request BatchRegisterDeviceWithApplyIdRequest
      * @return BatchRegisterDeviceWithApplyIdResponse
     */
    async batchRegisterDeviceWithApplyId(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchRegisterDeviceWithApplyIdWithOptions(request, runtime);
    }
    async batchSetEdgeInstanceDeviceChannelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.channelId)) {
            query["ChannelId"] = request.channelId;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotIds)) {
            query["IotIds"] = request.iotIds;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchSetEdgeInstanceDeviceChannel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchSetEdgeInstanceDeviceChannelResponse({}));
    }
    async batchSetEdgeInstanceDeviceChannel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchSetEdgeInstanceDeviceChannelWithOptions(request, runtime);
    }
    async batchSetEdgeInstanceDeviceConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceConfigs)) {
            query["DeviceConfigs"] = request.deviceConfigs;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchSetEdgeInstanceDeviceConfig",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchSetEdgeInstanceDeviceConfigResponse({}));
    }
    async batchSetEdgeInstanceDeviceConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchSetEdgeInstanceDeviceConfigWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchUnbindDeviceFromEdgeInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchUnbindDeviceFromEdgeInstanceResponse
     */
    async batchUnbindDeviceFromEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotIds)) {
            query["IotIds"] = request.iotIds;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchUnbindDeviceFromEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchUnbindDeviceFromEdgeInstanceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchUnbindDeviceFromEdgeInstanceRequest
      * @return BatchUnbindDeviceFromEdgeInstanceResponse
     */
    async batchUnbindDeviceFromEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchUnbindDeviceFromEdgeInstanceWithOptions(request, runtime);
    }
    async batchUnbindProjectDevicesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.devices)) {
            body["Devices"] = request.devices;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchUnbindProjectDevices",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchUnbindProjectDevicesResponse({}));
    }
    async batchUnbindProjectDevices(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchUnbindProjectDevicesWithOptions(request, runtime);
    }
    async batchUnbindProjectProductsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKeys)) {
            body["ProductKeys"] = request.productKeys;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchUnbindProjectProducts",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchUnbindProjectProductsResponse({}));
    }
    async batchUnbindProjectProducts(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchUnbindProjectProductsWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchUpdateDeviceNicknameRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BatchUpdateDeviceNicknameResponse
     */
    async batchUpdateDeviceNicknameWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceNicknameInfo)) {
            query["DeviceNicknameInfo"] = request.deviceNicknameInfo;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchUpdateDeviceNickname",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BatchUpdateDeviceNicknameResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BatchUpdateDeviceNicknameRequest
      * @return BatchUpdateDeviceNicknameResponse
     */
    async batchUpdateDeviceNickname(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.batchUpdateDeviceNicknameWithOptions(request, runtime);
    }
    async bindApplicationToEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.applicationId)) {
            query["ApplicationId"] = request.applicationId;
        }
        if (!tea_util_1.default.isUnset(request.applicationVersion)) {
            query["ApplicationVersion"] = request.applicationVersion;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BindApplicationToEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BindApplicationToEdgeInstanceResponse({}));
    }
    async bindApplicationToEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.bindApplicationToEdgeInstanceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BindDriverToEdgeInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BindDriverToEdgeInstanceResponse
     */
    async bindDriverToEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.driverVersion)) {
            query["DriverVersion"] = request.driverVersion;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.orderId)) {
            query["OrderId"] = request.orderId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BindDriverToEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BindDriverToEdgeInstanceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BindDriverToEdgeInstanceRequest
      * @return BindDriverToEdgeInstanceResponse
     */
    async bindDriverToEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.bindDriverToEdgeInstanceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BindGatewayToEdgeInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return BindGatewayToEdgeInstanceResponse
     */
    async bindGatewayToEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BindGatewayToEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BindGatewayToEdgeInstanceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request BindGatewayToEdgeInstanceRequest
      * @return BindGatewayToEdgeInstanceResponse
     */
    async bindGatewayToEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.bindGatewayToEdgeInstanceWithOptions(request, runtime);
    }
    async bindLicenseDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.licenseCode)) {
            query["LicenseCode"] = request.licenseCode;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceNameList)) {
            body["DeviceNameList"] = request.deviceNameList;
        }
        if (!tea_util_1.default.isUnset(request.iotIdList)) {
            body["IotIdList"] = request.iotIdList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BindLicenseDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BindLicenseDeviceResponse({}));
    }
    async bindLicenseDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.bindLicenseDeviceWithOptions(request, runtime);
    }
    async bindLicenseProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.licenseCode)) {
            query["LicenseCode"] = request.licenseCode;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BindLicenseProduct",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BindLicenseProductResponse({}));
    }
    async bindLicenseProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.bindLicenseProductWithOptions(request, runtime);
    }
    async bindRoleToEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.roleArn)) {
            query["RoleArn"] = request.roleArn;
        }
        if (!tea_util_1.default.isUnset(request.roleName)) {
            query["RoleName"] = request.roleName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BindRoleToEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BindRoleToEdgeInstanceResponse({}));
    }
    async bindRoleToEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.bindRoleToEdgeInstanceWithOptions(request, runtime);
    }
    async bindSceneRuleToEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BindSceneRuleToEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new BindSceneRuleToEdgeInstanceResponse({}));
    }
    async bindSceneRuleToEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.bindSceneRuleToEdgeInstanceWithOptions(request, runtime);
    }
    async cancelJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CancelJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelJobResponse({}));
    }
    async cancelJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.cancelJobWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You can cancel only the dynamic update policy that is attached to a dynamic update batch. This operation is not applicable to static update batches.
      *     After the operation is successful, the **JobStatus** parameter is set to CANCELED.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CancelOTAStrategyByJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CancelOTAStrategyByJobResponse
     */
    async cancelOTAStrategyByJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CancelOTAStrategyByJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelOTAStrategyByJobResponse({}));
    }
    /**
      * ## Limits
      * *   You can cancel only the dynamic update policy that is attached to a dynamic update batch. This operation is not applicable to static update batches.
      *     After the operation is successful, the **JobStatus** parameter is set to CANCELED.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CancelOTAStrategyByJobRequest
      * @return CancelOTAStrategyByJobResponse
     */
    async cancelOTAStrategyByJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.cancelOTAStrategyByJobWithOptions(request, runtime);
    }
    /**
      * This operation can cancel device update tasks only when the tasks are in the to be pushed, pushed, or in upgrade state.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request CancelOTATaskByDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CancelOTATaskByDeviceResponse
     */
    async cancelOTATaskByDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.firmwareId)) {
            query["FirmwareId"] = request.firmwareId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CancelOTATaskByDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelOTATaskByDeviceResponse({}));
    }
    /**
      * This operation can cancel device update tasks only when the tasks are in the to be pushed, pushed, or in upgrade state.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request CancelOTATaskByDeviceRequest
      * @return CancelOTATaskByDeviceResponse
     */
    async cancelOTATaskByDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.cancelOTATaskByDeviceWithOptions(request, runtime);
    }
    /**
      * When you call this operation, make sure that you specify at least one of the CancelScheduledTask, CancelQueuedTask, CancelInProgressTask, CancelNotifiedTask, and CancelUnconfirmedTask parameters. Otherwise, the request will fail.
      * ## QPS limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CancelOTATaskByJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CancelOTATaskByJobResponse
     */
    async cancelOTATaskByJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.cancelInProgressTask)) {
            query["CancelInProgressTask"] = request.cancelInProgressTask;
        }
        if (!tea_util_1.default.isUnset(request.cancelNotifiedTask)) {
            query["CancelNotifiedTask"] = request.cancelNotifiedTask;
        }
        if (!tea_util_1.default.isUnset(request.cancelQueuedTask)) {
            query["CancelQueuedTask"] = request.cancelQueuedTask;
        }
        if (!tea_util_1.default.isUnset(request.cancelScheduledTask)) {
            query["CancelScheduledTask"] = request.cancelScheduledTask;
        }
        if (!tea_util_1.default.isUnset(request.cancelUnconfirmedTask)) {
            query["CancelUnconfirmedTask"] = request.cancelUnconfirmedTask;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CancelOTATaskByJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelOTATaskByJobResponse({}));
    }
    /**
      * When you call this operation, make sure that you specify at least one of the CancelScheduledTask, CancelQueuedTask, CancelInProgressTask, CancelNotifiedTask, and CancelUnconfirmedTask parameters. Otherwise, the request will fail.
      * ## QPS limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CancelOTATaskByJobRequest
      * @return CancelOTATaskByJobResponse
     */
    async cancelOTATaskByJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.cancelOTATaskByJobWithOptions(request, runtime);
    }
    /**
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CancelReleaseProductRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CancelReleaseProductResponse
     */
    async cancelReleaseProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CancelReleaseProduct",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelReleaseProductResponse({}));
    }
    /**
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CancelReleaseProductRequest
      * @return CancelReleaseProductResponse
     */
    async cancelReleaseProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.cancelReleaseProductWithOptions(request, runtime);
    }
    async checkBindLicenseDeviceProgressWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.checkProgressId)) {
            query["CheckProgressId"] = request.checkProgressId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.licenseCode)) {
            query["LicenseCode"] = request.licenseCode;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CheckBindLicenseDeviceProgress",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CheckBindLicenseDeviceProgressResponse({}));
    }
    async checkBindLicenseDeviceProgress(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.checkBindLicenseDeviceProgressWithOptions(request, runtime);
    }
    /**
      * *   Each time you call this operation, you must specify the identifiers of properties whose desired values you want to delete for the **Identifies** parameter. If you do not configure the **Identifies** parameter, the call fails.
      * *   You can specify up to 10 property identifiers for the **Identifies** parameter in a single call.
      * *   After you call this operation to deletes the desired values of properties of a device, you can call the [QueryDeviceDesiredProperty](~~107566~~) operation to query the desired values of properties of the device. In this case, the QueryDeviceDesiredProperty operation returns the **Identifier** parameter instead of the **Value** parameter.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ClearDeviceDesiredPropertyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ClearDeviceDesiredPropertyResponse
     */
    async clearDeviceDesiredPropertyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.identifies)) {
            body["Identifies"] = request.identifies;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ClearDeviceDesiredProperty",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ClearDeviceDesiredPropertyResponse({}));
    }
    /**
      * *   Each time you call this operation, you must specify the identifiers of properties whose desired values you want to delete for the **Identifies** parameter. If you do not configure the **Identifies** parameter, the call fails.
      * *   You can specify up to 10 property identifiers for the **Identifies** parameter in a single call.
      * *   After you call this operation to deletes the desired values of properties of a device, you can call the [QueryDeviceDesiredProperty](~~107566~~) operation to query the desired values of properties of the device. In this case, the QueryDeviceDesiredProperty operation returns the **Identifier** parameter instead of the **Value** parameter.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ClearDeviceDesiredPropertyRequest
      * @return ClearDeviceDesiredPropertyResponse
     */
    async clearDeviceDesiredProperty(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.clearDeviceDesiredPropertyWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ClearEdgeInstanceDriverConfigsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ClearEdgeInstanceDriverConfigsResponse
     */
    async clearEdgeInstanceDriverConfigsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ClearEdgeInstanceDriverConfigs",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ClearEdgeInstanceDriverConfigsResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ClearEdgeInstanceDriverConfigsRequest
      * @return ClearEdgeInstanceDriverConfigsResponse
     */
    async clearEdgeInstanceDriverConfigs(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.clearEdgeInstanceDriverConfigsWithOptions(request, runtime);
    }
    async closeDeviceTunnelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.tunnelId)) {
            query["TunnelId"] = request.tunnelId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CloseDeviceTunnel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CloseDeviceTunnelResponse({}));
    }
    async closeDeviceTunnel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.closeDeviceTunnelWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CloseEdgeInstanceDeploymentRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CloseEdgeInstanceDeploymentResponse
     */
    async closeEdgeInstanceDeploymentWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CloseEdgeInstanceDeployment",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CloseEdgeInstanceDeploymentResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CloseEdgeInstanceDeploymentRequest
      * @return CloseEdgeInstanceDeploymentResponse
     */
    async closeEdgeInstanceDeployment(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.closeEdgeInstanceDeploymentWithOptions(request, runtime);
    }
    /**
      * To confirm update tasks in a scheduled update batch, you must call this operation within the specified time range.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ConfirmOTATaskRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ConfirmOTATaskResponse
     */
    async confirmOTATaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ConfirmOTATask",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ConfirmOTATaskResponse({}));
    }
    /**
      * To confirm update tasks in a scheduled update batch, you must call this operation within the specified time range.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ConfirmOTATaskRequest
      * @return ConfirmOTATaskResponse
     */
    async confirmOTATask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.confirmOTATaskWithOptions(request, runtime);
    }
    /**
      * *   If a destination product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you can copy a TSL model.
      * *   The categories of the source product and destination product must be the same. The product category is indicated by the **CategoryKey** parameter. You can call the [QueryProduct](~~69272~~) operation and view the **CategoryKey** parameter of a product in the returned result.
      * *   You must specify the version of the TSL model that you want to copy by using the **SourceModelVersion** parameter in the request. Otherwise, the CopyThingModel operation fails.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to five queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CopyThingModelRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CopyThingModelResponse
     */
    async copyThingModelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.sourceModelVersion)) {
            query["SourceModelVersion"] = request.sourceModelVersion;
        }
        if (!tea_util_1.default.isUnset(request.sourceProductKey)) {
            query["SourceProductKey"] = request.sourceProductKey;
        }
        if (!tea_util_1.default.isUnset(request.targetProductKey)) {
            query["TargetProductKey"] = request.targetProductKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CopyThingModel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CopyThingModelResponse({}));
    }
    /**
      * *   If a destination product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you can copy a TSL model.
      * *   The categories of the source product and destination product must be the same. The product category is indicated by the **CategoryKey** parameter. You can call the [QueryProduct](~~69272~~) operation and view the **CategoryKey** parameter of a product in the returned result.
      * *   You must specify the version of the TSL model that you want to copy by using the **SourceModelVersion** parameter in the request. Otherwise, the CopyThingModel operation fails.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to five queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CopyThingModelRequest
      * @return CopyThingModelResponse
     */
    async copyThingModel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.copyThingModelWithOptions(request, runtime);
    }
    async countSpeechBroadcastHourWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.queryDateTimeHour)) {
            query["QueryDateTimeHour"] = request.queryDateTimeHour;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.shareTaskCode)) {
            body["ShareTaskCode"] = request.shareTaskCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CountSpeechBroadcastHour",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CountSpeechBroadcastHourResponse({}));
    }
    async countSpeechBroadcastHour(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.countSpeechBroadcastHourWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateConsumerGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateConsumerGroupResponse
     */
    async createConsumerGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupName)) {
            query["GroupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.subBizCode)) {
            query["SubBizCode"] = request.subBizCode;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateConsumerGroup",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateConsumerGroupResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateConsumerGroupRequest
      * @return CreateConsumerGroupResponse
     */
    async createConsumerGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createConsumerGroupWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateConsumerGroupSubscribeRelationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateConsumerGroupSubscribeRelationResponse
     */
    async createConsumerGroupSubscribeRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.consumerGroupId)) {
            query["ConsumerGroupId"] = request.consumerGroupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateConsumerGroupSubscribeRelation",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateConsumerGroupSubscribeRelationResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateConsumerGroupSubscribeRelationRequest
      * @return CreateConsumerGroupSubscribeRelationResponse
     */
    async createConsumerGroupSubscribeRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createConsumerGroupSubscribeRelationWithOptions(request, runtime);
    }
    async createDataAPIServiceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.apiPath)) {
            body["ApiPath"] = request.apiPath;
        }
        if (!tea_util_1.default.isUnset(request.desc)) {
            body["Desc"] = request.desc;
        }
        if (!tea_util_1.default.isUnset(request.displayName)) {
            body["DisplayName"] = request.displayName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.originSql)) {
            body["OriginSql"] = request.originSql;
        }
        if (!tea_util_1.default.isUnset(request.requestParam)) {
            body["RequestParam"] = request.requestParam;
        }
        if (!tea_util_1.default.isUnset(request.responseParam)) {
            body["ResponseParam"] = request.responseParam;
        }
        if (!tea_util_1.default.isUnset(request.templateSql)) {
            body["TemplateSql"] = request.templateSql;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateDataAPIService",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDataAPIServiceResponse({}));
    }
    async createDataAPIService(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDataAPIServiceWithOptions(request, runtime);
    }
    async createDataSourceItemWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dataSourceId)) {
            query["DataSourceId"] = request.dataSourceId;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.scopeType)) {
            query["ScopeType"] = request.scopeType;
        }
        if (!tea_util_1.default.isUnset(request.topic)) {
            query["Topic"] = request.topic;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDataSourceItem",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDataSourceItemResponse({}));
    }
    async createDataSourceItem(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDataSourceItemWithOptions(request, runtime);
    }
    async createDestinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.configuration)) {
            query["Configuration"] = request.configuration;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDestination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDestinationResponse({}));
    }
    async createDestination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDestinationWithOptions(request, runtime);
    }
    /**
      * To distribute devices, perform the following steps:
      * 1\\. Asynchronously call this operation to create a device distribution task and obtain the **JobId** parameter.
      * 2\\. Use **JobId** as a request parameter and repeatedly call the [QueryDeviceDistributeJob](~~199536~~) operation to obtain the **Status** parameter.
      * >  You must control the frequency of calls based on the QPS limit of the QueryDeviceDistributeJob operation.
      * If either of the following values is returned for the **Status** parameter, the distribution task ends:
      * *   **2**: The device distribution task is completed. This return value does not indicate that the devices are distributed. To obtain the distribution result of each device, perform the next step.
      * *   **3**: The distribution is unexpectedly interrupted. After you process the error, you can initiate a device distribution task again.
      * 3\\. Use **JobId** that is returned in Step 1 as a request parameter and call the [QueryDeviceDistributeDetail](~~199533~~) operation to obtain the **File** parameter. The File parameter indicates the file URL of the distribution result.
      * >  The file URL is valid for 10 minutes.
      * 4\\. Obtain the distribution result by using the file URL. The **Code** parameter indicates whether a device is distributed. If the value of the **Code** parameter is 200, the device is distributed.
      * If the distribution fails, you can perform the preceding steps to distribute devices again.
      * ## Limits
      * - This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * - You cannot call this operation to distribute devices across accounts.
      * - Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a product distribution task, see [CreateProductDistributeJob](/help/en/iot-platform/latest/createproductdistributejob).
      * - Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateDeviceDistributeJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDeviceDistributeJobResponse
     */
    async createDeviceDistributeJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.sourceInstanceId)) {
            body["SourceInstanceId"] = request.sourceInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.strategy)) {
            body["Strategy"] = request.strategy;
        }
        if (!tea_util_1.default.isUnset(request.targetAliyunId)) {
            body["TargetAliyunId"] = request.targetAliyunId;
        }
        if (!tea_util_1.default.isUnset(request.targetInstanceConfig)) {
            body["TargetInstanceConfig"] = request.targetInstanceConfig;
        }
        if (!tea_util_1.default.isUnset(request.targetUid)) {
            body["TargetUid"] = request.targetUid;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateDeviceDistributeJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDeviceDistributeJobResponse({}));
    }
    /**
      * To distribute devices, perform the following steps:
      * 1\\. Asynchronously call this operation to create a device distribution task and obtain the **JobId** parameter.
      * 2\\. Use **JobId** as a request parameter and repeatedly call the [QueryDeviceDistributeJob](~~199536~~) operation to obtain the **Status** parameter.
      * >  You must control the frequency of calls based on the QPS limit of the QueryDeviceDistributeJob operation.
      * If either of the following values is returned for the **Status** parameter, the distribution task ends:
      * *   **2**: The device distribution task is completed. This return value does not indicate that the devices are distributed. To obtain the distribution result of each device, perform the next step.
      * *   **3**: The distribution is unexpectedly interrupted. After you process the error, you can initiate a device distribution task again.
      * 3\\. Use **JobId** that is returned in Step 1 as a request parameter and call the [QueryDeviceDistributeDetail](~~199533~~) operation to obtain the **File** parameter. The File parameter indicates the file URL of the distribution result.
      * >  The file URL is valid for 10 minutes.
      * 4\\. Obtain the distribution result by using the file URL. The **Code** parameter indicates whether a device is distributed. If the value of the **Code** parameter is 200, the device is distributed.
      * If the distribution fails, you can perform the preceding steps to distribute devices again.
      * ## Limits
      * - This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * - You cannot call this operation to distribute devices across accounts.
      * - Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a product distribution task, see [CreateProductDistributeJob](/help/en/iot-platform/latest/createproductdistributejob).
      * - Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateDeviceDistributeJobRequest
      * @return CreateDeviceDistributeJobResponse
     */
    async createDeviceDistributeJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDeviceDistributeJobWithOptions(request, runtime);
    }
    async createDeviceDynamicGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dynamicGroupExpression)) {
            query["DynamicGroupExpression"] = request.dynamicGroupExpression;
        }
        if (!tea_util_1.default.isUnset(request.groupDesc)) {
            query["GroupDesc"] = request.groupDesc;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            query["GroupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDeviceDynamicGroup",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDeviceDynamicGroupResponse({}));
    }
    async createDeviceDynamicGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDeviceDynamicGroupWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateDeviceGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDeviceGroupResponse
     */
    async createDeviceGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupDesc)) {
            query["GroupDesc"] = request.groupDesc;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            query["GroupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.superGroupId)) {
            query["SuperGroupId"] = request.superGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDeviceGroup",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDeviceGroupResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateDeviceGroupRequest
      * @return CreateDeviceGroupResponse
     */
    async createDeviceGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDeviceGroupWithOptions(request, runtime);
    }
    async createDeviceTunnelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.udi)) {
            query["Udi"] = request.udi;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDeviceTunnel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDeviceTunnelResponse({}));
    }
    async createDeviceTunnel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDeviceTunnelWithOptions(request, runtime);
    }
    async createDownloadDataJobWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateDownloadDataJobShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.fileConfig)) {
            request.fileConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.fileConfig, "FileConfig", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.downloadDataType)) {
            query["DownloadDataType"] = request.downloadDataType;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.fileConfigShrink)) {
            query["FileConfig"] = request.fileConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.tableName)) {
            query["TableName"] = request.tableName;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateDownloadDataJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDownloadDataJobResponse({}));
    }
    async createDownloadDataJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDownloadDataJobWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users share the quota of the Alibaba Cloud account.
      *
      * @param request CreateEdgeDriverRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateEdgeDriverResponse
     */
    async createEdgeDriverWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.cpuArch)) {
            query["CpuArch"] = request.cpuArch;
        }
        if (!tea_util_1.default.isUnset(request.driverName)) {
            query["DriverName"] = request.driverName;
        }
        if (!tea_util_1.default.isUnset(request.driverProtocol)) {
            query["DriverProtocol"] = request.driverProtocol;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.isBuiltIn)) {
            query["IsBuiltIn"] = request.isBuiltIn;
        }
        if (!tea_util_1.default.isUnset(request.runtime)) {
            query["Runtime"] = request.runtime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateEdgeDriver",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateEdgeDriverResponse({}));
    }
    /**
      * ## Limits
      * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users share the quota of the Alibaba Cloud account.
      *
      * @param request CreateEdgeDriverRequest
      * @return CreateEdgeDriverResponse
     */
    async createEdgeDriver(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createEdgeDriverWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateEdgeDriverVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateEdgeDriverVersionResponse
     */
    async createEdgeDriverVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.argument)) {
            query["Argument"] = request.argument;
        }
        if (!tea_util_1.default.isUnset(request.configCheckRule)) {
            query["ConfigCheckRule"] = request.configCheckRule;
        }
        if (!tea_util_1.default.isUnset(request.containerConfig)) {
            query["ContainerConfig"] = request.containerConfig;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.driverConfig)) {
            query["DriverConfig"] = request.driverConfig;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.driverVersion)) {
            query["DriverVersion"] = request.driverVersion;
        }
        if (!tea_util_1.default.isUnset(request.edgeVersion)) {
            query["EdgeVersion"] = request.edgeVersion;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.sourceConfig)) {
            query["SourceConfig"] = request.sourceConfig;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateEdgeDriverVersion",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateEdgeDriverVersionResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateEdgeDriverVersionRequest
      * @return CreateEdgeDriverVersionResponse
     */
    async createEdgeDriverVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createEdgeDriverVersionWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users share the quota of the Alibaba Cloud account.
      *
      * @param request CreateEdgeInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateEdgeInstanceResponse
     */
    async createEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.spec)) {
            query["Spec"] = request.spec;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            query["Tags"] = request.tags;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateEdgeInstanceResponse({}));
    }
    /**
      * ## Limits
      * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users share the quota of the Alibaba Cloud account.
      *
      * @param request CreateEdgeInstanceRequest
      * @return CreateEdgeInstanceResponse
     */
    async createEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createEdgeInstanceWithOptions(request, runtime);
    }
    async createEdgeInstanceChannelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.channelName)) {
            query["ChannelName"] = request.channelName;
        }
        if (!tea_util_1.default.isUnset(request.configs)) {
            query["Configs"] = request.configs;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateEdgeInstanceChannel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateEdgeInstanceChannelResponse({}));
    }
    async createEdgeInstanceChannel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createEdgeInstanceChannelWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateEdgeInstanceDeploymentRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateEdgeInstanceDeploymentResponse
     */
    async createEdgeInstanceDeploymentWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateEdgeInstanceDeployment",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateEdgeInstanceDeploymentResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateEdgeInstanceDeploymentRequest
      * @return CreateEdgeInstanceDeploymentResponse
     */
    async createEdgeInstanceDeployment(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createEdgeInstanceDeploymentWithOptions(request, runtime);
    }
    async createEdgeInstanceMessageRoutingWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.sourceData)) {
            query["SourceData"] = request.sourceData;
        }
        if (!tea_util_1.default.isUnset(request.sourceType)) {
            query["SourceType"] = request.sourceType;
        }
        if (!tea_util_1.default.isUnset(request.targetData)) {
            query["TargetData"] = request.targetData;
        }
        if (!tea_util_1.default.isUnset(request.targetIotHubQos)) {
            query["TargetIotHubQos"] = request.targetIotHubQos;
        }
        if (!tea_util_1.default.isUnset(request.targetType)) {
            query["TargetType"] = request.targetType;
        }
        if (!tea_util_1.default.isUnset(request.topicFilter)) {
            query["TopicFilter"] = request.topicFilter;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateEdgeInstanceMessageRouting",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateEdgeInstanceMessageRoutingResponse({}));
    }
    async createEdgeInstanceMessageRouting(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createEdgeInstanceMessageRoutingWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateEdgeOssPreSignedAddressRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateEdgeOssPreSignedAddressResponse
     */
    async createEdgeOssPreSignedAddressWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.fileName)) {
            query["FileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceId)) {
            query["ResourceId"] = request.resourceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceVersion)) {
            query["ResourceVersion"] = request.resourceVersion;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateEdgeOssPreSignedAddress",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateEdgeOssPreSignedAddressResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateEdgeOssPreSignedAddressRequest
      * @return CreateEdgeOssPreSignedAddressResponse
     */
    async createEdgeOssPreSignedAddress(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createEdgeOssPreSignedAddressWithOptions(request, runtime);
    }
    async createJobWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateJobShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.jobFile)) {
            request.jobFileShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.jobFile, "JobFile", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.rolloutConfig)) {
            request.rolloutConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.rolloutConfig, "RolloutConfig", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.targetConfig)) {
            request.targetConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.targetConfig, "TargetConfig", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.timeoutConfig)) {
            request.timeoutConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.timeoutConfig, "TimeoutConfig", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobDocument)) {
            query["JobDocument"] = request.jobDocument;
        }
        if (!tea_util_1.default.isUnset(request.jobFileShrink)) {
            query["JobFile"] = request.jobFileShrink;
        }
        if (!tea_util_1.default.isUnset(request.jobName)) {
            query["JobName"] = request.jobName;
        }
        if (!tea_util_1.default.isUnset(request.rolloutConfigShrink)) {
            query["RolloutConfig"] = request.rolloutConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.scheduledTime)) {
            query["ScheduledTime"] = request.scheduledTime;
        }
        if (!tea_util_1.default.isUnset(request.targetConfigShrink)) {
            query["TargetConfig"] = request.targetConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.timeoutConfigShrink)) {
            query["TimeoutConfig"] = request.timeoutConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateJobResponse({}));
    }
    async createJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createJobWithOptions(request, runtime);
    }
    async createLoRaNodesTaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceInfo)) {
            query["DeviceInfo"] = request.deviceInfo;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateLoRaNodesTask",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateLoRaNodesTaskResponse({}));
    }
    async createLoRaNodesTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createLoRaNodesTaskWithOptions(request, runtime);
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common parameters](~~30561~~).
      *
      * @param request CreateOTADynamicUpgradeJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateOTADynamicUpgradeJobResponse
     */
    async createOTADynamicUpgradeJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.downloadProtocol)) {
            query["DownloadProtocol"] = request.downloadProtocol;
        }
        if (!tea_util_1.default.isUnset(request.dynamicMode)) {
            query["DynamicMode"] = request.dynamicMode;
        }
        if (!tea_util_1.default.isUnset(request.firmwareId)) {
            query["FirmwareId"] = request.firmwareId;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.groupType)) {
            query["GroupType"] = request.groupType;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.maximumPerMinute)) {
            query["MaximumPerMinute"] = request.maximumPerMinute;
        }
        if (!tea_util_1.default.isUnset(request.multiModuleMode)) {
            query["MultiModuleMode"] = request.multiModuleMode;
        }
        if (!tea_util_1.default.isUnset(request.needConfirm)) {
            query["NeedConfirm"] = request.needConfirm;
        }
        if (!tea_util_1.default.isUnset(request.needPush)) {
            query["NeedPush"] = request.needPush;
        }
        if (!tea_util_1.default.isUnset(request.overwriteMode)) {
            query["OverwriteMode"] = request.overwriteMode;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.retryCount)) {
            query["RetryCount"] = request.retryCount;
        }
        if (!tea_util_1.default.isUnset(request.retryInterval)) {
            query["RetryInterval"] = request.retryInterval;
        }
        if (!tea_util_1.default.isUnset(request.srcVersion)) {
            query["SrcVersion"] = request.srcVersion;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        if (!tea_util_1.default.isUnset(request.timeoutInMinutes)) {
            query["TimeoutInMinutes"] = request.timeoutInMinutes;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateOTADynamicUpgradeJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateOTADynamicUpgradeJobResponse({}));
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common parameters](~~30561~~).
      *
      * @param request CreateOTADynamicUpgradeJobRequest
      * @return CreateOTADynamicUpgradeJobResponse
     */
    async createOTADynamicUpgradeJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createOTADynamicUpgradeJobWithOptions(request, runtime);
    }
    /**
      * Before you call this operation to create an OTA update package, you must call the [GenerateOTAUploadURL](~~147310~~) operation to generate the information about the files that you want to add to the OTA update package and call the Object Storage Service (OSS) [PostObject](~~31988~~) operation to upload the files.
      * ## Limits
      * Each Alibaba Cloud account can have up to 500 update packages.
      * ## QPS limits
      * You can call this API operation up to 10 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateOTAFirmwareRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateOTAFirmwareResponse
     */
    async createOTAFirmwareWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.destVersion)) {
            query["DestVersion"] = request.destVersion;
        }
        if (!tea_util_1.default.isUnset(request.firmwareDesc)) {
            query["FirmwareDesc"] = request.firmwareDesc;
        }
        if (!tea_util_1.default.isUnset(request.firmwareName)) {
            query["FirmwareName"] = request.firmwareName;
        }
        if (!tea_util_1.default.isUnset(request.firmwareSign)) {
            query["FirmwareSign"] = request.firmwareSign;
        }
        if (!tea_util_1.default.isUnset(request.firmwareSize)) {
            query["FirmwareSize"] = request.firmwareSize;
        }
        if (!tea_util_1.default.isUnset(request.firmwareUrl)) {
            query["FirmwareUrl"] = request.firmwareUrl;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.moduleName)) {
            query["ModuleName"] = request.moduleName;
        }
        if (!tea_util_1.default.isUnset(request.multiFiles)) {
            query["MultiFiles"] = request.multiFiles;
        }
        if (!tea_util_1.default.isUnset(request.needToVerify)) {
            query["NeedToVerify"] = request.needToVerify;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.signMethod)) {
            query["SignMethod"] = request.signMethod;
        }
        if (!tea_util_1.default.isUnset(request.srcVersion)) {
            query["SrcVersion"] = request.srcVersion;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.udi)) {
            query["Udi"] = request.udi;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateOTAFirmware",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateOTAFirmwareResponse({}));
    }
    /**
      * Before you call this operation to create an OTA update package, you must call the [GenerateOTAUploadURL](~~147310~~) operation to generate the information about the files that you want to add to the OTA update package and call the Object Storage Service (OSS) [PostObject](~~31988~~) operation to upload the files.
      * ## Limits
      * Each Alibaba Cloud account can have up to 500 update packages.
      * ## QPS limits
      * You can call this API operation up to 10 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateOTAFirmwareRequest
      * @return CreateOTAFirmwareResponse
     */
    async createOTAFirmware(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createOTAFirmwareWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * OTA modules are the updatable units of the devices that belong to the same product. The default module indicates the entire firmware of a device. You can call this operation to create a custom OTA module.
      * *   You can create a maximum of 10 custom OTA modules for each product.
      * *   After an OTA module is created, you cannot modify its name. You can call the [UpdateOTAModule](~~186061~~) operation to modify the module alias and description.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateOTAModuleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateOTAModuleResponse
     */
    async createOTAModuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.aliasName)) {
            query["AliasName"] = request.aliasName;
        }
        if (!tea_util_1.default.isUnset(request.desc)) {
            query["Desc"] = request.desc;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.moduleName)) {
            query["ModuleName"] = request.moduleName;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateOTAModule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateOTAModuleResponse({}));
    }
    /**
      * ## Limits
      * OTA modules are the updatable units of the devices that belong to the same product. The default module indicates the entire firmware of a device. You can call this operation to create a custom OTA module.
      * *   You can create a maximum of 10 custom OTA modules for each product.
      * *   After an OTA module is created, you cannot modify its name. You can call the [UpdateOTAModule](~~186061~~) operation to modify the module alias and description.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateOTAModuleRequest
      * @return CreateOTAModuleResponse
     */
    async createOTAModule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createOTAModuleWithOptions(request, runtime);
    }
    /**
      * *   If you specify that an update package does not need to be verified when you call the [CreateOTAFirmware](~~147311~~) operation, you must make sure that the update package is verified before you call the CreateOTAStaticUpgradeJob operation to create an update batch. For more information about how to create a task to verify an update package, see [CreateOTAVerifyJob](~~147480~~).
      * *   You can initiate update tasks for a maximum of 200 devices in each call. If you use a device list file, you can initiate update tasks for a maximum of 1,000,000 devices. However, you must call the [GenerateDeviceNameListURL](~~186062~~) operation to generate a URL for the device list file. Then, you can perform the operations as prompted to upload the device list file.
      * *   When you initiate update tasks for multiple devices, the devices that already have the destination firmware versions are skipped.
      * *   Each device can be in the pending or updating status only in one update task. If you initiate another update task for a device that is in the pending or updating status, the update task fails.
      * *   You can create multiple static update batches by using a single update package.
      * *   Downloading update packages through the MQTT protocol is supported only in the China (Shanghai) region.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateOTAStaticUpgradeJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateOTAStaticUpgradeJobResponse
     */
    async createOTAStaticUpgradeJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dnListFileUrl)) {
            query["DnListFileUrl"] = request.dnListFileUrl;
        }
        if (!tea_util_1.default.isUnset(request.downloadProtocol)) {
            query["DownloadProtocol"] = request.downloadProtocol;
        }
        if (!tea_util_1.default.isUnset(request.firmwareId)) {
            query["FirmwareId"] = request.firmwareId;
        }
        if (!tea_util_1.default.isUnset(request.grayPercent)) {
            query["GrayPercent"] = request.grayPercent;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.groupType)) {
            query["GroupType"] = request.groupType;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.maximumPerMinute)) {
            query["MaximumPerMinute"] = request.maximumPerMinute;
        }
        if (!tea_util_1.default.isUnset(request.multiModuleMode)) {
            query["MultiModuleMode"] = request.multiModuleMode;
        }
        if (!tea_util_1.default.isUnset(request.needConfirm)) {
            query["NeedConfirm"] = request.needConfirm;
        }
        if (!tea_util_1.default.isUnset(request.needPush)) {
            query["NeedPush"] = request.needPush;
        }
        if (!tea_util_1.default.isUnset(request.overwriteMode)) {
            query["OverwriteMode"] = request.overwriteMode;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.retryCount)) {
            query["RetryCount"] = request.retryCount;
        }
        if (!tea_util_1.default.isUnset(request.retryInterval)) {
            query["RetryInterval"] = request.retryInterval;
        }
        if (!tea_util_1.default.isUnset(request.scheduleFinishTime)) {
            query["ScheduleFinishTime"] = request.scheduleFinishTime;
        }
        if (!tea_util_1.default.isUnset(request.scheduleTime)) {
            query["ScheduleTime"] = request.scheduleTime;
        }
        if (!tea_util_1.default.isUnset(request.srcVersion)) {
            query["SrcVersion"] = request.srcVersion;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        if (!tea_util_1.default.isUnset(request.targetDeviceName)) {
            query["TargetDeviceName"] = request.targetDeviceName;
        }
        if (!tea_util_1.default.isUnset(request.targetSelection)) {
            query["TargetSelection"] = request.targetSelection;
        }
        if (!tea_util_1.default.isUnset(request.timeoutInMinutes)) {
            query["TimeoutInMinutes"] = request.timeoutInMinutes;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateOTAStaticUpgradeJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateOTAStaticUpgradeJobResponse({}));
    }
    /**
      * *   If you specify that an update package does not need to be verified when you call the [CreateOTAFirmware](~~147311~~) operation, you must make sure that the update package is verified before you call the CreateOTAStaticUpgradeJob operation to create an update batch. For more information about how to create a task to verify an update package, see [CreateOTAVerifyJob](~~147480~~).
      * *   You can initiate update tasks for a maximum of 200 devices in each call. If you use a device list file, you can initiate update tasks for a maximum of 1,000,000 devices. However, you must call the [GenerateDeviceNameListURL](~~186062~~) operation to generate a URL for the device list file. Then, you can perform the operations as prompted to upload the device list file.
      * *   When you initiate update tasks for multiple devices, the devices that already have the destination firmware versions are skipped.
      * *   Each device can be in the pending or updating status only in one update task. If you initiate another update task for a device that is in the pending or updating status, the update task fails.
      * *   You can create multiple static update batches by using a single update package.
      * *   Downloading update packages through the MQTT protocol is supported only in the China (Shanghai) region.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateOTAStaticUpgradeJobRequest
      * @return CreateOTAStaticUpgradeJobResponse
     */
    async createOTAStaticUpgradeJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createOTAStaticUpgradeJobWithOptions(request, runtime);
    }
    /**
      * *   You must verify an update package before you push the package to devices for a batch update. Only verified update packages can be used to update devices in batches. You can call the [QueryOTAFirmware](~~147461~~) operation to view the status of a verification task.
      * *   You cannot initiate a verification task for an update package that is being verified or has been verified.
      * *   You can specify a maximum of 10 devices for a verification task.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateOTAVerifyJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateOTAVerifyJobResponse
     */
    async createOTAVerifyJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.downloadProtocol)) {
            query["DownloadProtocol"] = request.downloadProtocol;
        }
        if (!tea_util_1.default.isUnset(request.firmwareId)) {
            query["FirmwareId"] = request.firmwareId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.needConfirm)) {
            query["NeedConfirm"] = request.needConfirm;
        }
        if (!tea_util_1.default.isUnset(request.needPush)) {
            query["NeedPush"] = request.needPush;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        if (!tea_util_1.default.isUnset(request.targetDeviceName)) {
            query["TargetDeviceName"] = request.targetDeviceName;
        }
        if (!tea_util_1.default.isUnset(request.timeoutInMinutes)) {
            query["TimeoutInMinutes"] = request.timeoutInMinutes;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateOTAVerifyJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateOTAVerifyJobResponse({}));
    }
    /**
      * *   You must verify an update package before you push the package to devices for a batch update. Only verified update packages can be used to update devices in batches. You can call the [QueryOTAFirmware](~~147461~~) operation to view the status of a verification task.
      * *   You cannot initiate a verification task for an update package that is being verified or has been verified.
      * *   You can specify a maximum of 10 devices for a verification task.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateOTAVerifyJobRequest
      * @return CreateOTAVerifyJobResponse
     */
    async createOTAVerifyJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createOTAVerifyJobWithOptions(request, runtime);
    }
    async createParserWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateParser",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateParserResponse({}));
    }
    async createParser(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createParserWithOptions(request, runtime);
    }
    async createParserDataSourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateParserDataSource",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateParserDataSourceResponse({}));
    }
    async createParserDataSource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createParserDataSourceWithOptions(request, runtime);
    }
    /**
      * If a Thing Specification Language (TSL) model is required to create a product, you must set the **AliyunCommodityCode** parameter to iothub_senior and configure the **DataFormat** parameter.******** For more information, see the "**Request parameters**" section of this topic.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateProductRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateProductResponse
     */
    async createProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.aliyunCommodityCode)) {
            query["AliyunCommodityCode"] = request.aliyunCommodityCode;
        }
        if (!tea_util_1.default.isUnset(request.authType)) {
            query["AuthType"] = request.authType;
        }
        if (!tea_util_1.default.isUnset(request.categoryKey)) {
            query["CategoryKey"] = request.categoryKey;
        }
        if (!tea_util_1.default.isUnset(request.dataFormat)) {
            query["DataFormat"] = request.dataFormat;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.id2)) {
            query["Id2"] = request.id2;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.joinPermissionId)) {
            query["JoinPermissionId"] = request.joinPermissionId;
        }
        if (!tea_util_1.default.isUnset(request.netType)) {
            query["NetType"] = request.netType;
        }
        if (!tea_util_1.default.isUnset(request.nodeType)) {
            query["NodeType"] = request.nodeType;
        }
        if (!tea_util_1.default.isUnset(request.productName)) {
            query["ProductName"] = request.productName;
        }
        if (!tea_util_1.default.isUnset(request.protocolType)) {
            query["ProtocolType"] = request.protocolType;
        }
        if (!tea_util_1.default.isUnset(request.publishAuto)) {
            query["PublishAuto"] = request.publishAuto;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.validateType)) {
            query["ValidateType"] = request.validateType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateProduct",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateProductResponse({}));
    }
    /**
      * If a Thing Specification Language (TSL) model is required to create a product, you must set the **AliyunCommodityCode** parameter to iothub_senior and configure the **DataFormat** parameter.******** For more information, see the "**Request parameters**" section of this topic.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateProductRequest
      * @return CreateProductResponse
     */
    async createProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createProductWithOptions(request, runtime);
    }
    /**
      * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * *   You cannot call this operation to distribute a product across accounts.
      * *   A product distribution task does not distribute the devices under the product.
      * *   After a product is distributed, you cannot modify its TSL model and scripts.
      * *   Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a device distribution task, see [CreateDeviceDistributeJob](~~199390~~).
      * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
      *     **
      *     **Note** RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateProductDistributeJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateProductDistributeJobResponse
     */
    async createProductDistributeJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.sourceInstanceId)) {
            query["SourceInstanceId"] = request.sourceInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.targetAliyunId)) {
            query["TargetAliyunId"] = request.targetAliyunId;
        }
        if (!tea_util_1.default.isUnset(request.targetInstanceId)) {
            query["TargetInstanceId"] = request.targetInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.targetUid)) {
            query["TargetUid"] = request.targetUid;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateProductDistributeJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateProductDistributeJobResponse({}));
    }
    /**
      * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * *   You cannot call this operation to distribute a product across accounts.
      * *   A product distribution task does not distribute the devices under the product.
      * *   After a product is distributed, you cannot modify its TSL model and scripts.
      * *   Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a device distribution task, see [CreateDeviceDistributeJob](~~199390~~).
      * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
      *     **
      *     **Note** RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateProductDistributeJobRequest
      * @return CreateProductDistributeJobResponse
     */
    async createProductDistributeJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createProductDistributeJobWithOptions(request, runtime);
    }
    /**
      * *   You can create a maximum of 10 tags for a product in a single call.
      * *   Each product can have a maximum of 100 tags.
      * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
      * ## QPS limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateProductTagsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateProductTagsResponse
     */
    async createProductTagsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.productTag)) {
            query["ProductTag"] = request.productTag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateProductTags",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateProductTagsResponse({}));
    }
    /**
      * *   You can create a maximum of 10 tags for a product in a single call.
      * *   Each product can have a maximum of 100 tags.
      * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
      * ## QPS limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateProductTagsRequest
      * @return CreateProductTagsResponse
     */
    async createProductTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createProductTagsWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 1 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateProductTopicRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateProductTopicResponse
     */
    async createProductTopicWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.codec)) {
            query["Codec"] = request.codec;
        }
        if (!tea_util_1.default.isUnset(request.desc)) {
            query["Desc"] = request.desc;
        }
        if (!tea_util_1.default.isUnset(request.enableProxySubscribe)) {
            query["EnableProxySubscribe"] = request.enableProxySubscribe;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.operation)) {
            query["Operation"] = request.operation;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.topicShortName)) {
            query["TopicShortName"] = request.topicShortName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateProductTopic",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateProductTopicResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 1 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateProductTopicRequest
      * @return CreateProductTopicResponse
     */
    async createProductTopic(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createProductTopicWithOptions(request, runtime);
    }
    /**
      * When you call this operation, you must specify the **ProductKey** parameter in the request.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateRuleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateRuleResponse
     */
    async createRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dataType)) {
            query["DataType"] = request.dataType;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.ruleDesc)) {
            query["RuleDesc"] = request.ruleDesc;
        }
        if (!tea_util_1.default.isUnset(request.select)) {
            query["Select"] = request.select;
        }
        if (!tea_util_1.default.isUnset(request.shortTopic)) {
            query["ShortTopic"] = request.shortTopic;
        }
        if (!tea_util_1.default.isUnset(request.topic)) {
            query["Topic"] = request.topic;
        }
        if (!tea_util_1.default.isUnset(request.topicType)) {
            query["TopicType"] = request.topicType;
        }
        if (!tea_util_1.default.isUnset(request.where)) {
            query["Where"] = request.where;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateRuleResponse({}));
    }
    /**
      * When you call this operation, you must specify the **ProductKey** parameter in the request.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateRuleRequest
      * @return CreateRuleResponse
     */
    async createRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createRuleWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   Destination Alibaba Cloud services that are supported by the rules engine vary based on regions. For more information about the regions and destination cloud services that are supported by the rules engine, see [Regions and zones](~~85669~~).
      * *   You can create a maximum of 10 rule actions for each rule.
      * *   You can call this API operation to define rule actions to forward data to an IoT Platform topic, AMQP consumer group, or Alibaba Cloud service. The supported Alibaba Cloud services include Message Service (MNS), Function Compute, and Tablestore. If you need to forward data to ApsaraDB RDS, you must use the [IoT Platform console](https://iot.console.aliyun.com).
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateRuleActionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateRuleActionResponse
     */
    async createRuleActionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.configuration)) {
            query["Configuration"] = request.configuration;
        }
        if (!tea_util_1.default.isUnset(request.errorActionFlag)) {
            query["ErrorActionFlag"] = request.errorActionFlag;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateRuleAction",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateRuleActionResponse({}));
    }
    /**
      * ## Limits
      * *   Destination Alibaba Cloud services that are supported by the rules engine vary based on regions. For more information about the regions and destination cloud services that are supported by the rules engine, see [Regions and zones](~~85669~~).
      * *   You can create a maximum of 10 rule actions for each rule.
      * *   You can call this API operation to define rule actions to forward data to an IoT Platform topic, AMQP consumer group, or Alibaba Cloud service. The supported Alibaba Cloud services include Message Service (MNS), Function Compute, and Tablestore. If you need to forward data to ApsaraDB RDS, you must use the [IoT Platform console](https://iot.console.aliyun.com).
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateRuleActionRequest
      * @return CreateRuleActionResponse
     */
    async createRuleAction(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createRuleActionWithOptions(request, runtime);
    }
    async createSceneRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleContent)) {
            query["RuleContent"] = request.ruleContent;
        }
        if (!tea_util_1.default.isUnset(request.ruleDescription)) {
            query["RuleDescription"] = request.ruleDescription;
        }
        if (!tea_util_1.default.isUnset(request.ruleName)) {
            query["RuleName"] = request.ruleName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateSceneRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateSceneRuleResponse({}));
    }
    async createSceneRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createSceneRuleWithOptions(request, runtime);
    }
    async createSchedulePeriodWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.scheduleCode)) {
            body["ScheduleCode"] = request.scheduleCode;
        }
        if (!tea_util_1.default.isUnset(request.soundCodeContent)) {
            body["SoundCodeContent"] = request.soundCodeContent;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateSchedulePeriod",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateSchedulePeriodResponse({}));
    }
    async createSchedulePeriod(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createSchedulePeriodWithOptions(request, runtime);
    }
    async createSoundCodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.duration)) {
            body["Duration"] = request.duration;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.openType)) {
            body["OpenType"] = request.openType;
        }
        if (!tea_util_1.default.isUnset(request.soundCodeContent)) {
            body["SoundCodeContent"] = request.soundCodeContent;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateSoundCode",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateSoundCodeResponse({}));
    }
    async createSoundCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createSoundCodeWithOptions(request, runtime);
    }
    async createSoundCodeLabelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.label)) {
            body["Label"] = request.label;
        }
        if (!tea_util_1.default.isUnset(request.scheduleCode)) {
            body["ScheduleCode"] = request.scheduleCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateSoundCodeLabel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateSoundCodeLabelResponse({}));
    }
    async createSoundCodeLabel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createSoundCodeLabelWithOptions(request, runtime);
    }
    async createSoundCodeScheduleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.endDate)) {
            body["EndDate"] = request.endDate;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.openType)) {
            body["OpenType"] = request.openType;
        }
        if (!tea_util_1.default.isUnset(request.startDate)) {
            body["StartDate"] = request.startDate;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateSoundCodeSchedule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateSoundCodeScheduleResponse({}));
    }
    async createSoundCodeSchedule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createSoundCodeScheduleWithOptions(request, runtime);
    }
    async createSpeechWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateSpeechShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.soundCodeConfig)) {
            request.soundCodeConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.soundCodeConfig, "SoundCodeConfig", "json");
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.audioFormat)) {
            body["AudioFormat"] = request.audioFormat;
        }
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            body["BizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.enableSoundCode)) {
            body["EnableSoundCode"] = request.enableSoundCode;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectCode)) {
            body["ProjectCode"] = request.projectCode;
        }
        if (!tea_util_1.default.isUnset(request.soundCodeConfigShrink)) {
            body["SoundCodeConfig"] = request.soundCodeConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.speechRate)) {
            body["SpeechRate"] = request.speechRate;
        }
        if (!tea_util_1.default.isUnset(request.speechType)) {
            body["SpeechType"] = request.speechType;
        }
        if (!tea_util_1.default.isUnset(request.text)) {
            body["Text"] = request.text;
        }
        if (!tea_util_1.default.isUnset(request.voice)) {
            body["Voice"] = request.voice;
        }
        if (!tea_util_1.default.isUnset(request.volume)) {
            body["Volume"] = request.volume;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateSpeech",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateSpeechResponse({}));
    }
    async createSpeech(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createSpeechWithOptions(request, runtime);
    }
    async createStudioAppDomainOpenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["AppId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.host)) {
            body["Host"] = request.host;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        if (!tea_util_1.default.isUnset(request.protocol)) {
            body["Protocol"] = request.protocol;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateStudioAppDomainOpen",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateStudioAppDomainOpenResponse({}));
    }
    async createStudioAppDomainOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createStudioAppDomainOpenWithOptions(request, runtime);
    }
    /**
      * Server-side subscriptions are categorized into the following two types:
      * *   MNS subscription: pushes subscribed messages to MNS queues. Your server applications listen to MNS queues to receive device messages. For more information, see [Configure MNS server-side subscriptions](~~68948~~). You can call this operation to create an MNS subscription.
      * *   AMQP subscription: pushes subscribed messages to your server by using the AMQP channel. For more information, see [Configure AMQP server-side subscriptions](~~142376~~). To configure an AMQP subscription, perform the following steps:
      *     1\\. Call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group and obtain the returned consumer group ID. Messages are pushed to the consumer group. The AMQP client carries the consumer group ID when the client connected to IoT Platform. For more information, see [Connect an AMQP client to IoT Platform](~~142489~~).
      *     2\\. Call the CreateSubscribeRelation operation to create an AMQP subscription.
      *     3\\. Optional. Call the [CreateConsumerGroupSubscribeRelation](~~170354~~) operation to add a consumer group to the AMQP subscription. You can also call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove a consumer group from an AMQP subscription.
      *     4\\. Optional. Call the [QueryConsumerGroupStatus](~~170358~~) operation to query the status of a consumer group, including online client information, message consumption rate, number of accumulated messages, and last message consumption time. You can also call the [ResetConsumerGroupPosition](~~170355~~) operation to clear the accumulated messages of the consumer group.
      * ## QPS limits
      * You can call this API operation up to five times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateSubscribeRelationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateSubscribeRelationResponse
     */
    async createSubscribeRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.consumerGroupIds)) {
            query["ConsumerGroupIds"] = request.consumerGroupIds;
        }
        if (!tea_util_1.default.isUnset(request.deviceDataFlag)) {
            query["DeviceDataFlag"] = request.deviceDataFlag;
        }
        if (!tea_util_1.default.isUnset(request.deviceLifeCycleFlag)) {
            query["DeviceLifeCycleFlag"] = request.deviceLifeCycleFlag;
        }
        if (!tea_util_1.default.isUnset(request.deviceStatusChangeFlag)) {
            query["DeviceStatusChangeFlag"] = request.deviceStatusChangeFlag;
        }
        if (!tea_util_1.default.isUnset(request.deviceTagFlag)) {
            query["DeviceTagFlag"] = request.deviceTagFlag;
        }
        if (!tea_util_1.default.isUnset(request.deviceTopoLifeCycleFlag)) {
            query["DeviceTopoLifeCycleFlag"] = request.deviceTopoLifeCycleFlag;
        }
        if (!tea_util_1.default.isUnset(request.foundDeviceListFlag)) {
            query["FoundDeviceListFlag"] = request.foundDeviceListFlag;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.mnsConfiguration)) {
            query["MnsConfiguration"] = request.mnsConfiguration;
        }
        if (!tea_util_1.default.isUnset(request.otaEventFlag)) {
            query["OtaEventFlag"] = request.otaEventFlag;
        }
        if (!tea_util_1.default.isUnset(request.otaJobFlag)) {
            query["OtaJobFlag"] = request.otaJobFlag;
        }
        if (!tea_util_1.default.isUnset(request.otaVersionFlag)) {
            query["OtaVersionFlag"] = request.otaVersionFlag;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.subscribeFlags)) {
            query["SubscribeFlags"] = request.subscribeFlags;
        }
        if (!tea_util_1.default.isUnset(request.thingHistoryFlag)) {
            query["ThingHistoryFlag"] = request.thingHistoryFlag;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateSubscribeRelation",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateSubscribeRelationResponse({}));
    }
    /**
      * Server-side subscriptions are categorized into the following two types:
      * *   MNS subscription: pushes subscribed messages to MNS queues. Your server applications listen to MNS queues to receive device messages. For more information, see [Configure MNS server-side subscriptions](~~68948~~). You can call this operation to create an MNS subscription.
      * *   AMQP subscription: pushes subscribed messages to your server by using the AMQP channel. For more information, see [Configure AMQP server-side subscriptions](~~142376~~). To configure an AMQP subscription, perform the following steps:
      *     1\\. Call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group and obtain the returned consumer group ID. Messages are pushed to the consumer group. The AMQP client carries the consumer group ID when the client connected to IoT Platform. For more information, see [Connect an AMQP client to IoT Platform](~~142489~~).
      *     2\\. Call the CreateSubscribeRelation operation to create an AMQP subscription.
      *     3\\. Optional. Call the [CreateConsumerGroupSubscribeRelation](~~170354~~) operation to add a consumer group to the AMQP subscription. You can also call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove a consumer group from an AMQP subscription.
      *     4\\. Optional. Call the [QueryConsumerGroupStatus](~~170358~~) operation to query the status of a consumer group, including online client information, message consumption rate, number of accumulated messages, and last message consumption time. You can also call the [ResetConsumerGroupPosition](~~170355~~) operation to clear the accumulated messages of the consumer group.
      * ## QPS limits
      * You can call this API operation up to five times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateSubscribeRelationRequest
      * @return CreateSubscribeRelationResponse
     */
    async createSubscribeRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createSubscribeRelationWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
      * *   Before you call the operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
      * *   You can call this operation to add a maximum of 10 TSL features. TSL features include properties, services, and events.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateThingModelRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateThingModelResponse
     */
    async createThingModelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.functionBlockName)) {
            query["FunctionBlockName"] = request.functionBlockName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.thingModelJson)) {
            query["ThingModelJson"] = request.thingModelJson;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateThingModel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateThingModelResponse({}));
    }
    /**
      * ## Limits
      * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
      * *   Before you call the operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
      * *   You can call this operation to add a maximum of 10 TSL features. TSL features include properties, services, and events.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateThingModelRequest
      * @return CreateThingModelResponse
     */
    async createThingModel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createThingModelWithOptions(request, runtime);
    }
    /**
      * A data parsing script is used to convert data submitted by devices into the JSON format. The data submitted by devices is in a custom format. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
      * > If the data format is **Alink JSON**, the CreateThingScript operation is not supported. Alink JSON is a standard data format that is defined by IoT Connectivity Alliance (ICA).
      * ## QPS limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateThingScriptRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateThingScriptResponse
     */
    async createThingScriptWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.scriptContent)) {
            query["ScriptContent"] = request.scriptContent;
        }
        if (!tea_util_1.default.isUnset(request.scriptType)) {
            query["ScriptType"] = request.scriptType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateThingScript",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateThingScriptResponse({}));
    }
    /**
      * A data parsing script is used to convert data submitted by devices into the JSON format. The data submitted by devices is in a custom format. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
      * > If the data format is **Alink JSON**, the CreateThingScript operation is not supported. Alink JSON is a standard data format that is defined by IoT Connectivity Alliance (ICA).
      * ## QPS limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateThingScriptRequest
      * @return CreateThingScriptResponse
     */
    async createThingScript(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createThingScriptWithOptions(request, runtime);
    }
    async createTopicConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.codec)) {
            query["Codec"] = request.codec;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.enableBroadcast)) {
            query["EnableBroadcast"] = request.enableBroadcast;
        }
        if (!tea_util_1.default.isUnset(request.enableProxySubscribe)) {
            query["EnableProxySubscribe"] = request.enableProxySubscribe;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.operation)) {
            query["Operation"] = request.operation;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.topicFullName)) {
            query["TopicFullName"] = request.topicFullName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateTopicConfig",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateTopicConfigResponse({}));
    }
    async createTopicConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createTopicConfigWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You can specify a maximum of 100 destination topics for a source topic.
      * *   The device to which the source topic belongs must be activated.
      * *   The source and destination topics support only custom topics.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateTopicRouteTableRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateTopicRouteTableResponse
     */
    async createTopicRouteTableWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dstTopic)) {
            query["DstTopic"] = request.dstTopic;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.srcTopic)) {
            query["SrcTopic"] = request.srcTopic;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateTopicRouteTable",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateTopicRouteTableResponse({}));
    }
    /**
      * ## Limits
      * *   You can specify a maximum of 100 destination topics for a source topic.
      * *   The device to which the source topic belongs must be activated.
      * *   The source and destination topics support only custom topics.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request CreateTopicRouteTableRequest
      * @return CreateTopicRouteTableResponse
     */
    async createTopicRouteTable(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createTopicRouteTableWithOptions(request, runtime);
    }
    /**
      * *   You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device and obtain the number of ClientIDs.
      * *   After you call the DeleteClientIds operation, all ClientIDs of the device are deleted and cannot be resumed. To obtain a new ClientID, you can register the device again.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteClientIdsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteClientIdsResponse
     */
    async deleteClientIdsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteClientIds",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteClientIdsResponse({}));
    }
    /**
      * *   You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device and obtain the number of ClientIDs.
      * *   After you call the DeleteClientIds operation, all ClientIDs of the device are deleted and cannot be resumed. To obtain a new ClientID, you can register the device again.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteClientIdsRequest
      * @return DeleteClientIdsResponse
     */
    async deleteClientIds(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteClientIdsWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You cannot delete the default consumer group provided by IoT Platform.
      * *   If the consumer group is associated with an AMQP subscription, you must disassociate the consumer group from the subscription. If the subscription has multiple consumer groups, you can call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove the consumer group from the subscription. If the subscription has only one consumer group, you can call the [UpdateSubscribeRelation](~~170351~~) operation to change the consumer group or call the [DeleteSubscribeRelation](~~170353~~) operation to delete the subscription.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteConsumerGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteConsumerGroupResponse
     */
    async deleteConsumerGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteConsumerGroup",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteConsumerGroupResponse({}));
    }
    /**
      * ## Limits
      * *   You cannot delete the default consumer group provided by IoT Platform.
      * *   If the consumer group is associated with an AMQP subscription, you must disassociate the consumer group from the subscription. If the subscription has multiple consumer groups, you can call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove the consumer group from the subscription. If the subscription has only one consumer group, you can call the [UpdateSubscribeRelation](~~170351~~) operation to change the consumer group or call the [DeleteSubscribeRelation](~~170353~~) operation to delete the subscription.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteConsumerGroupRequest
      * @return DeleteConsumerGroupResponse
     */
    async deleteConsumerGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteConsumerGroupWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   If the AMQP subscription has only one consumer group, you cannot call this operation to remove the consumer group.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteConsumerGroupSubscribeRelationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteConsumerGroupSubscribeRelationResponse
     */
    async deleteConsumerGroupSubscribeRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.consumerGroupId)) {
            query["ConsumerGroupId"] = request.consumerGroupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteConsumerGroupSubscribeRelation",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteConsumerGroupSubscribeRelationResponse({}));
    }
    /**
      * ## Limits
      * *   If the AMQP subscription has only one consumer group, you cannot call this operation to remove the consumer group.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteConsumerGroupSubscribeRelationRequest
      * @return DeleteConsumerGroupSubscribeRelationResponse
     */
    async deleteConsumerGroupSubscribeRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteConsumerGroupSubscribeRelationWithOptions(request, runtime);
    }
    async deleteDataSourceItemWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dataSourceId)) {
            query["DataSourceId"] = request.dataSourceId;
        }
        if (!tea_util_1.default.isUnset(request.dataSourceItemId)) {
            query["DataSourceItemId"] = request.dataSourceItemId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDataSourceItem",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDataSourceItemResponse({}));
    }
    async deleteDataSourceItem(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDataSourceItemWithOptions(request, runtime);
    }
    async deleteDestinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.destinationId)) {
            query["DestinationId"] = request.destinationId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDestination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDestinationResponse({}));
    }
    async deleteDestination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDestinationWithOptions(request, runtime);
    }
    /**
      * *   When you call this operation with an Alibaba Cloud account, IoT Platform sends a verification code by text message to confirm your identity.
      * *   When you call this operation with a RAM user, IoT Platform does not send a verification code. To ensure device security, you can create custom permission policies to perform fine-grained permission management. For more information, see [Mapping of IoT Platform operations and RAM policies](~~47485~~) and [Custom permissions](~~47495~~).
      * **Warning**
      * *   After a device is deleted, the device ID (**IotId**) becomes invalid, and all other information associated with the device is deleted. In addition, you can no longer perform an operation on the device.
      * *   Before you delete a device in the IoT Platform console, make sure that the corresponding actual device is offline. Otherwise, after the device is deleted from IoT Platform, the actual device continues to initiate connection requests to IoT Platform. If the number of requests exceeds the upper limit, IoT Platform starts request throttling. In this case, access of other devices within your Alibaba Cloud account is affected.
      * *   After you delete a device, the certificate of the device becomes invalid and cannot be restored. Proceed with caution.
      * ****
      * *   You must specify a value for the **IotId** parameter or values for the **ProductKey** and **DeviceName** parameters to identify a device.
      * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDeviceResponse
     */
    async deleteDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDeviceResponse({}));
    }
    /**
      * *   When you call this operation with an Alibaba Cloud account, IoT Platform sends a verification code by text message to confirm your identity.
      * *   When you call this operation with a RAM user, IoT Platform does not send a verification code. To ensure device security, you can create custom permission policies to perform fine-grained permission management. For more information, see [Mapping of IoT Platform operations and RAM policies](~~47485~~) and [Custom permissions](~~47495~~).
      * **Warning**
      * *   After a device is deleted, the device ID (**IotId**) becomes invalid, and all other information associated with the device is deleted. In addition, you can no longer perform an operation on the device.
      * *   Before you delete a device in the IoT Platform console, make sure that the corresponding actual device is offline. Otherwise, after the device is deleted from IoT Platform, the actual device continues to initiate connection requests to IoT Platform. If the number of requests exceeds the upper limit, IoT Platform starts request throttling. In this case, access of other devices within your Alibaba Cloud account is affected.
      * *   After you delete a device, the certificate of the device becomes invalid and cannot be restored. Proceed with caution.
      * ****
      * *   You must specify a value for the **IotId** parameter or values for the **ProductKey** and **DeviceName** parameters to identify a device.
      * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteDeviceRequest
      * @return DeleteDeviceResponse
     */
    async deleteDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDeviceWithOptions(request, runtime);
    }
    /**
      * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteDeviceDistributeJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDeviceDistributeJobResponse
     */
    async deleteDeviceDistributeJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDeviceDistributeJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDeviceDistributeJobResponse({}));
    }
    /**
      * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteDeviceDistributeJobRequest
      * @return DeleteDeviceDistributeJobResponse
     */
    async deleteDeviceDistributeJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDeviceDistributeJobWithOptions(request, runtime);
    }
    async deleteDeviceDynamicGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDeviceDynamicGroup",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDeviceDynamicGroupResponse({}));
    }
    async deleteDeviceDynamicGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDeviceDynamicGroupWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteDeviceFileRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDeviceFileResponse
     */
    async deleteDeviceFileWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.fileId)) {
            query["FileId"] = request.fileId;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDeviceFile",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDeviceFileResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteDeviceFileRequest
      * @return DeleteDeviceFileResponse
     */
    async deleteDeviceFile(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDeviceFileWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteDeviceGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDeviceGroupResponse
     */
    async deleteDeviceGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDeviceGroup",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDeviceGroupResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteDeviceGroupRequest
      * @return DeleteDeviceGroupResponse
     */
    async deleteDeviceGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDeviceGroupWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteDevicePropRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDevicePropResponse
     */
    async deleteDevicePropWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.propKey)) {
            query["PropKey"] = request.propKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDeviceProp",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDevicePropResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteDevicePropRequest
      * @return DeleteDevicePropResponse
     */
    async deleteDeviceProp(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDevicePropWithOptions(request, runtime);
    }
    async deleteDeviceSpeechWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceSpeechList)) {
            body["DeviceSpeechList"] = request.deviceSpeechList;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDeviceSpeech",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDeviceSpeechResponse({}));
    }
    async deleteDeviceSpeech(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDeviceSpeechWithOptions(request, runtime);
    }
    async deleteDeviceTunnelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.tunnelId)) {
            query["TunnelId"] = request.tunnelId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDeviceTunnel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDeviceTunnelResponse({}));
    }
    async deleteDeviceTunnel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDeviceTunnelWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You are not allowed to delete a driver that has a published version.
      * *   Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteEdgeDriverRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteEdgeDriverResponse
     */
    async deleteEdgeDriverWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteEdgeDriver",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteEdgeDriverResponse({}));
    }
    /**
      * ## Limits
      * *   You are not allowed to delete a driver that has a published version.
      * *   Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteEdgeDriverRequest
      * @return DeleteEdgeDriverResponse
     */
    async deleteEdgeDriver(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteEdgeDriverWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You are not allowed to delete a published driver version.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteEdgeDriverVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteEdgeDriverVersionResponse
     */
    async deleteEdgeDriverVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.driverVersion)) {
            query["DriverVersion"] = request.driverVersion;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteEdgeDriverVersion",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteEdgeDriverVersionResponse({}));
    }
    /**
      * ## Limits
      * *   You are not allowed to delete a published driver version.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteEdgeDriverVersionRequest
      * @return DeleteEdgeDriverVersionResponse
     */
    async deleteEdgeDriverVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteEdgeDriverVersionWithOptions(request, runtime);
    }
    /**
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteEdgeInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteEdgeInstanceResponse
     */
    async deleteEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteEdgeInstanceResponse({}));
    }
    /**
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteEdgeInstanceRequest
      * @return DeleteEdgeInstanceResponse
     */
    async deleteEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteEdgeInstanceWithOptions(request, runtime);
    }
    async deleteEdgeInstanceMessageRoutingWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.routeId)) {
            query["RouteId"] = request.routeId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteEdgeInstanceMessageRouting",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteEdgeInstanceMessageRoutingResponse({}));
    }
    async deleteEdgeInstanceMessageRouting(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteEdgeInstanceMessageRoutingWithOptions(request, runtime);
    }
    async deleteJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteJobResponse({}));
    }
    async deleteJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteJobWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteOTAFirmwareRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteOTAFirmwareResponse
     */
    async deleteOTAFirmwareWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.firmwareId)) {
            query["FirmwareId"] = request.firmwareId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteOTAFirmware",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteOTAFirmwareResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteOTAFirmwareRequest
      * @return DeleteOTAFirmwareResponse
     */
    async deleteOTAFirmware(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteOTAFirmwareWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   The default module cannot be deleted.
      * *   If an update package exists in an OTA module, you cannot delete the OTA module.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteOTAModuleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteOTAModuleResponse
     */
    async deleteOTAModuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.moduleName)) {
            query["ModuleName"] = request.moduleName;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteOTAModule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteOTAModuleResponse({}));
    }
    /**
      * ## Limits
      * *   The default module cannot be deleted.
      * *   If an update package exists in an OTA module, you cannot delete the OTA module.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteOTAModuleRequest
      * @return DeleteOTAModuleResponse
     */
    async deleteOTAModule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteOTAModuleWithOptions(request, runtime);
    }
    async deleteParserWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteParser",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteParserResponse({}));
    }
    async deleteParser(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteParserWithOptions(request, runtime);
    }
    async deleteParserDataSourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dataSourceId)) {
            query["DataSourceId"] = request.dataSourceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteParserDataSource",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteParserDataSourceResponse({}));
    }
    async deleteParserDataSource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteParserDataSourceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   After a product is deleted, the ProductKey of the product is invalid. The related information about the product is also deleted. You cannot perform the required operations on the product.
      * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteProductRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteProductResponse
     */
    async deleteProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteProduct",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteProductResponse({}));
    }
    /**
      * ## Limits
      * *   After a product is deleted, the ProductKey of the product is invalid. The related information about the product is also deleted. You cannot perform the required operations on the product.
      * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteProductRequest
      * @return DeleteProductResponse
     */
    async deleteProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteProductWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You can delete a maximum of 10 tags in a single call.
      * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteProductTagsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteProductTagsResponse
     */
    async deleteProductTagsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.productTagKey)) {
            query["ProductTagKey"] = request.productTagKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteProductTags",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteProductTagsResponse({}));
    }
    /**
      * ## Limits
      * *   You can delete a maximum of 10 tags in a single call.
      * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteProductTagsRequest
      * @return DeleteProductTagsResponse
     */
    async deleteProductTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteProductTagsWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteProductTopicRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteProductTopicResponse
     */
    async deleteProductTopicWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.topicId)) {
            query["TopicId"] = request.topicId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteProductTopic",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteProductTopicResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteProductTopicRequest
      * @return DeleteProductTopicResponse
     */
    async deleteProductTopic(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteProductTopicWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteRuleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteRuleResponse
     */
    async deleteRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteRuleResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteRuleRequest
      * @return DeleteRuleResponse
     */
    async deleteRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteRuleWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteRuleActionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteRuleActionResponse
     */
    async deleteRuleActionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.actionId)) {
            query["ActionId"] = request.actionId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteRuleAction",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteRuleActionResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteRuleActionRequest
      * @return DeleteRuleActionResponse
     */
    async deleteRuleAction(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteRuleActionWithOptions(request, runtime);
    }
    async deleteSceneRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteSceneRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSceneRuleResponse({}));
    }
    async deleteSceneRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteSceneRuleWithOptions(request, runtime);
    }
    async deleteSchedulePeriodWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.periodCode)) {
            body["PeriodCode"] = request.periodCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteSchedulePeriod",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSchedulePeriodResponse({}));
    }
    async deleteSchedulePeriod(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteSchedulePeriodWithOptions(request, runtime);
    }
    async deleteShareTaskDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotIdList)) {
            body["IotIdList"] = request.iotIdList;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.shareTaskId)) {
            body["ShareTaskId"] = request.shareTaskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteShareTaskDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteShareTaskDeviceResponse({}));
    }
    async deleteShareTaskDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteShareTaskDeviceWithOptions(request, runtime);
    }
    async deleteSoundCodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.soundCode)) {
            body["SoundCode"] = request.soundCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteSoundCode",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSoundCodeResponse({}));
    }
    async deleteSoundCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteSoundCodeWithOptions(request, runtime);
    }
    async deleteSoundCodeLabelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.soundCode)) {
            body["SoundCode"] = request.soundCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteSoundCodeLabel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSoundCodeLabelResponse({}));
    }
    async deleteSoundCodeLabel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteSoundCodeLabelWithOptions(request, runtime);
    }
    async deleteSoundCodeScheduleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.scheduleCode)) {
            body["ScheduleCode"] = request.scheduleCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteSoundCodeSchedule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSoundCodeScheduleResponse({}));
    }
    async deleteSoundCodeSchedule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteSoundCodeScheduleWithOptions(request, runtime);
    }
    async deleteSpeechWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.speechCodeList)) {
            body["SpeechCodeList"] = request.speechCodeList;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteSpeech",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSpeechResponse({}));
    }
    async deleteSpeech(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteSpeechWithOptions(request, runtime);
    }
    async deleteStudioAppDomainOpenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["AppId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.domainId)) {
            body["DomainId"] = request.domainId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteStudioAppDomainOpen",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteStudioAppDomainOpenResponse({}));
    }
    async deleteStudioAppDomainOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteStudioAppDomainOpenWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteSubscribeRelationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteSubscribeRelationResponse
     */
    async deleteSubscribeRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteSubscribeRelation",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSubscribeRelationResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteSubscribeRelationRequest
      * @return DeleteSubscribeRelationResponse
     */
    async deleteSubscribeRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteSubscribeRelationWithOptions(request, runtime);
    }
    /**
      * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call the DeleteThingModel operation.
      * *   If an existing feature or custom TSL module in a product is not published, you can call the DeleteThingModel operation to remove the feature or delete the custom TSL module.
      * *   When you call the DeleteThingModel operation, you must specify a value for the **ProductKey** parameter. The following list describes how the DeleteThingModel operation works:
      *     *   If you specify a value only for the **ProductKey** parameter, the operation deletes all custom TSL modules and removes all features in the default TSL module from the specified product.
      *     *   If you specify values only for the **ProductKey** and **FunctionBlockId** parameters, the operation deletes the specified custom TSL module from the specified product.
      *     *   If you specify a value for the **ProductKey** parameter and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from the default TSL module of the specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist in the default TSL module, the operation returns the same result as when you specify a value only for the **ProductKey** parameter.
      *     *   If you specify values for the **ProductKey** and **FunctionBlockId** parameters and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from a specified custom TSL module in a specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist, the operation returns the same result as when you specify values only for the **ProductKey** and **FunctionBlockId** parameters.
      * > You must specify up to 10 identifiers for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter.
      * *   After you call the DeleteThingModel operation to remove one or more features from a product, you must call the [PublishThingModel](~~150311~~) operation to re-publish the TSL model of the product. This way, the change takes effect.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 5 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request DeleteThingModelRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteThingModelResponse
     */
    async deleteThingModelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.eventIdentifier)) {
            query["EventIdentifier"] = request.eventIdentifier;
        }
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.propertyIdentifier)) {
            query["PropertyIdentifier"] = request.propertyIdentifier;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.serviceIdentifier)) {
            query["ServiceIdentifier"] = request.serviceIdentifier;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteThingModel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteThingModelResponse({}));
    }
    /**
      * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call the DeleteThingModel operation.
      * *   If an existing feature or custom TSL module in a product is not published, you can call the DeleteThingModel operation to remove the feature or delete the custom TSL module.
      * *   When you call the DeleteThingModel operation, you must specify a value for the **ProductKey** parameter. The following list describes how the DeleteThingModel operation works:
      *     *   If you specify a value only for the **ProductKey** parameter, the operation deletes all custom TSL modules and removes all features in the default TSL module from the specified product.
      *     *   If you specify values only for the **ProductKey** and **FunctionBlockId** parameters, the operation deletes the specified custom TSL module from the specified product.
      *     *   If you specify a value for the **ProductKey** parameter and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from the default TSL module of the specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist in the default TSL module, the operation returns the same result as when you specify a value only for the **ProductKey** parameter.
      *     *   If you specify values for the **ProductKey** and **FunctionBlockId** parameters and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from a specified custom TSL module in a specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist, the operation returns the same result as when you specify values only for the **ProductKey** and **FunctionBlockId** parameters.
      * > You must specify up to 10 identifiers for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter.
      * *   After you call the DeleteThingModel operation to remove one or more features from a product, you must call the [PublishThingModel](~~150311~~) operation to re-publish the TSL model of the product. This way, the change takes effect.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 5 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request DeleteThingModelRequest
      * @return DeleteThingModelResponse
     */
    async deleteThingModel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteThingModelWithOptions(request, runtime);
    }
    async deleteTopicConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.topicFullName)) {
            query["TopicFullName"] = request.topicFullName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteTopicConfig",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteTopicConfigResponse({}));
    }
    async deleteTopicConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteTopicConfigWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteTopicRouteTableRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteTopicRouteTableResponse
     */
    async deleteTopicRouteTableWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dstTopic)) {
            query["DstTopic"] = request.dstTopic;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.srcTopic)) {
            query["SrcTopic"] = request.srcTopic;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteTopicRouteTable",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteTopicRouteTableResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DeleteTopicRouteTableRequest
      * @return DeleteTopicRouteTableResponse
     */
    async deleteTopicRouteTable(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteTopicRouteTableWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request DetachDestinationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DetachDestinationResponse
     */
    async detachDestinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.destinationId)) {
            query["DestinationId"] = request.destinationId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DetachDestination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DetachDestinationResponse({}));
    }
    /**
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request DetachDestinationRequest
      * @return DetachDestinationResponse
     */
    async detachDestination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.detachDestinationWithOptions(request, runtime);
    }
    async detachParserDataSourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dataSourceId)) {
            query["DataSourceId"] = request.dataSourceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DetachParserDataSource",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DetachParserDataSourceResponse({}));
    }
    async detachParserDataSource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.detachParserDataSourceWithOptions(request, runtime);
    }
    async disableDeviceTunnelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DisableDeviceTunnel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DisableDeviceTunnelResponse({}));
    }
    async disableDeviceTunnel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.disableDeviceTunnelWithOptions(request, runtime);
    }
    async disableDeviceTunnelShareWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DisableDeviceTunnelShare",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DisableDeviceTunnelShareResponse({}));
    }
    async disableDeviceTunnelShare(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.disableDeviceTunnelShareWithOptions(request, runtime);
    }
    async disableSceneRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DisableSceneRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DisableSceneRuleResponse({}));
    }
    async disableSceneRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.disableSceneRuleWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   After a device is disabled, you cannot connect the device to IoT Platform. You can perform device-specific operations on the device. However, the information about the device is still retained in IoT Platform. You can use the [EnableThing](~~69603~~) API operation to connect the disabled device to IoT Platform again.
      * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DisableThingRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DisableThingResponse
     */
    async disableThingWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DisableThing",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DisableThingResponse({}));
    }
    /**
      * ## Limits
      * *   After a device is disabled, you cannot connect the device to IoT Platform. You can perform device-specific operations on the device. However, the information about the device is still retained in IoT Platform. You can use the [EnableThing](~~69603~~) API operation to connect the disabled device to IoT Platform again.
      * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request DisableThingRequest
      * @return DisableThingResponse
     */
    async disableThing(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.disableThingWithOptions(request, runtime);
    }
    async enableDeviceTunnelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "EnableDeviceTunnel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new EnableDeviceTunnelResponse({}));
    }
    async enableDeviceTunnel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.enableDeviceTunnelWithOptions(request, runtime);
    }
    async enableDeviceTunnelShareWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "EnableDeviceTunnelShare",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new EnableDeviceTunnelShareResponse({}));
    }
    async enableDeviceTunnelShare(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.enableDeviceTunnelShareWithOptions(request, runtime);
    }
    async enableSceneRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "EnableSceneRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new EnableSceneRuleResponse({}));
    }
    async enableSceneRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.enableSceneRuleWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request EnableThingRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return EnableThingResponse
     */
    async enableThingWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "EnableThing",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new EnableThingResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request EnableThingRequest
      * @return EnableThingResponse
     */
    async enableThing(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.enableThingWithOptions(request, runtime);
    }
    /**
      * This operation can be used with other operations to upload a device list file. Procedure:
      * 1. Call this operation to generate the information of a device list file that you want to upload to OSS.
      * The response parameters of this API operation include:
      * The following request parameters of the OSS [PostObject](/help/en/object-storage-service/latest/postobject) operation that is used to upload the device list file: **Key**, **AccessKeyId**, **Signature**, and **Policy**.
      * 2. Use an [OSS SDK](/help/en/object-storage-service/latest/sdk-code-samples-overview) to call the [PostObject](/help/en/object-storage-service/latest/postobject) operation to upload the device list file within 1 minute after a response is returned. For more information about sample code, see the "Usage of response parameters" section in this topic.
      * >  The parameter information that is returned by this operation is valid for 1 minute. You must upload the device list file within 1 minute.  3. After you upload the device list file, call the [CreateOTAStaticUpgradeJob](/help/en/iot-platform/latest/e1qtmo) operation of IoT Platform to create a static update batch within 60 minutes.
      * If you upload device list files but you do not call the CreateOTAStaticUpgradeJob operation to create a static update batch, the system automatically deletes the uploaded files. The system deletes files on a regular basis.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      * ## Requirements
      * *   A device list file contains the names of devices. Separate multiple device names with line feeds. Each line contains only one device name. A device list file must be in the CSV format. The maximum size of a device list file is 5 MB.
      * *   Each device list file can contain up to 10,000 names for the devices in a product that is related to an update package. If the number of device names in a device list file exceeds the limit, an error occurs when you use the file to create a static update batch.
      *
      * @param request GenerateDeviceNameListURLRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GenerateDeviceNameListURLResponse
     */
    async generateDeviceNameListURLWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GenerateDeviceNameListURL",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GenerateDeviceNameListURLResponse({}));
    }
    /**
      * This operation can be used with other operations to upload a device list file. Procedure:
      * 1. Call this operation to generate the information of a device list file that you want to upload to OSS.
      * The response parameters of this API operation include:
      * The following request parameters of the OSS [PostObject](/help/en/object-storage-service/latest/postobject) operation that is used to upload the device list file: **Key**, **AccessKeyId**, **Signature**, and **Policy**.
      * 2. Use an [OSS SDK](/help/en/object-storage-service/latest/sdk-code-samples-overview) to call the [PostObject](/help/en/object-storage-service/latest/postobject) operation to upload the device list file within 1 minute after a response is returned. For more information about sample code, see the "Usage of response parameters" section in this topic.
      * >  The parameter information that is returned by this operation is valid for 1 minute. You must upload the device list file within 1 minute.  3. After you upload the device list file, call the [CreateOTAStaticUpgradeJob](/help/en/iot-platform/latest/e1qtmo) operation of IoT Platform to create a static update batch within 60 minutes.
      * If you upload device list files but you do not call the CreateOTAStaticUpgradeJob operation to create a static update batch, the system automatically deletes the uploaded files. The system deletes files on a regular basis.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      * ## Requirements
      * *   A device list file contains the names of devices. Separate multiple device names with line feeds. Each line contains only one device name. A device list file must be in the CSV format. The maximum size of a device list file is 5 MB.
      * *   Each device list file can contain up to 10,000 names for the devices in a product that is related to an update package. If the number of device names in a device list file exceeds the limit, an error occurs when you use the file to create a static update batch.
      *
      * @param request GenerateDeviceNameListURLRequest
      * @return GenerateDeviceNameListURLResponse
     */
    async generateDeviceNameListURL(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.generateDeviceNameListURLWithOptions(request, runtime);
    }
    async generateFileUploadURLWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["BizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.fileName)) {
            query["FileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.fileSuffix)) {
            query["FileSuffix"] = request.fileSuffix;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GenerateFileUploadURL",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GenerateFileUploadURLResponse({}));
    }
    async generateFileUploadURL(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.generateFileUploadURLWithOptions(request, runtime);
    }
    /**
      * This operation can be used together with other operations to create an update package. Procedure:
      * 1\\. Call this API operation to generate the details of an update package file that you want to upload to OSS.
      * The following section describes the response parameters of this API operation:
      * *   The following request parameters of the OSS [PostObject](~~31988~~) operation that is used to upload the update package file: **Key**, **OSSAccessKeyId**, **Signature**, and **Policy**.
      * *   The following request parameter of the [CreateOTAFirmware](~~147311~~) operation that is used to create the update package: **FirmwareUrl**.
      * 2\\. Use an [OSS SDK](~~52834~~) to call the [PostObject](~~31988~~) operation to upload the update package file. For more information about sample code, see the "Usage of response parameters" section.
      * > The parameter information that is returned by this operation is valid for 1 minute. You must upload the update package file within 1 minute. The maximum size of the uploaded update package file is 1,000 MB.
      * 3\\. After the update package file is uploaded, call the [CreateOTAFirmware](~~147311~~) operation to create an update package within 60 minutes.
      * If update package files are uploaded but you do not call the CreateOTAFirmware operation to create update packages for the files, the uploaded files are automatically deleted by the system on a regular basis.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request GenerateOTAUploadURLRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GenerateOTAUploadURLResponse
     */
    async generateOTAUploadURLWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.fileSuffix)) {
            query["FileSuffix"] = request.fileSuffix;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GenerateOTAUploadURL",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GenerateOTAUploadURLResponse({}));
    }
    /**
      * This operation can be used together with other operations to create an update package. Procedure:
      * 1\\. Call this API operation to generate the details of an update package file that you want to upload to OSS.
      * The following section describes the response parameters of this API operation:
      * *   The following request parameters of the OSS [PostObject](~~31988~~) operation that is used to upload the update package file: **Key**, **OSSAccessKeyId**, **Signature**, and **Policy**.
      * *   The following request parameter of the [CreateOTAFirmware](~~147311~~) operation that is used to create the update package: **FirmwareUrl**.
      * 2\\. Use an [OSS SDK](~~52834~~) to call the [PostObject](~~31988~~) operation to upload the update package file. For more information about sample code, see the "Usage of response parameters" section.
      * > The parameter information that is returned by this operation is valid for 1 minute. You must upload the update package file within 1 minute. The maximum size of the uploaded update package file is 1,000 MB.
      * 3\\. After the update package file is uploaded, call the [CreateOTAFirmware](~~147311~~) operation to create an update package within 60 minutes.
      * If update package files are uploaded but you do not call the CreateOTAFirmware operation to create update packages for the files, the uploaded files are automatically deleted by the system on a regular basis.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request GenerateOTAUploadURLRequest
      * @return GenerateOTAUploadURLResponse
     */
    async generateOTAUploadURL(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.generateOTAUploadURLWithOptions(request, runtime);
    }
    async getDataAPIServiceDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.apiSrn)) {
            body["ApiSrn"] = request.apiSrn;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetDataAPIServiceDetail",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetDataAPIServiceDetailResponse({}));
    }
    async getDataAPIServiceDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getDataAPIServiceDetailWithOptions(request, runtime);
    }
    async getDestinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.destinationId)) {
            query["DestinationId"] = request.destinationId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDestination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetDestinationResponse({}));
    }
    async getDestination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getDestinationWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * You can call this API operation up to 500 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetDeviceShadowRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetDeviceShadowResponse
     */
    async getDeviceShadowWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDeviceShadow",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetDeviceShadowResponse({}));
    }
    /**
      * ## QPS limits
      * You can call this API operation up to 500 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetDeviceShadowRequest
      * @return GetDeviceShadowResponse
     */
    async getDeviceShadow(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getDeviceShadowWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetDeviceStatusRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetDeviceStatusResponse
     */
    async getDeviceStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDeviceStatus",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetDeviceStatusResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetDeviceStatusRequest
      * @return GetDeviceStatusResponse
     */
    async getDeviceStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getDeviceStatusWithOptions(request, runtime);
    }
    async getDeviceTunnelShareStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDeviceTunnelShareStatus",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetDeviceTunnelShareStatusResponse({}));
    }
    async getDeviceTunnelShareStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getDeviceTunnelShareStatusWithOptions(request, runtime);
    }
    async getDeviceTunnelStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDeviceTunnelStatus",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetDeviceTunnelStatusResponse({}));
    }
    async getDeviceTunnelStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getDeviceTunnelStatusWithOptions(request, runtime);
    }
    async getDownloadFileWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new GetDownloadFileShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.context)) {
            request.contextShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.context, "Context", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.longJobId)) {
            query["LongJobId"] = request.longJobId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.contextShrink)) {
            body["Context"] = request.contextShrink;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetDownloadFile",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetDownloadFileResponse({}));
    }
    async getDownloadFile(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getDownloadFileWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetEdgeDriverVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetEdgeDriverVersionResponse
     */
    async getEdgeDriverVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.driverVersion)) {
            query["DriverVersion"] = request.driverVersion;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetEdgeDriverVersion",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetEdgeDriverVersionResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetEdgeDriverVersionRequest
      * @return GetEdgeDriverVersionResponse
     */
    async getEdgeDriverVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getEdgeDriverVersionWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetEdgeInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetEdgeInstanceResponse
     */
    async getEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetEdgeInstanceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetEdgeInstanceRequest
      * @return GetEdgeInstanceResponse
     */
    async getEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getEdgeInstanceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetEdgeInstanceDeploymentRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetEdgeInstanceDeploymentResponse
     */
    async getEdgeInstanceDeploymentWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deploymentId)) {
            query["DeploymentId"] = request.deploymentId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetEdgeInstanceDeployment",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetEdgeInstanceDeploymentResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetEdgeInstanceDeploymentRequest
      * @return GetEdgeInstanceDeploymentResponse
     */
    async getEdgeInstanceDeployment(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getEdgeInstanceDeploymentWithOptions(request, runtime);
    }
    async getEdgeInstanceMessageRoutingWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.routeId)) {
            query["RouteId"] = request.routeId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetEdgeInstanceMessageRouting",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetEdgeInstanceMessageRoutingResponse({}));
    }
    async getEdgeInstanceMessageRouting(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getEdgeInstanceMessageRoutingWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetGatewayBySubDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetGatewayBySubDeviceResponse
     */
    async getGatewayBySubDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetGatewayBySubDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetGatewayBySubDeviceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetGatewayBySubDeviceRequest
      * @return GetGatewayBySubDeviceResponse
     */
    async getGatewayBySubDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getGatewayBySubDeviceWithOptions(request, runtime);
    }
    async getLoraNodesTaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetLoraNodesTask",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetLoraNodesTaskResponse({}));
    }
    async getLoraNodesTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getLoraNodesTaskWithOptions(request, runtime);
    }
    async getParserWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetParser",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetParserResponse({}));
    }
    async getParser(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getParserWithOptions(request, runtime);
    }
    async getParserDataSourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dataSourceId)) {
            query["DataSourceId"] = request.dataSourceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetParserDataSource",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetParserDataSourceResponse({}));
    }
    async getParserDataSource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getParserDataSourceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetRuleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetRuleResponse
     */
    async getRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetRuleResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetRuleRequest
      * @return GetRuleResponse
     */
    async getRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getRuleWithOptions(request, runtime);
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
      *
      * @param request GetRuleActionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetRuleActionResponse
     */
    async getRuleActionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.actionId)) {
            query["ActionId"] = request.actionId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetRuleAction",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetRuleActionResponse({}));
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
      *
      * @param request GetRuleActionRequest
      * @return GetRuleActionResponse
     */
    async getRuleAction(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getRuleActionWithOptions(request, runtime);
    }
    async getSceneRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetSceneRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetSceneRuleResponse({}));
    }
    async getSceneRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getSceneRuleWithOptions(request, runtime);
    }
    async getShareSpeechModelAudioWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.shareTaskId)) {
            body["ShareTaskId"] = request.shareTaskId;
        }
        if (!tea_util_1.default.isUnset(request.speechModelCodeList)) {
            body["SpeechModelCodeList"] = request.speechModelCodeList;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetShareSpeechModelAudio",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetShareSpeechModelAudioResponse({}));
    }
    async getShareSpeechModelAudio(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getShareSpeechModelAudioWithOptions(request, runtime);
    }
    async getShareTaskByDeviceOpenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetShareTaskByDeviceOpen",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetShareTaskByDeviceOpenResponse({}));
    }
    async getShareTaskByDeviceOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getShareTaskByDeviceOpenWithOptions(request, runtime);
    }
    async getSoundCodeAudioWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.soundCodeList)) {
            body["SoundCodeList"] = request.soundCodeList;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetSoundCodeAudio",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetSoundCodeAudioResponse({}));
    }
    async getSoundCodeAudio(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getSoundCodeAudioWithOptions(request, runtime);
    }
    async getSoundCodeScheduleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.scheduleCode)) {
            body["ScheduleCode"] = request.scheduleCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetSoundCodeSchedule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetSoundCodeScheduleResponse({}));
    }
    async getSoundCodeSchedule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getSoundCodeScheduleWithOptions(request, runtime);
    }
    async getSpeechDeviceDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetSpeechDeviceDetail",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetSpeechDeviceDetailResponse({}));
    }
    async getSpeechDeviceDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getSpeechDeviceDetailWithOptions(request, runtime);
    }
    async getSpeechLicenseDeviceStatisticsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetSpeechLicenseDeviceStatistics",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetSpeechLicenseDeviceStatisticsResponse({}));
    }
    async getSpeechLicenseDeviceStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getSpeechLicenseDeviceStatisticsWithOptions(request, runtime);
    }
    async getSpeechVoiceWithOptions(runtime) {
        let req = new $OpenApi.OpenApiRequest({});
        let params = new $OpenApi.Params({
            action: "GetSpeechVoice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetSpeechVoiceResponse({}));
    }
    async getSpeechVoice() {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getSpeechVoiceWithOptions(runtime);
    }
    async getStudioAppTokenOpenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["AppId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetStudioAppTokenOpen",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetStudioAppTokenOpenResponse({}));
    }
    async getStudioAppTokenOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getStudioAppTokenOpenWithOptions(request, runtime);
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
      *
      * @param request GetThingModelTslRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetThingModelTslResponse
     */
    async getThingModelTslWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.modelVersion)) {
            query["ModelVersion"] = request.modelVersion;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.simple)) {
            query["Simple"] = request.simple;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetThingModelTsl",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetThingModelTslResponse({}));
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
      *
      * @param request GetThingModelTslRequest
      * @return GetThingModelTslResponse
     */
    async getThingModelTsl(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getThingModelTslWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetThingModelTslPublishedRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetThingModelTslPublishedResponse
     */
    async getThingModelTslPublishedWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.modelVersion)) {
            query["ModelVersion"] = request.modelVersion;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.simple)) {
            query["Simple"] = request.simple;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetThingModelTslPublished",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetThingModelTslPublishedResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetThingModelTslPublishedRequest
      * @return GetThingModelTslPublishedResponse
     */
    async getThingModelTslPublished(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getThingModelTslPublishedWithOptions(request, runtime);
    }
    /**
      * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetThingScriptRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetThingScriptResponse
     */
    async getThingScriptWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetThingScript",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetThingScriptResponse({}));
    }
    /**
      * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetThingScriptRequest
      * @return GetThingScriptResponse
     */
    async getThingScript(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getThingScriptWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetThingTemplateRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetThingTemplateResponse
     */
    async getThingTemplateWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.categoryKey)) {
            query["CategoryKey"] = request.categoryKey;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetThingTemplate",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetThingTemplateResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetThingTemplateRequest
      * @return GetThingTemplateResponse
     */
    async getThingTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getThingTemplateWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can initiate a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetThingTopoRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetThingTopoResponse
     */
    async getThingTopoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageNo)) {
            query["PageNo"] = request.pageNo;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetThingTopo",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetThingTopoResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can initiate a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request GetThingTopoRequest
      * @return GetThingTopoResponse
     */
    async getThingTopo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getThingTopoWithOptions(request, runtime);
    }
    async gisQueryDeviceLocationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.thingList)) {
            query["ThingList"] = request.thingList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GisQueryDeviceLocation",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GisQueryDeviceLocationResponse({}));
    }
    async gisQueryDeviceLocation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.gisQueryDeviceLocationWithOptions(request, runtime);
    }
    async gisSearchDeviceTraceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.mapMatch)) {
            query["MapMatch"] = request.mapMatch;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GisSearchDeviceTrace",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GisSearchDeviceTraceResponse({}));
    }
    async gisSearchDeviceTrace(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.gisSearchDeviceTraceWithOptions(request, runtime);
    }
    async importDTDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DTInstanceId)) {
            query["DTInstanceId"] = request.DTInstanceId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.items)) {
            body["Items"] = request.items;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ImportDTData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ImportDTDataResponse({}));
    }
    async importDTData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.importDTDataWithOptions(request, runtime);
    }
    async importDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.deviceSecret)) {
            query["DeviceSecret"] = request.deviceSecret;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nickname)) {
            query["Nickname"] = request.nickname;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.sn)) {
            query["Sn"] = request.sn;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ImportDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ImportDeviceResponse({}));
    }
    async importDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.importDeviceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ImportThingModelTslRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ImportThingModelTslResponse
     */
    async importThingModelTslWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.functionBlockName)) {
            query["FunctionBlockName"] = request.functionBlockName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.tslStr)) {
            query["TslStr"] = request.tslStr;
        }
        if (!tea_util_1.default.isUnset(request.tslUrl)) {
            query["TslUrl"] = request.tslUrl;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ImportThingModelTsl",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ImportThingModelTslResponse({}));
    }
    /**
      * ## Limits
      * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ImportThingModelTslRequest
      * @return ImportThingModelTslResponse
     */
    async importThingModelTsl(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.importThingModelTslWithOptions(request, runtime);
    }
    async invokeDataAPIServiceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.apiSrn)) {
            body["ApiSrn"] = request.apiSrn;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.param)) {
            body["Param"] = request.param;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InvokeDataAPIService",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new InvokeDataAPIServiceResponse({}));
    }
    async invokeDataAPIService(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.invokeDataAPIServiceWithOptions(request, runtime);
    }
    /**
      * When you define a service in a Thing Specification Language (TSL) model, the mode in which the service is called is specified. When you call a service by using this operation, IoT Platform uses a call mode based on the value of the **Identifier** parameter.
      * *   Synchronous mode: IoT Platform sends a revert-remote procedure call (RRPC) request to a device. Then, the device synchronously returns an RRPC response. For more information about how to use an RRPC, see [What is RRPC?](~~90567~~)
      * *   Asynchronous mode: IoT Platform sends an RRPC request to a device. Then, the device asynchronously returns an RRPC response. For more information about topics, see [Device properties, events, and services](~~89301~~).
      * > If you set the Checksum Type parameter to **Verification-free** when you create a product, the asynchronous mode is used.
      * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
      * ```
      * {
      * 	"id": "58***89",
      * 	"code": 200,
      * 	"data": {},
      * 	"message": "success",
      * 	"localizedMsg": "localizedMsg"
      * }
      * ```
      * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and then return the ID.
      * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
      * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can configure the parameters that you want to include in the returned result. The data must be in the JSON format.
      * >*   The **message** and **localizedMsg** parameters are optional.
      * >*   Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
      * ## Limits
      * If you synchronously call a service, the timeout period is 8 seconds. If a server does not receive a response within 8 seconds, a timeout error occurs. No limit is imposed on the timeout period of asynchronous calls.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request InvokeThingServiceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return InvokeThingServiceResponse
     */
    async invokeThingServiceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.args)) {
            query["Args"] = request.args;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "InvokeThingService",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new InvokeThingServiceResponse({}));
    }
    /**
      * When you define a service in a Thing Specification Language (TSL) model, the mode in which the service is called is specified. When you call a service by using this operation, IoT Platform uses a call mode based on the value of the **Identifier** parameter.
      * *   Synchronous mode: IoT Platform sends a revert-remote procedure call (RRPC) request to a device. Then, the device synchronously returns an RRPC response. For more information about how to use an RRPC, see [What is RRPC?](~~90567~~)
      * *   Asynchronous mode: IoT Platform sends an RRPC request to a device. Then, the device asynchronously returns an RRPC response. For more information about topics, see [Device properties, events, and services](~~89301~~).
      * > If you set the Checksum Type parameter to **Verification-free** when you create a product, the asynchronous mode is used.
      * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
      * ```
      * {
      * 	"id": "58***89",
      * 	"code": 200,
      * 	"data": {},
      * 	"message": "success",
      * 	"localizedMsg": "localizedMsg"
      * }
      * ```
      * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and then return the ID.
      * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
      * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can configure the parameters that you want to include in the returned result. The data must be in the JSON format.
      * >*   The **message** and **localizedMsg** parameters are optional.
      * >*   Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
      * ## Limits
      * If you synchronously call a service, the timeout period is 8 seconds. If a server does not receive a response within 8 seconds, a timeout error occurs. No limit is imposed on the timeout period of asynchronous calls.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request InvokeThingServiceRequest
      * @return InvokeThingServiceResponse
     */
    async invokeThingService(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.invokeThingServiceWithOptions(request, runtime);
    }
    /**
      * You can only asynchronously call this operation.
      * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
      * ```
      * {
      * 	"id": "58***89",
      * 	"code": 200,
      * 	"data": {},
      * 	"message": "success",
      * 	"localizedMsg": "localizedMsg"
      * }
      * ```
      * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and return the ID.
      * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
      * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can specify the parameters included in the returned result. The data must be in JSON format.
      * >*   The **message** and **localizedMsg** parameters are optional.
      * >*    Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request InvokeThingsServiceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return InvokeThingsServiceResponse
     */
    async invokeThingsServiceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.args)) {
            query["Args"] = request.args;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "InvokeThingsService",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new InvokeThingsServiceResponse({}));
    }
    /**
      * You can only asynchronously call this operation.
      * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
      * ```
      * {
      * 	"id": "58***89",
      * 	"code": 200,
      * 	"data": {},
      * 	"message": "success",
      * 	"localizedMsg": "localizedMsg"
      * }
      * ```
      * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and return the ID.
      * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
      * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can specify the parameters included in the returned result. The data must be in JSON format.
      * >*   The **message** and **localizedMsg** parameters are optional.
      * >*    Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request InvokeThingsServiceRequest
      * @return InvokeThingsServiceResponse
     */
    async invokeThingsService(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.invokeThingsServiceWithOptions(request, runtime);
    }
    async listAnalyticsDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.apiPath)) {
            query["ApiPath"] = request.apiPath;
        }
        if (!tea_util_1.default.isUnset(request.condition)) {
            query["Condition"] = request.condition;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.isoId)) {
            query["IsoId"] = request.isoId;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListAnalyticsData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListAnalyticsDataResponse({}));
    }
    async listAnalyticsData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listAnalyticsDataWithOptions(request, runtime);
    }
    async listDataSourceItemWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dataSourceId)) {
            query["DataSourceId"] = request.dataSourceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.page)) {
            query["Page"] = request.page;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.searchName)) {
            query["SearchName"] = request.searchName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListDataSourceItem",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListDataSourceItemResponse({}));
    }
    async listDataSourceItem(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listDataSourceItemWithOptions(request, runtime);
    }
    async listDestinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.page)) {
            query["Page"] = request.page;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.searchName)) {
            query["SearchName"] = request.searchName;
        }
        if (!tea_util_1.default.isUnset(request.types)) {
            query["Types"] = request.types;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListDestination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListDestinationResponse({}));
    }
    async listDestination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listDestinationWithOptions(request, runtime);
    }
    /**
      * If you use an Enterprise Edition instance, you must specify the **IotInstanceId** parameter when you call this operation. Otherwise, the call fails.
      * ## QPS limits
      * You can call this API operation up to five times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListDeviceDistributeJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListDeviceDistributeJobResponse
     */
    async listDeviceDistributeJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.targetUid)) {
            query["TargetUid"] = request.targetUid;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.jobId)) {
            body["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ListDeviceDistributeJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListDeviceDistributeJobResponse({}));
    }
    /**
      * If you use an Enterprise Edition instance, you must specify the **IotInstanceId** parameter when you call this operation. Otherwise, the call fails.
      * ## QPS limits
      * You can call this API operation up to five times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListDeviceDistributeJobRequest
      * @return ListDeviceDistributeJobResponse
     */
    async listDeviceDistributeJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listDeviceDistributeJobWithOptions(request, runtime);
    }
    /**
      * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      * *   Multiple Alibaba Cloud accounts can run a maximum of 200 QPS at the same time.
      *
      * @param request ListDistributedDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListDistributedDeviceResponse
     */
    async listDistributedDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.sourceInstanceId)) {
            query["SourceInstanceId"] = request.sourceInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.targetUid)) {
            query["TargetUid"] = request.targetUid;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListDistributedDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListDistributedDeviceResponse({}));
    }
    /**
      * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      * *   Multiple Alibaba Cloud accounts can run a maximum of 200 QPS at the same time.
      *
      * @param request ListDistributedDeviceRequest
      * @return ListDistributedDeviceResponse
     */
    async listDistributedDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listDistributedDeviceWithOptions(request, runtime);
    }
    /**
      * You can call this operation only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * ## QPS limits
      * You can call this API operation up to five times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListDistributedProductRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListDistributedProductResponse
     */
    async listDistributedProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.sourceInstanceId)) {
            query["SourceInstanceId"] = request.sourceInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.targetInstanceId)) {
            query["TargetInstanceId"] = request.targetInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.targetUid)) {
            query["TargetUid"] = request.targetUid;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListDistributedProduct",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListDistributedProductResponse({}));
    }
    /**
      * You can call this operation only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * ## QPS limits
      * You can call this API operation up to five times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListDistributedProductRequest
      * @return ListDistributedProductResponse
     */
    async listDistributedProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listDistributedProductWithOptions(request, runtime);
    }
    async listJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListJobResponse({}));
    }
    async listJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listJobWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAFirmwareRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListOTAFirmwareResponse
     */
    async listOTAFirmwareWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.destVersion)) {
            query["DestVersion"] = request.destVersion;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListOTAFirmware",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListOTAFirmwareResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAFirmwareRequest
      * @return ListOTAFirmwareResponse
     */
    async listOTAFirmware(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listOTAFirmwareWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAJobByDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListOTAJobByDeviceResponse
     */
    async listOTAJobByDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.firmwareId)) {
            query["FirmwareId"] = request.firmwareId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListOTAJobByDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListOTAJobByDeviceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAJobByDeviceRequest
      * @return ListOTAJobByDeviceResponse
     */
    async listOTAJobByDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listOTAJobByDeviceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAJobByFirmwareRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListOTAJobByFirmwareResponse
     */
    async listOTAJobByFirmwareWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.firmwareId)) {
            query["FirmwareId"] = request.firmwareId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListOTAJobByFirmware",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListOTAJobByFirmwareResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAJobByFirmwareRequest
      * @return ListOTAJobByFirmwareResponse
     */
    async listOTAJobByFirmware(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listOTAJobByFirmwareWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAModuleByProductRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListOTAModuleByProductResponse
     */
    async listOTAModuleByProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListOTAModuleByProduct",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "GET",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListOTAModuleByProductResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAModuleByProductRequest
      * @return ListOTAModuleByProductResponse
     */
    async listOTAModuleByProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listOTAModuleByProductWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAModuleVersionsByDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListOTAModuleVersionsByDeviceResponse
     */
    async listOTAModuleVersionsByDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListOTAModuleVersionsByDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListOTAModuleVersionsByDeviceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAModuleVersionsByDeviceRequest
      * @return ListOTAModuleVersionsByDeviceResponse
     */
    async listOTAModuleVersionsByDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listOTAModuleVersionsByDeviceWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request ListOTATaskByJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListOTATaskByJobResponse
     */
    async listOTATaskByJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.deviceNames)) {
            query["DeviceNames"] = request.deviceNames;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.taskStatus)) {
            query["TaskStatus"] = request.taskStatus;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListOTATaskByJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListOTATaskByJobResponse({}));
    }
    /**
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request ListOTATaskByJobRequest
      * @return ListOTATaskByJobResponse
     */
    async listOTATaskByJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listOTATaskByJobWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAUnfinishedTaskByDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListOTAUnfinishedTaskByDeviceResponse
     */
    async listOTAUnfinishedTaskByDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.moduleName)) {
            query["ModuleName"] = request.moduleName;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.taskStatus)) {
            query["TaskStatus"] = request.taskStatus;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListOTAUnfinishedTaskByDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListOTAUnfinishedTaskByDeviceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListOTAUnfinishedTaskByDeviceRequest
      * @return ListOTAUnfinishedTaskByDeviceResponse
     */
    async listOTAUnfinishedTaskByDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listOTAUnfinishedTaskByDeviceWithOptions(request, runtime);
    }
    async listParserWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.searchName)) {
            query["SearchName"] = request.searchName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListParser",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListParserResponse({}));
    }
    async listParser(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listParserWithOptions(request, runtime);
    }
    async listParserDataSourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.page)) {
            query["Page"] = request.page;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.searchName)) {
            query["SearchName"] = request.searchName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListParserDataSource",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListParserDataSourceResponse({}));
    }
    async listParserDataSource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listParserDataSourceWithOptions(request, runtime);
    }
    async listParserDestinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.isFailover)) {
            query["IsFailover"] = request.isFailover;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListParserDestination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListParserDestinationResponse({}));
    }
    async listParserDestination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listParserDestinationWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      * *   You can specify a tag key or a tag key-value pair for search.
      * *   If you specify multiple tags, the logical relationship among these tags is **OR**.
      *
      * @param request ListProductByTagsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListProductByTagsResponse
     */
    async listProductByTagsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productTag)) {
            query["ProductTag"] = request.productTag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListProductByTags",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListProductByTagsResponse({}));
    }
    /**
      * ## Limits
      * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      * *   You can specify a tag key or a tag key-value pair for search.
      * *   If you specify multiple tags, the logical relationship among these tags is **OR**.
      *
      * @param request ListProductByTagsRequest
      * @return ListProductByTagsResponse
     */
    async listProductByTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listProductByTagsWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListProductTagsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListProductTagsResponse
     */
    async listProductTagsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListProductTags",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListProductTagsResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListProductTagsRequest
      * @return ListProductTagsResponse
     */
    async listProductTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listProductTagsWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * You can call this API operation up to 20 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListRuleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListRuleResponse
     */
    async listRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListRuleResponse({}));
    }
    /**
      * ## QPS limits
      * You can call this API operation up to 20 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListRuleRequest
      * @return ListRuleResponse
     */
    async listRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listRuleWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListRuleActionsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListRuleActionsResponse
     */
    async listRuleActionsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListRuleActions",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListRuleActionsResponse({}));
    }
    /**
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListRuleActionsRequest
      * @return ListRuleActionsResponse
     */
    async listRuleActions(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listRuleActionsWithOptions(request, runtime);
    }
    async listTaskWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new ListTaskShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.device)) {
            request.deviceShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.device, "Device", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceShrink)) {
            query["Device"] = request.deviceShrink;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["Limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListTask",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListTaskResponse({}));
    }
    async listTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listTaskWithOptions(request, runtime);
    }
    /**
      * You can manage TSL models by version. After you import a TSL model by calling the [ImportThingModelTsl](~~150320~~) operation, copy a TSL model by calling the [CopyThingModel](~~150322~~) operation, or edit a TSL model, you must publish the TSL model by calling the [PublishThingModel](~~150311~~) operation. Then, the TSL model can be used. Each time a TSL model of a product is published, a new version is generated.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListThingModelVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListThingModelVersionResponse
     */
    async listThingModelVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListThingModelVersion",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListThingModelVersionResponse({}));
    }
    /**
      * You can manage TSL models by version. After you import a TSL model by calling the [ImportThingModelTsl](~~150320~~) operation, copy a TSL model by calling the [CopyThingModel](~~150322~~) operation, or edit a TSL model, you must publish the TSL model by calling the [PublishThingModel](~~150311~~) operation. Then, the TSL model can be used. Each time a TSL model of a product is published, a new version is generated.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListThingModelVersionRequest
      * @return ListThingModelVersionResponse
     */
    async listThingModelVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listThingModelVersionWithOptions(request, runtime);
    }
    /**
      * IoT Platform provides product categories that have defined TSL models, such as street lamps, vehicle location cards, and water immersion detectors.
      * When you call the [CreateProduct](~~69123~~) operation to create a product, you can set the CategoryKey parameter to specify a product category. The product that you create references the standardized TSL model of the specified category.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListThingTemplatesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListThingTemplatesResponse
     */
    async listThingTemplatesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListThingTemplates",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListThingTemplatesResponse({}));
    }
    /**
      * IoT Platform provides product categories that have defined TSL models, such as street lamps, vehicle location cards, and water immersion detectors.
      * When you call the [CreateProduct](~~69123~~) operation to create a product, you can set the CategoryKey parameter to specify a product category. The product that you create references the standardized TSL model of the specified category.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ListThingTemplatesRequest
      * @return ListThingTemplatesResponse
     */
    async listThingTemplates(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listThingTemplatesWithOptions(request, runtime);
    }
    /**
      * A successful response indicates that the command to add topological relationships is sent to the gateway. It does not indicate that the topological relationships are added.
      * When you develop the gateway, you must subscribe to the topic that is used to send notifications when you add topological relationships. For more information about the topic and message format, see [Manage topological relationships](~~89299~~).
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request NotifyAddThingTopoRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return NotifyAddThingTopoResponse
     */
    async notifyAddThingTopoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceListStr)) {
            query["DeviceListStr"] = request.deviceListStr;
        }
        if (!tea_util_1.default.isUnset(request.gwDeviceName)) {
            query["GwDeviceName"] = request.gwDeviceName;
        }
        if (!tea_util_1.default.isUnset(request.gwIotId)) {
            query["GwIotId"] = request.gwIotId;
        }
        if (!tea_util_1.default.isUnset(request.gwProductKey)) {
            query["GwProductKey"] = request.gwProductKey;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "NotifyAddThingTopo",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new NotifyAddThingTopoResponse({}));
    }
    /**
      * A successful response indicates that the command to add topological relationships is sent to the gateway. It does not indicate that the topological relationships are added.
      * When you develop the gateway, you must subscribe to the topic that is used to send notifications when you add topological relationships. For more information about the topic and message format, see [Manage topological relationships](~~89299~~).
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request NotifyAddThingTopoRequest
      * @return NotifyAddThingTopoResponse
     */
    async notifyAddThingTopo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.notifyAddThingTopoWithOptions(request, runtime);
    }
    async openIotServiceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "OpenIotService",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new OpenIotServiceResponse({}));
    }
    async openIotService(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.openIotServiceWithOptions(request, runtime);
    }
    async packageSoundCodeLabelBatchAudioWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.batchCode)) {
            body["BatchCode"] = request.batchCode;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PackageSoundCodeLabelBatchAudio",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PackageSoundCodeLabelBatchAudioResponse({}));
    }
    async packageSoundCodeLabelBatchAudio(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.packageSoundCodeLabelBatchAudioWithOptions(request, runtime);
    }
    async pageQuerySharedSpeechOpenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.shareTaskCode)) {
            body["ShareTaskCode"] = request.shareTaskCode;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["Status"] = request.status;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PageQuerySharedSpeechOpen",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PageQuerySharedSpeechOpenResponse({}));
    }
    async pageQuerySharedSpeechOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.pageQuerySharedSpeechOpenWithOptions(request, runtime);
    }
    async pageQuerySpeechBroadcastHourWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.queryDateTimeHour)) {
            query["QueryDateTimeHour"] = request.queryDateTimeHour;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.pageToken)) {
            body["PageToken"] = request.pageToken;
        }
        if (!tea_util_1.default.isUnset(request.shareTaskCode)) {
            body["ShareTaskCode"] = request.shareTaskCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PageQuerySpeechBroadcastHour",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PageQuerySpeechBroadcastHourResponse({}));
    }
    async pageQuerySpeechBroadcastHour(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.pageQuerySpeechBroadcastHourWithOptions(request, runtime);
    }
    async printByTemplateWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.historyPrintTopic)) {
            body["HistoryPrintTopic"] = request.historyPrintTopic;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.paramsJsonString)) {
            body["ParamsJsonString"] = request.paramsJsonString;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.templateBizCode)) {
            body["TemplateBizCode"] = request.templateBizCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PrintByTemplate",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PrintByTemplateResponse({}));
    }
    async printByTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.printByTemplateWithOptions(request, runtime);
    }
    /**
      * This operation does not support device property settings and service invocations.
      * *   To set properties, call the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation.
      * *   To invoke a service, call the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
      * ## QPS limit
      * You can call this API operation up to 1,600 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request PubRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return PubResponse
     */
    async pubWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.contentType)) {
            query["ContentType"] = request.contentType;
        }
        if (!tea_util_1.default.isUnset(request.correlationData)) {
            query["CorrelationData"] = request.correlationData;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.messageExpiryInterval)) {
            query["MessageExpiryInterval"] = request.messageExpiryInterval;
        }
        if (!tea_util_1.default.isUnset(request.payloadFormatIndicator)) {
            query["PayloadFormatIndicator"] = request.payloadFormatIndicator;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.qos)) {
            query["Qos"] = request.qos;
        }
        if (!tea_util_1.default.isUnset(request.responseTopic)) {
            query["ResponseTopic"] = request.responseTopic;
        }
        if (!tea_util_1.default.isUnset(request.retained)) {
            query["Retained"] = request.retained;
        }
        if (!tea_util_1.default.isUnset(request.topicFullName)) {
            query["TopicFullName"] = request.topicFullName;
        }
        if (!tea_util_1.default.isUnset(request.userProp)) {
            query["UserProp"] = request.userProp;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.messageContent)) {
            body["MessageContent"] = request.messageContent;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "Pub",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PubResponse({}));
    }
    /**
      * This operation does not support device property settings and service invocations.
      * *   To set properties, call the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation.
      * *   To invoke a service, call the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
      * ## QPS limit
      * You can call this API operation up to 1,600 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request PubRequest
      * @return PubResponse
     */
    async pub(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.pubWithOptions(request, runtime);
    }
    /**
      * You can use the **TopicFullName** parameter in the **request** to specify the devices to which you want to broadcast messages. For more information, see the description about the **TopicFullName** parameter in this topic.
      * ## QPS limits
      * - Each Alibaba Cloud account can run only one query per second (QPS) to broadcast a message to devices that subscribe to a topic.
      * - Each Alibaba Cloud account can run only one query per minute (QPM) to broadcast a message to all online devices of a product.      >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request PubBroadcastRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return PubBroadcastResponse
     */
    async pubBroadcastWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.messageContent)) {
            query["MessageContent"] = request.messageContent;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.topicFullName)) {
            query["TopicFullName"] = request.topicFullName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "PubBroadcast",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PubBroadcastResponse({}));
    }
    /**
      * You can use the **TopicFullName** parameter in the **request** to specify the devices to which you want to broadcast messages. For more information, see the description about the **TopicFullName** parameter in this topic.
      * ## QPS limits
      * - Each Alibaba Cloud account can run only one query per second (QPS) to broadcast a message to devices that subscribe to a topic.
      * - Each Alibaba Cloud account can run only one query per minute (QPM) to broadcast a message to all online devices of a product.      >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request PubBroadcastRequest
      * @return PubBroadcastResponse
     */
    async pubBroadcast(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.pubBroadcastWithOptions(request, runtime);
    }
    async publishScriptWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "PublishScript",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PublishScriptResponse({}));
    }
    async publishScript(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.publishScriptWithOptions(request, runtime);
    }
    async publishStudioAppWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["AppId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PublishStudioApp",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PublishStudioAppResponse({}));
    }
    async publishStudioApp(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.publishStudioAppWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request PublishThingModelRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return PublishThingModelResponse
     */
    async publishThingModelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.modelVersion)) {
            query["ModelVersion"] = request.modelVersion;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "PublishThingModel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PublishThingModelResponse({}));
    }
    /**
      * ## Limits
      * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request PublishThingModelRequest
      * @return PublishThingModelResponse
     */
    async publishThingModel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.publishThingModelWithOptions(request, runtime);
    }
    async pushSpeechWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.projectCode)) {
            body["ProjectCode"] = request.projectCode;
        }
        if (!tea_util_1.default.isUnset(request.pushMode)) {
            body["PushMode"] = request.pushMode;
        }
        if (!tea_util_1.default.isUnset(request.speechCodeList)) {
            body["SpeechCodeList"] = request.speechCodeList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PushSpeech",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PushSpeechResponse({}));
    }
    async pushSpeech(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.pushSpeechWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * You can call this API operation up to 30 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryBatchRegisterDeviceStatusRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryBatchRegisterDeviceStatusResponse
     */
    async queryBatchRegisterDeviceStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.applyId)) {
            query["ApplyId"] = request.applyId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryBatchRegisterDeviceStatus",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryBatchRegisterDeviceStatusResponse({}));
    }
    /**
      * ## QPS limits
      * You can call this API operation up to 30 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryBatchRegisterDeviceStatusRequest
      * @return QueryBatchRegisterDeviceStatusResponse
     */
    async queryBatchRegisterDeviceStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryBatchRegisterDeviceStatusWithOptions(request, runtime);
    }
    async queryCertUrlByApplyIdWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.applyId)) {
            query["ApplyId"] = request.applyId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCertUrlByApplyId",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryCertUrlByApplyIdResponse({}));
    }
    async queryCertUrlByApplyId(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryCertUrlByApplyIdWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryClientIdsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryClientIdsResponse
     */
    async queryClientIdsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryClientIds",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryClientIdsResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryClientIdsRequest
      * @return QueryClientIdsResponse
     */
    async queryClientIds(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryClientIdsWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryConsumerGroupByGroupIdRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryConsumerGroupByGroupIdResponse
     */
    async queryConsumerGroupByGroupIdWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryConsumerGroupByGroupId",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryConsumerGroupByGroupIdResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryConsumerGroupByGroupIdRequest
      * @return QueryConsumerGroupByGroupIdResponse
     */
    async queryConsumerGroupByGroupId(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryConsumerGroupByGroupIdWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryConsumerGroupListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryConsumerGroupListResponse
     */
    async queryConsumerGroupListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.fuzzy)) {
            query["Fuzzy"] = request.fuzzy;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            query["GroupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.subBizCode)) {
            query["SubBizCode"] = request.subBizCode;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryConsumerGroupList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryConsumerGroupListResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryConsumerGroupListRequest
      * @return QueryConsumerGroupListResponse
     */
    async queryConsumerGroupList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryConsumerGroupListWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryConsumerGroupStatusRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryConsumerGroupStatusResponse
     */
    async queryConsumerGroupStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryConsumerGroupStatus",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryConsumerGroupStatusResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryConsumerGroupStatusRequest
      * @return QueryConsumerGroupStatusResponse
     */
    async queryConsumerGroupStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryConsumerGroupStatusWithOptions(request, runtime);
    }
    async queryDetailSceneRuleLogWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.traceId)) {
            query["TraceId"] = request.traceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDetailSceneRuleLog",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDetailSceneRuleLogResponse({}));
    }
    async queryDetailSceneRuleLog(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDetailSceneRuleLogWithOptions(request, runtime);
    }
    /**
      * The QueryDevice operation can return up to one million devices each time you call the operation.
      * ## QPS limits
      * - You can call this API operation up to 50 times per second per account. >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      * - If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the queries per second (QPS) of this operation decreases.
      * In this case, you can call this API operation up to two times per second per account.
      *
      * @param request QueryDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceResponse
     */
    async queryDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceResponse({}));
    }
    /**
      * The QueryDevice operation can return up to one million devices each time you call the operation.
      * ## QPS limits
      * - You can call this API operation up to 50 times per second per account. >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      * - If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the queries per second (QPS) of this operation decreases.
      * In this case, you can call this API operation up to two times per second per account.
      *
      * @param request QueryDeviceRequest
      * @return QueryDeviceResponse
     */
    async queryDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceWithOptions(request, runtime);
    }
    /**
      * *   You can query devices on Enterprise Edition instances only in the China (Shanghai) and Japan (Tokyo) regions.
      * *   The QueryDeviceBySQL operation can return up to 10,000 devices each time you call the operation. For more information, see the "`Syntax of LIMIT clauses`" section of this topic.
      * ## QPS limits
      * You can call this API operation up to 10 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceBySQLRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceBySQLResponse
     */
    async queryDeviceBySQLWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.SQL)) {
            query["SQL"] = request.SQL;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceBySQL",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceBySQLResponse({}));
    }
    /**
      * *   You can query devices on Enterprise Edition instances only in the China (Shanghai) and Japan (Tokyo) regions.
      * *   The QueryDeviceBySQL operation can return up to 10,000 devices each time you call the operation. For more information, see the "`Syntax of LIMIT clauses`" section of this topic.
      * ## QPS limits
      * You can call this API operation up to 10 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceBySQLRequest
      * @return QueryDeviceBySQLResponse
     */
    async queryDeviceBySQL(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceBySQLWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   After the status of a device changes, the new status is applied within 10 seconds. After the new status is applied, you can search for the device by using the new status. Before the new status is applied, you can search for the device by using the previous status.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceByStatusRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceByStatusResponse
     */
    async queryDeviceByStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceByStatus",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceByStatusResponse({}));
    }
    /**
      * ## Limits
      * *   After the status of a device changes, the new status is applied within 10 seconds. After the new status is applied, you can search for the device by using the new status. Before the new status is applied, you can search for the device by using the previous status.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceByStatusRequest
      * @return QueryDeviceByStatusResponse
     */
    async queryDeviceByStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceByStatusWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You can specify a maximum of 10 tags in a single call.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceByTagsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceByTagsResponse
     */
    async queryDeviceByTagsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceByTags",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceByTagsResponse({}));
    }
    /**
      * ## Limits
      * *   You can specify a maximum of 10 tags in a single call.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceByTagsRequest
      * @return QueryDeviceByTagsResponse
     */
    async queryDeviceByTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceByTagsWithOptions(request, runtime);
    }
    async queryDeviceCertWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceCert",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceCertResponse({}));
    }
    async queryDeviceCert(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceCertWithOptions(request, runtime);
    }
    /**
      * *   The desired values of read-only properties cannot be queried.
      * *   You can query the desired values of up to 10 properties in a single call.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceDesiredPropertyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceDesiredPropertyResponse
     */
    async queryDeviceDesiredPropertyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceDesiredProperty",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceDesiredPropertyResponse({}));
    }
    /**
      * *   The desired values of read-only properties cannot be queried.
      * *   You can query the desired values of up to 10 properties in a single call.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceDesiredPropertyRequest
      * @return QueryDeviceDesiredPropertyResponse
     */
    async queryDeviceDesiredProperty(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceDesiredPropertyWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceDetailRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceDetailResponse
     */
    async queryDeviceDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceDetail",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceDetailResponse({}));
    }
    /**
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceDetailRequest
      * @return QueryDeviceDetailResponse
     */
    async queryDeviceDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceDetailWithOptions(request, runtime);
    }
    /**
      * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceDistributeDetailRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceDistributeDetailResponse
     */
    async queryDeviceDistributeDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceDistributeDetail",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceDistributeDetailResponse({}));
    }
    /**
      * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceDistributeDetailRequest
      * @return QueryDeviceDistributeDetailResponse
     */
    async queryDeviceDistributeDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceDistributeDetailWithOptions(request, runtime);
    }
    /**
      * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceDistributeJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceDistributeJobResponse
     */
    async queryDeviceDistributeJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceDistributeJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceDistributeJobResponse({}));
    }
    /**
      * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceDistributeJobRequest
      * @return QueryDeviceDistributeJobResponse
     */
    async queryDeviceDistributeJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceDistributeJobWithOptions(request, runtime);
    }
    /**
      * You can query only the event records that are generated in the previous 30 days.
      * >  The storage period of an event record is calculated from the day when the record is generated.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request QueryDeviceEventDataRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceEventDataResponse
     */
    async queryDeviceEventDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.asc)) {
            query["Asc"] = request.asc;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.eventType)) {
            query["EventType"] = request.eventType;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceEventData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceEventDataResponse({}));
    }
    /**
      * You can query only the event records that are generated in the previous 30 days.
      * >  The storage period of an event record is calculated from the day when the record is generated.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request QueryDeviceEventDataRequest
      * @return QueryDeviceEventDataResponse
     */
    async queryDeviceEventData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceEventDataWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceFileRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceFileResponse
     */
    async queryDeviceFileWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.fileId)) {
            query["FileId"] = request.fileId;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceFile",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceFileResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceFileRequest
      * @return QueryDeviceFileResponse
     */
    async queryDeviceFile(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceFileWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   The returned file information for this operation call does not contain download URLs. To obtain the download URL of a file, call [QueryDeviceFile](~~112002~~).
      * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceFileListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceFileListResponse
     */
    async queryDeviceFileListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceFileList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceFileListResponse({}));
    }
    /**
      * ## Limits
      * *   The returned file information for this operation call does not contain download URLs. To obtain the download URL of a file, call [QueryDeviceFile](~~112002~~).
      * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceFileListRequest
      * @return QueryDeviceFileListResponse
     */
    async queryDeviceFileList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceFileListWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You can add a device to a maximum of 10 groups.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceGroupByDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceGroupByDeviceResponse
     */
    async queryDeviceGroupByDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceGroupByDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceGroupByDeviceResponse({}));
    }
    /**
      * ## Limits
      * *   You can add a device to a maximum of 10 groups.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceGroupByDeviceRequest
      * @return QueryDeviceGroupByDeviceResponse
     */
    async queryDeviceGroupByDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceGroupByDeviceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceGroupByTagsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceGroupByTagsResponse
     */
    async queryDeviceGroupByTagsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceGroupByTags",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceGroupByTagsResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceGroupByTagsRequest
      * @return QueryDeviceGroupByTagsResponse
     */
    async queryDeviceGroupByTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceGroupByTagsWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceGroupInfoRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceGroupInfoResponse
     */
    async queryDeviceGroupInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.groupType)) {
            query["GroupType"] = request.groupType;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceGroupInfo",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceGroupInfoResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceGroupInfoRequest
      * @return QueryDeviceGroupInfoResponse
     */
    async queryDeviceGroupInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceGroupInfoWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 100 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceGroupListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceGroupListResponse
     */
    async queryDeviceGroupListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            query["GroupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.groupTypes)) {
            query["GroupTypes"] = request.groupTypes;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.superGroupId)) {
            query["SuperGroupId"] = request.superGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceGroupList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceGroupListResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 100 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceGroupListRequest
      * @return QueryDeviceGroupListResponse
     */
    async queryDeviceGroupList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceGroupListWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceGroupTagListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceGroupTagListResponse
     */
    async queryDeviceGroupTagListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.groupType)) {
            query["GroupType"] = request.groupType;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceGroupTagList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceGroupTagListResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceGroupTagListRequest
      * @return QueryDeviceGroupTagListResponse
     */
    async queryDeviceGroupTagList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceGroupTagListWithOptions(request, runtime);
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
      *
      * @param request QueryDeviceInfoRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceInfoResponse
     */
    async queryDeviceInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceInfo",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceInfoResponse({}));
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
      *
      * @param request QueryDeviceInfoRequest
      * @return QueryDeviceInfoResponse
     */
    async queryDeviceInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceInfoWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceListByDeviceGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceListByDeviceGroupResponse
     */
    async queryDeviceListByDeviceGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceListByDeviceGroup",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceListByDeviceGroupResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceListByDeviceGroupRequest
      * @return QueryDeviceListByDeviceGroupResponse
     */
    async queryDeviceListByDeviceGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceListByDeviceGroupWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You can query only the event records that are generated in the last 30 days.
      * >  The storage period of an event record is calculated from the day when the record is generated.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceOriginalEventDataRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceOriginalEventDataResponse
     */
    async queryDeviceOriginalEventDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.asc)) {
            query["Asc"] = request.asc;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nextPageToken)) {
            query["NextPageToken"] = request.nextPageToken;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceOriginalEventData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceOriginalEventDataResponse({}));
    }
    /**
      * ## Limits
      * *   You can query only the event records that are generated in the last 30 days.
      * >  The storage period of an event record is calculated from the day when the record is generated.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceOriginalEventDataRequest
      * @return QueryDeviceOriginalEventDataResponse
     */
    async queryDeviceOriginalEventData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceOriginalEventDataWithOptions(request, runtime);
    }
    /**
      * You can query only the property records that are generated within the previous 30 days.
      * >  The data of a property is stored from the day when the data is generated.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceOriginalPropertyDataRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceOriginalPropertyDataResponse
     */
    async queryDeviceOriginalPropertyDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.asc)) {
            query["Asc"] = request.asc;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nextPageToken)) {
            query["NextPageToken"] = request.nextPageToken;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceOriginalPropertyData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceOriginalPropertyDataResponse({}));
    }
    /**
      * You can query only the property records that are generated within the previous 30 days.
      * >  The data of a property is stored from the day when the data is generated.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceOriginalPropertyDataRequest
      * @return QueryDeviceOriginalPropertyDataResponse
     */
    async queryDeviceOriginalPropertyData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceOriginalPropertyDataWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceOriginalPropertyStatusRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceOriginalPropertyStatusResponse
     */
    async queryDeviceOriginalPropertyStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.asc)) {
            query["Asc"] = request.asc;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nextPageToken)) {
            query["NextPageToken"] = request.nextPageToken;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceOriginalPropertyStatus",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceOriginalPropertyStatusResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceOriginalPropertyStatusRequest
      * @return QueryDeviceOriginalPropertyStatusResponse
     */
    async queryDeviceOriginalPropertyStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceOriginalPropertyStatusWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You can query only the service call records that are generated in the last 30 days.
      * >  The storage period of a service call record is calculated from the day when the service is called.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceOriginalServiceDataRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceOriginalServiceDataResponse
     */
    async queryDeviceOriginalServiceDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.asc)) {
            query["Asc"] = request.asc;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nextPageToken)) {
            query["NextPageToken"] = request.nextPageToken;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceOriginalServiceData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceOriginalServiceDataResponse({}));
    }
    /**
      * ## Limits
      * *   You can query only the service call records that are generated in the last 30 days.
      * >  The storage period of a service call record is calculated from the day when the service is called.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceOriginalServiceDataRequest
      * @return QueryDeviceOriginalServiceDataResponse
     */
    async queryDeviceOriginalServiceData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceOriginalServiceDataWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDevicePropRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDevicePropResponse
     */
    async queryDevicePropWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceProp",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDevicePropResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDevicePropRequest
      * @return QueryDevicePropResponse
     */
    async queryDeviceProp(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDevicePropWithOptions(request, runtime);
    }
    /**
      * When you call this operation to query property records within a specified period, the number of records for a property at a point in time may reach the limit.**** The limit is specified by the **PageSize** parameter. In this case, the query stops. Some records of other properties may be not returned.**** You can check whether all records of a property are returned based on the NextValid repsonse parameter:
      * - If the value of the **NextValid** parameter is true, unretrieved records exist in the period that is indicated by the **NextTime** and **EndTime** parameter.
      * You can use the value of the **NextTime** response parameter as the value of the StartTime request parameter and call this operation again to query the rest records. You can call this operation multiple times until the value of the **NextValid** parameter is false.  >  To retrieve all property records within a specified period, you can set the **PageSize** parameter to the maximum value. Then, call this operation multiple times until the value of the **NextValid** parameter is false.
      * - If the value of the **NextValid** parameter is false, all property records are returned.
      * ## Limits
      * *   A maximum of 10 properties can be queried at a time. A maximum of 100 records can be queried for each property.
      * *   You can query property data that is generated within the last 30 days.
      * > The storage period of a property record is calculated from the day when the property record was generated.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDevicePropertiesDataRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDevicePropertiesDataResponse
     */
    async queryDevicePropertiesDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.asc)) {
            query["Asc"] = request.asc;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDevicePropertiesData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDevicePropertiesDataResponse({}));
    }
    /**
      * When you call this operation to query property records within a specified period, the number of records for a property at a point in time may reach the limit.**** The limit is specified by the **PageSize** parameter. In this case, the query stops. Some records of other properties may be not returned.**** You can check whether all records of a property are returned based on the NextValid repsonse parameter:
      * - If the value of the **NextValid** parameter is true, unretrieved records exist in the period that is indicated by the **NextTime** and **EndTime** parameter.
      * You can use the value of the **NextTime** response parameter as the value of the StartTime request parameter and call this operation again to query the rest records. You can call this operation multiple times until the value of the **NextValid** parameter is false.  >  To retrieve all property records within a specified period, you can set the **PageSize** parameter to the maximum value. Then, call this operation multiple times until the value of the **NextValid** parameter is false.
      * - If the value of the **NextValid** parameter is false, all property records are returned.
      * ## Limits
      * *   A maximum of 10 properties can be queried at a time. A maximum of 100 records can be queried for each property.
      * *   You can query property data that is generated within the last 30 days.
      * > The storage period of a property record is calculated from the day when the property record was generated.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDevicePropertiesDataRequest
      * @return QueryDevicePropertiesDataResponse
     */
    async queryDevicePropertiesData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDevicePropertiesDataWithOptions(request, runtime);
    }
    /**
      * If a device or a digital twin node has multiple properties, you can call this operation to query the data of the properties multiple times. You must specify a value for the **Identifier** parameter each time you call the operation. You can also call the [QueryDevicePropertiesData](~~99237~~) operation and specify multiple values for the **Identifier** parameter to query the data of the properties.
      * ## Limits
      * You can query only property data that is generated within the previous 30 days.
      * >  The data of a property is stored from the day when the data is generated.
      *
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request QueryDevicePropertyDataRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDevicePropertyDataResponse
     */
    async queryDevicePropertyDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.asc)) {
            query["Asc"] = request.asc;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDevicePropertyData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDevicePropertyDataResponse({}));
    }
    /**
      * If a device or a digital twin node has multiple properties, you can call this operation to query the data of the properties multiple times. You must specify a value for the **Identifier** parameter each time you call the operation. You can also call the [QueryDevicePropertiesData](~~99237~~) operation and specify multiple values for the **Identifier** parameter to query the data of the properties.
      * ## Limits
      * You can query only property data that is generated within the previous 30 days.
      * >  The data of a property is stored from the day when the data is generated.
      *
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request QueryDevicePropertyDataRequest
      * @return QueryDevicePropertyDataResponse
     */
    async queryDevicePropertyData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDevicePropertyDataWithOptions(request, runtime);
    }
    /**
      * To query the property data of a digital twin node, you must set the **IotId** parameter to the ID of the digital twin node.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 200 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request QueryDevicePropertyStatusRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDevicePropertyStatusResponse
     */
    async queryDevicePropertyStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDevicePropertyStatus",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDevicePropertyStatusResponse({}));
    }
    /**
      * To query the property data of a digital twin node, you must set the **IotId** parameter to the ID of the digital twin node.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 200 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request QueryDevicePropertyStatusRequest
      * @return QueryDevicePropertyStatusResponse
     */
    async queryDevicePropertyStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDevicePropertyStatusWithOptions(request, runtime);
    }
    async queryDeviceProvisioningWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceProvisioning",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceProvisioningResponse({}));
    }
    async queryDeviceProvisioning(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceProvisioningWithOptions(request, runtime);
    }
    /**
      * You can query only the service call records of the previous 30 days.
      * >  The storage period of a service call record is calculated from the day when the service is called.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceServiceDataRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceServiceDataResponse
     */
    async queryDeviceServiceDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.asc)) {
            query["Asc"] = request.asc;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceServiceData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceServiceDataResponse({}));
    }
    /**
      * You can query only the service call records of the previous 30 days.
      * >  The storage period of a service call record is calculated from the day when the service is called.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceServiceDataRequest
      * @return QueryDeviceServiceDataResponse
     */
    async queryDeviceServiceData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceServiceDataWithOptions(request, runtime);
    }
    async queryDeviceSpeechWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceSpeech",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceSpeechResponse({}));
    }
    async queryDeviceSpeech(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceSpeechWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceStatisticsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceStatisticsResponse
     */
    async queryDeviceStatisticsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceStatistics",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceStatisticsResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceStatisticsRequest
      * @return QueryDeviceStatisticsResponse
     */
    async queryDeviceStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceStatisticsWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * You can call this operation up to 100 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceSubTopicRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDeviceSubTopicResponse
     */
    async queryDeviceSubTopicWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceSubTopic",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceSubTopicResponse({}));
    }
    /**
      * ## QPS limits
      * You can call this operation up to 100 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryDeviceSubTopicRequest
      * @return QueryDeviceSubTopicResponse
     */
    async queryDeviceSubTopic(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceSubTopicWithOptions(request, runtime);
    }
    async queryDeviceTunnelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.tunnelId)) {
            query["TunnelId"] = request.tunnelId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDeviceTunnel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDeviceTunnelResponse({}));
    }
    async queryDeviceTunnel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDeviceTunnelWithOptions(request, runtime);
    }
    async queryDevicesHotStorageDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.asc)) {
            query["Asc"] = request.asc;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nextPageToken)) {
            query["NextPageToken"] = request.nextPageToken;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.userTopic)) {
            query["UserTopic"] = request.userTopic;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDevicesHotStorageData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDevicesHotStorageDataResponse({}));
    }
    async queryDevicesHotStorageData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDevicesHotStorageDataWithOptions(request, runtime);
    }
    async queryDevicesHotStorageDataStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.asc)) {
            query["Asc"] = request.asc;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nextPageToken)) {
            query["NextPageToken"] = request.nextPageToken;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.userTopic)) {
            query["UserTopic"] = request.userTopic;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDevicesHotStorageDataStatus",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDevicesHotStorageDataStatusResponse({}));
    }
    async queryDevicesHotStorageDataStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDevicesHotStorageDataStatusWithOptions(request, runtime);
    }
    async queryDynamicGroupDevicesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.fuzzyName)) {
            query["FuzzyName"] = request.fuzzyName;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDynamicGroupDevices",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDynamicGroupDevicesResponse({}));
    }
    async queryDynamicGroupDevices(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDynamicGroupDevicesWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users share the quota of the Alibaba Cloud account.
      *
      * @param request QueryEdgeDriverRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryEdgeDriverResponse
     */
    async queryEdgeDriverWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.driverName)) {
            query["DriverName"] = request.driverName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeDriver",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeDriverResponse({}));
    }
    /**
      * ## Limits
      * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users share the quota of the Alibaba Cloud account.
      *
      * @param request QueryEdgeDriverRequest
      * @return QueryEdgeDriverResponse
     */
    async queryEdgeDriver(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeDriverWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryEdgeDriverVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryEdgeDriverVersionResponse
     */
    async queryEdgeDriverVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.driverVersion)) {
            query["DriverVersion"] = request.driverVersion;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.versionState)) {
            query["VersionState"] = request.versionState;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeDriverVersion",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeDriverVersionResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryEdgeDriverVersionRequest
      * @return QueryEdgeDriverVersionResponse
     */
    async queryEdgeDriverVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeDriverVersionWithOptions(request, runtime);
    }
    /**
      * In addition to the preceding exclusive request parameters, you must specify common request parameters when calling this API operation. For more information about common request parameters, see [Common parameters](~~30561~~).
      *
      * @param request QueryEdgeInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryEdgeInstanceResponse
     */
    async queryEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeInstanceResponse({}));
    }
    /**
      * In addition to the preceding exclusive request parameters, you must specify common request parameters when calling this API operation. For more information about common request parameters, see [Common parameters](~~30561~~).
      *
      * @param request QueryEdgeInstanceRequest
      * @return QueryEdgeInstanceResponse
     */
    async queryEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeInstanceWithOptions(request, runtime);
    }
    async queryEdgeInstanceChannelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.channelName)) {
            query["ChannelName"] = request.channelName;
        }
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeInstanceChannel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeInstanceChannelResponse({}));
    }
    async queryEdgeInstanceChannel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeInstanceChannelWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryEdgeInstanceDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryEdgeInstanceDeviceResponse
     */
    async queryEdgeInstanceDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeInstanceDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeInstanceDeviceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryEdgeInstanceDeviceRequest
      * @return QueryEdgeInstanceDeviceResponse
     */
    async queryEdgeInstanceDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeInstanceDeviceWithOptions(request, runtime);
    }
    async queryEdgeInstanceDeviceByDriverWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.channelId)) {
            query["ChannelId"] = request.channelId;
        }
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeInstanceDeviceByDriver",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeInstanceDeviceByDriverResponse({}));
    }
    async queryEdgeInstanceDeviceByDriver(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeInstanceDeviceByDriverWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryEdgeInstanceDriverRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryEdgeInstanceDriverResponse
     */
    async queryEdgeInstanceDriverWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeInstanceDriver",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeInstanceDriverResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryEdgeInstanceDriverRequest
      * @return QueryEdgeInstanceDriverResponse
     */
    async queryEdgeInstanceDriver(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeInstanceDriverWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryEdgeInstanceGatewayRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryEdgeInstanceGatewayResponse
     */
    async queryEdgeInstanceGatewayWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeInstanceGateway",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeInstanceGatewayResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryEdgeInstanceGatewayRequest
      * @return QueryEdgeInstanceGatewayResponse
     */
    async queryEdgeInstanceGateway(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeInstanceGatewayWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryEdgeInstanceHistoricDeploymentRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryEdgeInstanceHistoricDeploymentResponse
     */
    async queryEdgeInstanceHistoricDeploymentWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeInstanceHistoricDeployment",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeInstanceHistoricDeploymentResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryEdgeInstanceHistoricDeploymentRequest
      * @return QueryEdgeInstanceHistoricDeploymentResponse
     */
    async queryEdgeInstanceHistoricDeployment(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeInstanceHistoricDeploymentWithOptions(request, runtime);
    }
    async queryEdgeInstanceMessageRoutingWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeInstanceMessageRouting",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeInstanceMessageRoutingResponse({}));
    }
    async queryEdgeInstanceMessageRouting(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeInstanceMessageRoutingWithOptions(request, runtime);
    }
    async queryEdgeInstanceSceneRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEdgeInstanceSceneRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEdgeInstanceSceneRuleResponse({}));
    }
    async queryEdgeInstanceSceneRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEdgeInstanceSceneRuleWithOptions(request, runtime);
    }
    async queryImportedDeviceByApplyIdWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.applyId)) {
            query["ApplyId"] = request.applyId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageNo)) {
            query["PageNo"] = request.pageNo;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryImportedDeviceByApplyId",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryImportedDeviceByApplyIdResponse({}));
    }
    async queryImportedDeviceByApplyId(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryImportedDeviceByApplyIdWithOptions(request, runtime);
    }
    async queryJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryJobResponse({}));
    }
    async queryJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryJobWithOptions(request, runtime);
    }
    async queryJobStatisticsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryJobStatistics",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "GET",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryJobStatisticsResponse({}));
    }
    async queryJobStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryJobStatisticsWithOptions(request, runtime);
    }
    async queryLicenseDeviceListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.licenseCode)) {
            query["LicenseCode"] = request.licenseCode;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            query["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryLicenseDeviceList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryLicenseDeviceListResponse({}));
    }
    async queryLicenseDeviceList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryLicenseDeviceListWithOptions(request, runtime);
    }
    async queryLoRaJoinPermissionsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryLoRaJoinPermissions",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryLoRaJoinPermissionsResponse({}));
    }
    async queryLoRaJoinPermissions(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryLoRaJoinPermissionsWithOptions(request, runtime);
    }
    async queryMessageInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.uniMsgId)) {
            query["UniMsgId"] = request.uniMsgId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryMessageInfo",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryMessageInfoResponse({}));
    }
    async queryMessageInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryMessageInfoWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryOTAFirmwareRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryOTAFirmwareResponse
     */
    async queryOTAFirmwareWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.firmwareId)) {
            query["FirmwareId"] = request.firmwareId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryOTAFirmware",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryOTAFirmwareResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryOTAFirmwareRequest
      * @return QueryOTAFirmwareResponse
     */
    async queryOTAFirmware(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryOTAFirmwareWithOptions(request, runtime);
    }
    /**
      * After you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch, the **JobId** parameter is returned. You can use this parameter to query the details of the update batch.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryOTAJobRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryOTAJobResponse
     */
    async queryOTAJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryOTAJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryOTAJobResponse({}));
    }
    /**
      * After you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch, the **JobId** parameter is returned. You can use this parameter to query the details of the update batch.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryOTAJobRequest
      * @return QueryOTAJobResponse
     */
    async queryOTAJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryOTAJobWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryPageByApplyIdRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryPageByApplyIdResponse
     */
    async queryPageByApplyIdWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.applyId)) {
            query["ApplyId"] = request.applyId;
        }
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryPageByApplyId",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryPageByApplyIdResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryPageByApplyIdRequest
      * @return QueryPageByApplyIdResponse
     */
    async queryPageByApplyId(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryPageByApplyIdWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryProductRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryProductResponse
     */
    async queryProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryProduct",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryProductResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryProductRequest
      * @return QueryProductResponse
     */
    async queryProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryProductWithOptions(request, runtime);
    }
    async queryProductCertInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryProductCertInfo",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryProductCertInfoResponse({}));
    }
    async queryProductCertInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryProductCertInfoWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * *   Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * > The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      * *   If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the QPS of this operation decreases.
      *     In this case, each Alibaba Cloud account can run up to 2 QPS.
      *
      * @param request QueryProductListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryProductListResponse
     */
    async queryProductListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.aliyunCommodityCode)) {
            query["AliyunCommodityCode"] = request.aliyunCommodityCode;
        }
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryProductList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryProductListResponse({}));
    }
    /**
      * ## QPS limits
      * *   Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * > The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      * *   If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the QPS of this operation decreases.
      *     In this case, each Alibaba Cloud account can run up to 2 QPS.
      *
      * @param request QueryProductListRequest
      * @return QueryProductListResponse
     */
    async queryProductList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryProductListWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 3 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryProductTopicRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryProductTopicResponse
     */
    async queryProductTopicWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryProductTopic",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryProductTopicResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 3 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryProductTopicRequest
      * @return QueryProductTopicResponse
     */
    async queryProductTopic(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryProductTopicWithOptions(request, runtime);
    }
    async queryProjectShareDeviceListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryProjectShareDeviceList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryProjectShareDeviceListResponse({}));
    }
    async queryProjectShareDeviceList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryProjectShareDeviceListWithOptions(request, runtime);
    }
    async querySceneRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.ruleName)) {
            query["RuleName"] = request.ruleName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySceneRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySceneRuleResponse({}));
    }
    async querySceneRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySceneRuleWithOptions(request, runtime);
    }
    async querySchedulePeriodListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.scheduleCode)) {
            body["ScheduleCode"] = request.scheduleCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySchedulePeriodList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySchedulePeriodListResponse({}));
    }
    async querySchedulePeriodList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySchedulePeriodListWithOptions(request, runtime);
    }
    async queryShareTaskDeviceListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.shareTaskId)) {
            body["ShareTaskId"] = request.shareTaskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryShareTaskDeviceList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryShareTaskDeviceListResponse({}));
    }
    async queryShareTaskDeviceList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryShareTaskDeviceListWithOptions(request, runtime);
    }
    async querySolutionDeviceGroupPageWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.fuzzyGroupName)) {
            query["FuzzyGroupName"] = request.fuzzyGroupName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            query["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.projectCode)) {
            query["ProjectCode"] = request.projectCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySolutionDeviceGroupPage",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySolutionDeviceGroupPageResponse({}));
    }
    async querySolutionDeviceGroupPage(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySolutionDeviceGroupPageWithOptions(request, runtime);
    }
    async querySoundCodeLabelBatchFailedResultWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.batchCode)) {
            body["BatchCode"] = request.batchCode;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySoundCodeLabelBatchFailedResult",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySoundCodeLabelBatchFailedResultResponse({}));
    }
    async querySoundCodeLabelBatchFailedResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySoundCodeLabelBatchFailedResultWithOptions(request, runtime);
    }
    async querySoundCodeLabelBatchListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.scheduleCode)) {
            body["ScheduleCode"] = request.scheduleCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySoundCodeLabelBatchList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySoundCodeLabelBatchListResponse({}));
    }
    async querySoundCodeLabelBatchList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySoundCodeLabelBatchListWithOptions(request, runtime);
    }
    async querySoundCodeLabelListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.scheduleCode)) {
            body["ScheduleCode"] = request.scheduleCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySoundCodeLabelList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySoundCodeLabelListResponse({}));
    }
    async querySoundCodeLabelList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySoundCodeLabelListWithOptions(request, runtime);
    }
    async querySoundCodeListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySoundCodeList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySoundCodeListResponse({}));
    }
    async querySoundCodeList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySoundCodeListWithOptions(request, runtime);
    }
    async querySoundCodeScheduleListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySoundCodeScheduleList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySoundCodeScheduleListResponse({}));
    }
    async querySoundCodeScheduleList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySoundCodeScheduleListWithOptions(request, runtime);
    }
    async querySpeechWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.speechCode)) {
            body["SpeechCode"] = request.speechCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySpeech",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySpeechResponse({}));
    }
    async querySpeech(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySpeechWithOptions(request, runtime);
    }
    async querySpeechDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.availableSpace)) {
            body["AvailableSpace"] = request.availableSpace;
        }
        if (!tea_util_1.default.isUnset(request.availableSpaceScope)) {
            body["AvailableSpaceScope"] = request.availableSpaceScope;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.projectCode)) {
            body["ProjectCode"] = request.projectCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySpeechDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySpeechDeviceResponse({}));
    }
    async querySpeechDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySpeechDeviceWithOptions(request, runtime);
    }
    async querySpeechLicenseAvailableQuotaWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySpeechLicenseAvailableQuota",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySpeechLicenseAvailableQuotaResponse({}));
    }
    async querySpeechLicenseAvailableQuota(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySpeechLicenseAvailableQuotaWithOptions(request, runtime);
    }
    async querySpeechLicenseDeviceListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            query["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.checkGroupId)) {
            body["CheckGroupId"] = request.checkGroupId;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.licenseStatusList)) {
            body["LicenseStatusList"] = request.licenseStatusList;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySpeechLicenseDeviceList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySpeechLicenseDeviceListResponse({}));
    }
    async querySpeechLicenseDeviceList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySpeechLicenseDeviceListWithOptions(request, runtime);
    }
    async querySpeechListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.audioFormat)) {
            body["AudioFormat"] = request.audioFormat;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.projectCode)) {
            body["ProjectCode"] = request.projectCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySpeechList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySpeechListResponse({}));
    }
    async querySpeechList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySpeechListWithOptions(request, runtime);
    }
    async querySpeechPushJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.jobCode)) {
            query["JobCode"] = request.jobCode;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.projectCode)) {
            body["ProjectCode"] = request.projectCode;
        }
        if (!tea_util_1.default.isUnset(request.pushMode)) {
            body["PushMode"] = request.pushMode;
        }
        if (!tea_util_1.default.isUnset(request.statusList)) {
            body["StatusList"] = request.statusList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySpeechPushJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySpeechPushJobResponse({}));
    }
    async querySpeechPushJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySpeechPushJobWithOptions(request, runtime);
    }
    async querySpeechPushJobDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobCode)) {
            body["JobCode"] = request.jobCode;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["Status"] = request.status;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySpeechPushJobDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySpeechPushJobDeviceResponse({}));
    }
    async querySpeechPushJobDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySpeechPushJobDeviceWithOptions(request, runtime);
    }
    async querySpeechPushJobSpeechWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobCode)) {
            body["JobCode"] = request.jobCode;
        }
        if (!tea_util_1.default.isUnset(request.pageId)) {
            body["PageId"] = request.pageId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySpeechPushJobSpeech",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySpeechPushJobSpeechResponse({}));
    }
    async querySpeechPushJobSpeech(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySpeechPushJobSpeechWithOptions(request, runtime);
    }
    async queryStudioAppDomainListOpenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["AppId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryStudioAppDomainListOpen",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryStudioAppDomainListOpenResponse({}));
    }
    async queryStudioAppDomainListOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryStudioAppDomainListOpenWithOptions(request, runtime);
    }
    async queryStudioAppListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.fuzzyName)) {
            body["FuzzyName"] = request.fuzzyName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageNo)) {
            body["PageNo"] = request.pageNo;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        if (!tea_util_1.default.isUnset(request.types)) {
            body["Types"] = request.types;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryStudioAppList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryStudioAppListResponse({}));
    }
    async queryStudioAppList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryStudioAppListWithOptions(request, runtime);
    }
    async queryStudioAppPageListOpenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["AppId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.isRelease)) {
            body["IsRelease"] = request.isRelease;
        }
        if (!tea_util_1.default.isUnset(request.pageNo)) {
            body["PageNo"] = request.pageNo;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryStudioAppPageListOpen",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryStudioAppPageListOpenResponse({}));
    }
    async queryStudioAppPageListOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryStudioAppPageListOpenWithOptions(request, runtime);
    }
    async queryStudioProjectListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.pageNo)) {
            body["PageNo"] = request.pageNo;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryStudioProjectList",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryStudioProjectListResponse({}));
    }
    async queryStudioProjectList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryStudioProjectListWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QuerySubscribeRelationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QuerySubscribeRelationResponse
     */
    async querySubscribeRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySubscribeRelation",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySubscribeRelationResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QuerySubscribeRelationRequest
      * @return QuerySubscribeRelationResponse
     */
    async querySubscribeRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySubscribeRelationWithOptions(request, runtime);
    }
    async querySummarySceneRuleLogWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentPage)) {
            query["CurrentPage"] = request.currentPage;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySummarySceneRuleLog",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySummarySceneRuleLogResponse({}));
    }
    async querySummarySceneRuleLog(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySummarySceneRuleLogWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QuerySuperDeviceGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QuerySuperDeviceGroupResponse
     */
    async querySuperDeviceGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySuperDeviceGroup",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySuperDeviceGroupResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QuerySuperDeviceGroupRequest
      * @return QuerySuperDeviceGroupResponse
     */
    async querySuperDeviceGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySuperDeviceGroupWithOptions(request, runtime);
    }
    async queryTaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryTask",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryTaskResponse({}));
    }
    async queryTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryTaskWithOptions(request, runtime);
    }
    /**
      * TSL features include properties, services, and events.
      * If you add custom modules to a TSL model and the value of the **FunctionBlockId** parameter is empty, you can obtain the TSL features of each custom module. If the value of the FunctionBlockId parameter is not empty, you can obtain the TSL features of a specified custom module.
      * For more information about the data format of the **ThingModelJson** parameter, see [Data structure of ThingModelJson](~~150457~~).
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryThingModelRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryThingModelResponse
     */
    async queryThingModelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.modelVersion)) {
            query["ModelVersion"] = request.modelVersion;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryThingModel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryThingModelResponse({}));
    }
    /**
      * TSL features include properties, services, and events.
      * If you add custom modules to a TSL model and the value of the **FunctionBlockId** parameter is empty, you can obtain the TSL features of each custom module. If the value of the FunctionBlockId parameter is not empty, you can obtain the TSL features of a specified custom module.
      * For more information about the data format of the **ThingModelJson** parameter, see [Data structure of ThingModelJson](~~150457~~).
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryThingModelRequest
      * @return QueryThingModelResponse
     */
    async queryThingModel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryThingModelWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryThingModelExtendConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryThingModelExtendConfigResponse
     */
    async queryThingModelExtendConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.modelVersion)) {
            query["ModelVersion"] = request.modelVersion;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryThingModelExtendConfig",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryThingModelExtendConfigResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryThingModelExtendConfigRequest
      * @return QueryThingModelExtendConfigResponse
     */
    async queryThingModelExtendConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryThingModelExtendConfigWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryThingModelExtendConfigPublishedRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryThingModelExtendConfigPublishedResponse
     */
    async queryThingModelExtendConfigPublishedWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.modelVersion)) {
            query["ModelVersion"] = request.modelVersion;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryThingModelExtendConfigPublished",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryThingModelExtendConfigPublishedResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryThingModelExtendConfigPublishedRequest
      * @return QueryThingModelExtendConfigPublishedResponse
     */
    async queryThingModelExtendConfigPublished(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryThingModelExtendConfigPublishedWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryThingModelPublishedRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryThingModelPublishedResponse
     */
    async queryThingModelPublishedWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.modelVersion)) {
            query["ModelVersion"] = request.modelVersion;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryThingModelPublished",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryThingModelPublishedResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryThingModelPublishedRequest
      * @return QueryThingModelPublishedResponse
     */
    async queryThingModelPublished(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryThingModelPublishedWithOptions(request, runtime);
    }
    async queryTopicConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryTopicConfig",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryTopicConfigResponse({}));
    }
    async queryTopicConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryTopicConfigWithOptions(request, runtime);
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
      *
      * @param request QueryTopicReverseRouteTableRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryTopicReverseRouteTableResponse
     */
    async queryTopicReverseRouteTableWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.topic)) {
            query["Topic"] = request.topic;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryTopicReverseRouteTable",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryTopicReverseRouteTableResponse({}));
    }
    /**
      * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
      *
      * @param request QueryTopicReverseRouteTableRequest
      * @return QueryTopicReverseRouteTableResponse
     */
    async queryTopicReverseRouteTable(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryTopicReverseRouteTableWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryTopicRouteTableRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryTopicRouteTableResponse
     */
    async queryTopicRouteTableWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.topic)) {
            query["Topic"] = request.topic;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryTopicRouteTable",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryTopicRouteTableResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request QueryTopicRouteTableRequest
      * @return QueryTopicRouteTableResponse
     */
    async queryTopicRouteTable(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryTopicRouteTableWithOptions(request, runtime);
    }
    /**
      * *   You can call this operation to query the information about a device of a JT/T 808 gateway product.
      * *   When you call this operation, you must specify a **ProductKey** and a **DeviceName**. Otherwise, the call fails.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request QueryVehicleDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryVehicleDeviceResponse
     */
    async queryVehicleDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryVehicleDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryVehicleDeviceResponse({}));
    }
    /**
      * *   You can call this operation to query the information about a device of a JT/T 808 gateway product.
      * *   When you call this operation, you must specify a **ProductKey** and a **DeviceName**. Otherwise, the call fails.
      * ## QPS limits
      * You can call this API operation up to 50 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request QueryVehicleDeviceRequest
      * @return QueryVehicleDeviceResponse
     */
    async queryVehicleDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryVehicleDeviceWithOptions(request, runtime);
    }
    /**
      * If the device fails to send a response within the timeout period after you call the operation, IoT Platform considers that the call fails even if the device receives the message. The timeout period is specified by the **Timeout** parameter.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 1000 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request RRpcRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RRpcResponse
     */
    async rRpcWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.contentType)) {
            query["ContentType"] = request.contentType;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.requestBase64Byte)) {
            query["RequestBase64Byte"] = request.requestBase64Byte;
        }
        if (!tea_util_1.default.isUnset(request.timeout)) {
            query["Timeout"] = request.timeout;
        }
        if (!tea_util_1.default.isUnset(request.topic)) {
            query["Topic"] = request.topic;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RRpc",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RRpcResponse({}));
    }
    /**
      * If the device fails to send a response within the timeout period after you call the operation, IoT Platform considers that the call fails even if the device receives the message. The timeout period is specified by the **Timeout** parameter.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 1000 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request RRpcRequest
      * @return RRpcResponse
     */
    async rRpc(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.rRpcWithOptions(request, runtime);
    }
    async reBindLicenseDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.licenseCode)) {
            query["LicenseCode"] = request.licenseCode;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceNameList)) {
            body["DeviceNameList"] = request.deviceNameList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ReBindLicenseDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ReBindLicenseDeviceResponse({}));
    }
    async reBindLicenseDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.reBindLicenseDeviceWithOptions(request, runtime);
    }
    async recognizeCarNumWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.url)) {
            query["Url"] = request.url;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeCarNum",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeCarNumResponse({}));
    }
    async recognizeCarNum(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeCarNumWithOptions(request, runtime);
    }
    async recognizePictureGeneralWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.url)) {
            query["Url"] = request.url;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RecognizePictureGeneral",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizePictureGeneralResponse({}));
    }
    async recognizePictureGeneral(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizePictureGeneralWithOptions(request, runtime);
    }
    async refreshDeviceTunnelSharePasswordWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RefreshDeviceTunnelSharePassword",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RefreshDeviceTunnelSharePasswordResponse({}));
    }
    async refreshDeviceTunnelSharePassword(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.refreshDeviceTunnelSharePasswordWithOptions(request, runtime);
    }
    async refreshStudioAppTokenOpenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["AppId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RefreshStudioAppTokenOpen",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RefreshStudioAppTokenOpenResponse({}));
    }
    async refreshStudioAppTokenOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.refreshStudioAppTokenOpenWithOptions(request, runtime);
    }
    /**
      * If you call this operation to register a device under a product, the device is added to the product in the IoT Platform console. After the device is registered, IoT Platform issues the IotId parameter to the device. This parameter is a globally unique identifier (GUID) of the device. To perform operations on a device, you must use the IotId parameter to identify the device.
      * You can also use a combination of the ProductKey and DeviceName parameters to identify a device. A ProductKey is issued by IoT Platform to a product when you create the product. A DeviceName is specified or randomly generated when you create a device. The IotId parameter has a higher priority than a combination of the ProductKey and DeviceName parameters.
      * For information about how to register multiple devices under a product at the same time, see [BatchRegisterDeviceWithApplyId](~~69514~~).
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request RegisterDeviceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RegisterDeviceResponse
     */
    async registerDeviceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appKey)) {
            query["AppKey"] = request.appKey;
        }
        if (!tea_util_1.default.isUnset(request.devEui)) {
            query["DevEui"] = request.devEui;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.joinEui)) {
            query["JoinEui"] = request.joinEui;
        }
        if (!tea_util_1.default.isUnset(request.loraNodeType)) {
            query["LoraNodeType"] = request.loraNodeType;
        }
        if (!tea_util_1.default.isUnset(request.nickname)) {
            query["Nickname"] = request.nickname;
        }
        if (!tea_util_1.default.isUnset(request.pinCode)) {
            query["PinCode"] = request.pinCode;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RegisterDevice",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RegisterDeviceResponse({}));
    }
    /**
      * If you call this operation to register a device under a product, the device is added to the product in the IoT Platform console. After the device is registered, IoT Platform issues the IotId parameter to the device. This parameter is a globally unique identifier (GUID) of the device. To perform operations on a device, you must use the IotId parameter to identify the device.
      * You can also use a combination of the ProductKey and DeviceName parameters to identify a device. A ProductKey is issued by IoT Platform to a product when you create the product. A DeviceName is specified or randomly generated when you create a device. The IotId parameter has a higher priority than a combination of the ProductKey and DeviceName parameters.
      * For information about how to register multiple devices under a product at the same time, see [BatchRegisterDeviceWithApplyId](~~69514~~).
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request RegisterDeviceRequest
      * @return RegisterDeviceResponse
     */
    async registerDevice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.registerDeviceWithOptions(request, runtime);
    }
    async releaseEdgeDriverVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.driverVersion)) {
            query["DriverVersion"] = request.driverVersion;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ReleaseEdgeDriverVersion",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ReleaseEdgeDriverVersionResponse({}));
    }
    async releaseEdgeDriverVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.releaseEdgeDriverVersionWithOptions(request, runtime);
    }
    /**
      * *   After a product is published, you cannot call the [CreateThingModel](~~150323~~), [UpdateThingModel](~~151240~~), [ImportThingModelTSL](~~150320~~), [PublishThingModel](~~150311~~), [DeleteThingModel](~~150312~~), or [CopyThingModel](~~150322~~) operation to edit the Thing Specification Language (TSL) model of the product. To edit the TSL model, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ReleaseProductRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ReleaseProductResponse
     */
    async releaseProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ReleaseProduct",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ReleaseProductResponse({}));
    }
    /**
      * *   After a product is published, you cannot call the [CreateThingModel](~~150323~~), [UpdateThingModel](~~151240~~), [ImportThingModelTSL](~~150320~~), [PublishThingModel](~~150311~~), [DeleteThingModel](~~150312~~), or [CopyThingModel](~~150322~~) operation to edit the Thing Specification Language (TSL) model of the product. To edit the TSL model, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ReleaseProductRequest
      * @return ReleaseProductResponse
     */
    async releaseProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.releaseProductWithOptions(request, runtime);
    }
    /**
      * *   If you specify a gateway, this operation removes the topological relationships between the gateway and all attached sub-devices.
      * *   If you specify a sub-device, this operation removes the topological relationship between the sub-device and the gateway to which the sub-device is attached.
      * # QPS limits
      * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request RemoveThingTopoRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RemoveThingTopoResponse
     */
    async removeThingTopoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RemoveThingTopo",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RemoveThingTopoResponse({}));
    }
    /**
      * *   If you specify a gateway, this operation removes the topological relationships between the gateway and all attached sub-devices.
      * *   If you specify a sub-device, this operation removes the topological relationship between the sub-device and the gateway to which the sub-device is attached.
      * # QPS limits
      * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request RemoveThingTopoRequest
      * @return RemoveThingTopoResponse
     */
    async removeThingTopo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.removeThingTopoWithOptions(request, runtime);
    }
    async replaceEdgeInstanceGatewayWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentGatewayId)) {
            query["CurrentGatewayId"] = request.currentGatewayId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.newGatewayId)) {
            query["NewGatewayId"] = request.newGatewayId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ReplaceEdgeInstanceGateway",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ReplaceEdgeInstanceGatewayResponse({}));
    }
    async replaceEdgeInstanceGateway(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.replaceEdgeInstanceGatewayWithOptions(request, runtime);
    }
    async rerunJobWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RerunJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RerunJobResponse({}));
    }
    async rerunJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.rerunJobWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ResetConsumerGroupPositionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ResetConsumerGroupPositionResponse
     */
    async resetConsumerGroupPositionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ResetConsumerGroupPosition",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ResetConsumerGroupPositionResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ResetConsumerGroupPositionRequest
      * @return ResetConsumerGroupPositionResponse
     */
    async resetConsumerGroupPosition(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.resetConsumerGroupPositionWithOptions(request, runtime);
    }
    /**
      * *   After you use dynamic registration to obtain the device certificate information of a directly connected device and activate the device, you can call this operation to reset the dynamic registration status of the status to unregistered in the IoT Platform console. Then, you can use dynamic registration again to obtain the device certificate information. The device certificate information includes ProductKey, DeviceName, and DeviceSecret.
      * > This operation is called to reset the dynamic registration status instead of activation status of a device. After you call the operation to reset the dynamic registration status of a device, the status of the device in the IoT Platform console is not reset to inactive.
      * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request ResetThingRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ResetThingResponse
     */
    async resetThingWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ResetThing",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ResetThingResponse({}));
    }
    /**
      * *   After you use dynamic registration to obtain the device certificate information of a directly connected device and activate the device, you can call this operation to reset the dynamic registration status of the status to unregistered in the IoT Platform console. Then, you can use dynamic registration again to obtain the device certificate information. The device certificate information includes ProductKey, DeviceName, and DeviceSecret.
      * > This operation is called to reset the dynamic registration status instead of activation status of a device. After you call the operation to reset the dynamic registration status of a device, the status of the device in the IoT Platform console is not reset to inactive.
      * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request ResetThingRequest
      * @return ResetThingResponse
     */
    async resetThing(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.resetThingWithOptions(request, runtime);
    }
    async retrySoundCodeLabelBatchWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.batchCode)) {
            body["BatchCode"] = request.batchCode;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RetrySoundCodeLabelBatch",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RetrySoundCodeLabelBatchResponse({}));
    }
    async retrySoundCodeLabelBatch(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.retrySoundCodeLabelBatchWithOptions(request, runtime);
    }
    /**
      * If the update task requires confirmation, you must make sure that it has been confirmed before you call this operation. You can call the [ConfirmOTATask](~~254666~~) operation to confirm update tasks.
      * ## QPS limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ReupgradeOTATaskRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ReupgradeOTATaskResponse
     */
    async reupgradeOTATaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ReupgradeOTATask",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ReupgradeOTATaskResponse({}));
    }
    /**
      * If the update task requires confirmation, you must make sure that it has been confirmed before you call this operation. You can call the [ConfirmOTATask](~~254666~~) operation to confirm update tasks.
      * ## QPS limits
      * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request ReupgradeOTATaskRequest
      * @return ReupgradeOTATaskResponse
     */
    async reupgradeOTATask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.reupgradeOTATaskWithOptions(request, runtime);
    }
    /**
      * *   A device can have a maximum of 100 tags.
      * *   You can modify or add a maximum of 100 tags at a time.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request SaveDevicePropRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return SaveDevicePropResponse
     */
    async saveDevicePropWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.props)) {
            query["Props"] = request.props;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SaveDeviceProp",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SaveDevicePropResponse({}));
    }
    /**
      * *   A device can have a maximum of 100 tags.
      * *   You can modify or add a maximum of 100 tags at a time.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request SaveDevicePropRequest
      * @return SaveDevicePropResponse
     */
    async saveDeviceProp(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.saveDevicePropWithOptions(request, runtime);
    }
    async saveScriptWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        if (!tea_util_1.default.isUnset(request.scriptDraft)) {
            query["ScriptDraft"] = request.scriptDraft;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SaveScript",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SaveScriptResponse({}));
    }
    async saveScript(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.saveScriptWithOptions(request, runtime);
    }
    /**
      * *   You cannot query the desired values of read-only properties.
      * *   You can specify up to 10 desired property values in a call.
      * *   After a device is created, the value of the **Version** parameter is 0. If you want to configure the **Version** parameter the first time you specify a desired property value, set the **Version** parameter to 0.
      * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request SetDeviceDesiredPropertyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return SetDeviceDesiredPropertyResponse
     */
    async setDeviceDesiredPropertyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.items)) {
            query["Items"] = request.items;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.versions)) {
            query["Versions"] = request.versions;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetDeviceDesiredProperty",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetDeviceDesiredPropertyResponse({}));
    }
    /**
      * *   You cannot query the desired values of read-only properties.
      * *   You can specify up to 10 desired property values in a call.
      * *   After a device is created, the value of the **Version** parameter is 0. If you want to configure the **Version** parameter the first time you specify a desired property value, set the **Version** parameter to 0.
      * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request SetDeviceDesiredPropertyRequest
      * @return SetDeviceDesiredPropertyResponse
     */
    async setDeviceDesiredProperty(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setDeviceDesiredPropertyWithOptions(request, runtime);
    }
    /**
      * A device group can have a maximum of 100 tags.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request SetDeviceGroupTagsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return SetDeviceGroupTagsResponse
     */
    async setDeviceGroupTagsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.groupType)) {
            query["GroupType"] = request.groupType;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.tagString)) {
            query["TagString"] = request.tagString;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetDeviceGroupTags",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetDeviceGroupTagsResponse({}));
    }
    /**
      * A device group can have a maximum of 100 tags.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request SetDeviceGroupTagsRequest
      * @return SetDeviceGroupTagsResponse
     */
    async setDeviceGroupTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setDeviceGroupTagsWithOptions(request, runtime);
    }
    /**
      * After IoT Platform sends a request to configure device properties, the device receives and processes the request in an asynchronous manner. When you call this operation, a successful response indicates that IoT Platform sent a request. The response does not indicate that the device received and processed the request. After the device SDK responds to the request, the device properties are configured.
      * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request SetDevicePropertyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return SetDevicePropertyResponse
     */
    async setDevicePropertyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.items)) {
            query["Items"] = request.items;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetDeviceProperty",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetDevicePropertyResponse({}));
    }
    /**
      * After IoT Platform sends a request to configure device properties, the device receives and processes the request in an asynchronous manner. When you call this operation, a successful response indicates that IoT Platform sent a request. The response does not indicate that the device received and processed the request. After the device SDK responds to the request, the device properties are configured.
      * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request SetDevicePropertyRequest
      * @return SetDevicePropertyResponse
     */
    async setDeviceProperty(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setDevicePropertyWithOptions(request, runtime);
    }
    /**
      * If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request SetDevicesPropertyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return SetDevicesPropertyResponse
     */
    async setDevicesPropertyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.items)) {
            query["Items"] = request.items;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetDevicesProperty",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetDevicesPropertyResponse({}));
    }
    /**
      * If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request SetDevicesPropertyRequest
      * @return SetDevicesPropertyResponse
     */
    async setDevicesProperty(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setDevicesPropertyWithOptions(request, runtime);
    }
    async setEdgeInstanceDriverConfigsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.configs)) {
            query["Configs"] = request.configs;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetEdgeInstanceDriverConfigs",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetEdgeInstanceDriverConfigsResponse({}));
    }
    async setEdgeInstanceDriverConfigs(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setEdgeInstanceDriverConfigsWithOptions(request, runtime);
    }
    async setProductCertInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.issueModel)) {
            query["IssueModel"] = request.issueModel;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetProductCertInfo",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetProductCertInfoResponse({}));
    }
    async setProductCertInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setProductCertInfoWithOptions(request, runtime);
    }
    async setStudioProjectCooperationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["Status"] = request.status;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SetStudioProjectCooperation",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetStudioProjectCooperationResponse({}));
    }
    async setStudioProjectCooperation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setStudioProjectCooperationWithOptions(request, runtime);
    }
    async setupStudioAppAuthModeOpenWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["AppId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.authMode)) {
            body["AuthMode"] = request.authMode;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["ProjectId"] = request.projectId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SetupStudioAppAuthModeOpen",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetupStudioAppAuthModeOpenResponse({}));
    }
    async setupStudioAppAuthModeOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setupStudioAppAuthModeOpenWithOptions(request, runtime);
    }
    async shareSpeechByCombinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.audioFormat)) {
            body["AudioFormat"] = request.audioFormat;
        }
        if (!tea_util_1.default.isUnset(request.combinationList)) {
            body["CombinationList"] = request.combinationList;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.speechId)) {
            body["SpeechId"] = request.speechId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ShareSpeechByCombination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ShareSpeechByCombinationResponse({}));
    }
    async shareSpeechByCombination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.shareSpeechByCombinationWithOptions(request, runtime);
    }
    async speechByCombinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.audioFormat)) {
            body["AudioFormat"] = request.audioFormat;
        }
        if (!tea_util_1.default.isUnset(request.combinationList)) {
            body["CombinationList"] = request.combinationList;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.enforceFlag)) {
            body["EnforceFlag"] = request.enforceFlag;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.speechId)) {
            body["SpeechId"] = request.speechId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SpeechByCombination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SpeechByCombinationResponse({}));
    }
    async speechByCombination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.speechByCombinationWithOptions(request, runtime);
    }
    async speechBySynthesisWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.audioFormat)) {
            body["AudioFormat"] = request.audioFormat;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.speechId)) {
            body["SpeechId"] = request.speechId;
        }
        if (!tea_util_1.default.isUnset(request.speechRate)) {
            body["SpeechRate"] = request.speechRate;
        }
        if (!tea_util_1.default.isUnset(request.text)) {
            body["Text"] = request.text;
        }
        if (!tea_util_1.default.isUnset(request.voice)) {
            body["Voice"] = request.voice;
        }
        if (!tea_util_1.default.isUnset(request.volume)) {
            body["Volume"] = request.volume;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SpeechBySynthesis",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SpeechBySynthesisResponse({}));
    }
    async speechBySynthesis(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.speechBySynthesisWithOptions(request, runtime);
    }
    async startParserWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "StartParser",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new StartParserResponse({}));
    }
    async startParser(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.startParserWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You must verify that the rule has SQL statements configured before you start the rule. If you do not set an SQL statement when you create the rule, call the [UpdateRule](~~69513~~) operation to add an SQL statement and update the rule.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request StartRuleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return StartRuleResponse
     */
    async startRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "StartRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new StartRuleResponse({}));
    }
    /**
      * ## Limits
      * *   You must verify that the rule has SQL statements configured before you start the rule. If you do not set an SQL statement when you create the rule, call the [UpdateRule](~~69513~~) operation to add an SQL statement and update the rule.
      * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request StartRuleRequest
      * @return StartRuleResponse
     */
    async startRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.startRuleWithOptions(request, runtime);
    }
    async stopParserWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "StopParser",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new StopParserResponse({}));
    }
    async stopParser(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.stopParserWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request StopRuleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return StopRuleResponse
     */
    async stopRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "StopRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new StopRuleResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request StopRuleRequest
      * @return StopRuleResponse
     */
    async stopRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.stopRuleWithOptions(request, runtime);
    }
    /**
      * *   The device that needs to subscribe to topics must be connected to IoT Platform and online.
      * *   You can call this operation to subscribe to the topics of a specified device. You can specify a maximum of 10 topics in a single call.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request SubscribeTopicRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return SubscribeTopicResponse
     */
    async subscribeTopicWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.topic)) {
            query["Topic"] = request.topic;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SubscribeTopic",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SubscribeTopicResponse({}));
    }
    /**
      * *   The device that needs to subscribe to topics must be connected to IoT Platform and online.
      * *   You can call this operation to subscribe to the topics of a specified device. You can specify a maximum of 10 topics in a single call.
      * ## QPS limits
      * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
      * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
      *
      * @param request SubscribeTopicRequest
      * @return SubscribeTopicResponse
     */
    async subscribeTopic(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.subscribeTopicWithOptions(request, runtime);
    }
    async syncSpeechByCombinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.audioFormat)) {
            body["AudioFormat"] = request.audioFormat;
        }
        if (!tea_util_1.default.isUnset(request.combinationList)) {
            body["CombinationList"] = request.combinationList;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            body["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.enforceFlag)) {
            body["EnforceFlag"] = request.enforceFlag;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            body["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            body["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.speechId)) {
            body["SpeechId"] = request.speechId;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SyncSpeechByCombination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SyncSpeechByCombinationResponse({}));
    }
    async syncSpeechByCombination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.syncSpeechByCombinationWithOptions(request, runtime);
    }
    async testSpeechWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new TestSpeechShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.soundCodeConfig)) {
            request.soundCodeConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.soundCodeConfig, "SoundCodeConfig", "json");
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.audioFormat)) {
            body["AudioFormat"] = request.audioFormat;
        }
        if (!tea_util_1.default.isUnset(request.enableSoundCode)) {
            body["EnableSoundCode"] = request.enableSoundCode;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectCode)) {
            body["ProjectCode"] = request.projectCode;
        }
        if (!tea_util_1.default.isUnset(request.soundCodeConfigShrink)) {
            body["SoundCodeConfig"] = request.soundCodeConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.speechRate)) {
            body["SpeechRate"] = request.speechRate;
        }
        if (!tea_util_1.default.isUnset(request.speechType)) {
            body["SpeechType"] = request.speechType;
        }
        if (!tea_util_1.default.isUnset(request.text)) {
            body["Text"] = request.text;
        }
        if (!tea_util_1.default.isUnset(request.voice)) {
            body["Voice"] = request.voice;
        }
        if (!tea_util_1.default.isUnset(request.volume)) {
            body["Volume"] = request.volume;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TestSpeech",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TestSpeechResponse({}));
    }
    async testSpeech(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.testSpeechWithOptions(request, runtime);
    }
    async testSwitchWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "TestSwitch",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TestSwitchResponse({}));
    }
    async testSwitch(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.testSwitchWithOptions(request, runtime);
    }
    /**
      * You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request TransformClientIdRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return TransformClientIdResponse
     */
    async transformClientIdWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientId)) {
            query["ClientId"] = request.clientId;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "TransformClientId",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TransformClientIdResponse({}));
    }
    /**
      * You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request TransformClientIdRequest
      * @return TransformClientIdResponse
     */
    async transformClientId(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.transformClientIdWithOptions(request, runtime);
    }
    async triggerSceneRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "TriggerSceneRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TriggerSceneRuleResponse({}));
    }
    async triggerSceneRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.triggerSceneRuleWithOptions(request, runtime);
    }
    async unbindApplicationFromEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.applicationId)) {
            query["ApplicationId"] = request.applicationId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UnbindApplicationFromEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UnbindApplicationFromEdgeInstanceResponse({}));
    }
    async unbindApplicationFromEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.unbindApplicationFromEdgeInstanceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UnbindDriverFromEdgeInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UnbindDriverFromEdgeInstanceResponse
     */
    async unbindDriverFromEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UnbindDriverFromEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UnbindDriverFromEdgeInstanceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UnbindDriverFromEdgeInstanceRequest
      * @return UnbindDriverFromEdgeInstanceResponse
     */
    async unbindDriverFromEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.unbindDriverFromEdgeInstanceWithOptions(request, runtime);
    }
    async unbindLicenseProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.licenseCode)) {
            query["LicenseCode"] = request.licenseCode;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UnbindLicenseProduct",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UnbindLicenseProductResponse({}));
    }
    async unbindLicenseProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.unbindLicenseProductWithOptions(request, runtime);
    }
    async unbindRoleFromEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UnbindRoleFromEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UnbindRoleFromEdgeInstanceResponse({}));
    }
    async unbindRoleFromEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.unbindRoleFromEdgeInstanceWithOptions(request, runtime);
    }
    async unbindSceneRuleFromEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UnbindSceneRuleFromEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UnbindSceneRuleFromEdgeInstanceResponse({}));
    }
    async unbindSceneRuleFromEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.unbindSceneRuleFromEdgeInstanceWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   You cannot modify the default consumer group provided by IoT Platform.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateConsumerGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateConsumerGroupResponse
     */
    async updateConsumerGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.newGroupName)) {
            query["NewGroupName"] = request.newGroupName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateConsumerGroup",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateConsumerGroupResponse({}));
    }
    /**
      * ## Limits
      * *   You cannot modify the default consumer group provided by IoT Platform.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateConsumerGroupRequest
      * @return UpdateConsumerGroupResponse
     */
    async updateConsumerGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateConsumerGroupWithOptions(request, runtime);
    }
    async updateDestinationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.configuration)) {
            query["Configuration"] = request.configuration;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.destinationId)) {
            query["DestinationId"] = request.destinationId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateDestination",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateDestinationResponse({}));
    }
    async updateDestination(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateDestinationWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateDeviceGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateDeviceGroupResponse
     */
    async updateDeviceGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.groupDesc)) {
            query["GroupDesc"] = request.groupDesc;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            query["GroupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.groupType)) {
            query["GroupType"] = request.groupType;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateDeviceGroup",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateDeviceGroupResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateDeviceGroupRequest
      * @return UpdateDeviceGroupResponse
     */
    async updateDeviceGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateDeviceGroupWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * You can call this API operation up to 500 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateDeviceShadowRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateDeviceShadowResponse
     */
    async updateDeviceShadowWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deltaUpdate)) {
            query["DeltaUpdate"] = request.deltaUpdate;
        }
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.shadowMessage)) {
            query["ShadowMessage"] = request.shadowMessage;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateDeviceShadow",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateDeviceShadowResponse({}));
    }
    /**
      * ## QPS limits
      * You can call this API operation up to 500 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateDeviceShadowRequest
      * @return UpdateDeviceShadowResponse
     */
    async updateDeviceShadow(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateDeviceShadowWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   If a request parameter is not specified, the original value of the parameter will be cleared for the driver version.
      * *   You are not allowed to update a published driver version.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateEdgeDriverVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateEdgeDriverVersionResponse
     */
    async updateEdgeDriverVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.argument)) {
            query["Argument"] = request.argument;
        }
        if (!tea_util_1.default.isUnset(request.configCheckRule)) {
            query["ConfigCheckRule"] = request.configCheckRule;
        }
        if (!tea_util_1.default.isUnset(request.containerConfig)) {
            query["ContainerConfig"] = request.containerConfig;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.driverConfig)) {
            query["DriverConfig"] = request.driverConfig;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.driverVersion)) {
            query["DriverVersion"] = request.driverVersion;
        }
        if (!tea_util_1.default.isUnset(request.edgeVersion)) {
            query["EdgeVersion"] = request.edgeVersion;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.sourceConfig)) {
            query["SourceConfig"] = request.sourceConfig;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateEdgeDriverVersion",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateEdgeDriverVersionResponse({}));
    }
    /**
      * ## Limits
      * *   If a request parameter is not specified, the original value of the parameter will be cleared for the driver version.
      * *   You are not allowed to update a published driver version.
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateEdgeDriverVersionRequest
      * @return UpdateEdgeDriverVersionResponse
     */
    async updateEdgeDriverVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateEdgeDriverVersionWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateEdgeInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateEdgeInstanceResponse
     */
    async updateEdgeInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizEnable)) {
            query["BizEnable"] = request.bizEnable;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.spec)) {
            query["Spec"] = request.spec;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            query["Tags"] = request.tags;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateEdgeInstance",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateEdgeInstanceResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateEdgeInstanceRequest
      * @return UpdateEdgeInstanceResponse
     */
    async updateEdgeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateEdgeInstanceWithOptions(request, runtime);
    }
    async updateEdgeInstanceChannelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.channelId)) {
            query["ChannelId"] = request.channelId;
        }
        if (!tea_util_1.default.isUnset(request.channelName)) {
            query["ChannelName"] = request.channelName;
        }
        if (!tea_util_1.default.isUnset(request.configs)) {
            query["Configs"] = request.configs;
        }
        if (!tea_util_1.default.isUnset(request.driverId)) {
            query["DriverId"] = request.driverId;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateEdgeInstanceChannel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateEdgeInstanceChannelResponse({}));
    }
    async updateEdgeInstanceChannel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateEdgeInstanceChannelWithOptions(request, runtime);
    }
    async updateEdgeInstanceMessageRoutingWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.routeId)) {
            query["RouteId"] = request.routeId;
        }
        if (!tea_util_1.default.isUnset(request.sourceData)) {
            query["SourceData"] = request.sourceData;
        }
        if (!tea_util_1.default.isUnset(request.sourceType)) {
            query["SourceType"] = request.sourceType;
        }
        if (!tea_util_1.default.isUnset(request.targetData)) {
            query["TargetData"] = request.targetData;
        }
        if (!tea_util_1.default.isUnset(request.targetIotHubQos)) {
            query["TargetIotHubQos"] = request.targetIotHubQos;
        }
        if (!tea_util_1.default.isUnset(request.targetType)) {
            query["TargetType"] = request.targetType;
        }
        if (!tea_util_1.default.isUnset(request.topicFilter)) {
            query["TopicFilter"] = request.topicFilter;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateEdgeInstanceMessageRouting",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateEdgeInstanceMessageRoutingResponse({}));
    }
    async updateEdgeInstanceMessageRouting(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateEdgeInstanceMessageRoutingWithOptions(request, runtime);
    }
    async updateJobWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new UpdateJobShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.rolloutConfig)) {
            request.rolloutConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.rolloutConfig, "RolloutConfig", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.timeoutConfig)) {
            request.timeoutConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.timeoutConfig, "TimeoutConfig", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        if (!tea_util_1.default.isUnset(request.rolloutConfigShrink)) {
            query["RolloutConfig"] = request.rolloutConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.timeoutConfigShrink)) {
            query["TimeoutConfig"] = request.timeoutConfigShrink;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateJob",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateJobResponse({}));
    }
    async updateJob(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateJobWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateOTAModuleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateOTAModuleResponse
     */
    async updateOTAModuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.aliasName)) {
            query["AliasName"] = request.aliasName;
        }
        if (!tea_util_1.default.isUnset(request.desc)) {
            query["Desc"] = request.desc;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.moduleName)) {
            query["ModuleName"] = request.moduleName;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateOTAModule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateOTAModuleResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateOTAModuleRequest
      * @return UpdateOTAModuleResponse
     */
    async updateOTAModule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateOTAModuleWithOptions(request, runtime);
    }
    async updateParserWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.parserId)) {
            query["ParserId"] = request.parserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateParser",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateParserResponse({}));
    }
    async updateParser(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateParserWithOptions(request, runtime);
    }
    async updateParserDataSourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dataSourceId)) {
            query["DataSourceId"] = request.dataSourceId;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateParserDataSource",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateParserDataSourceResponse({}));
    }
    async updateParserDataSource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateParserDataSourceWithOptions(request, runtime);
    }
    /**
      * ## QPS limits
      * You can call this API operation up to 10 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateProductRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateProductResponse
     */
    async updateProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.productName)) {
            query["ProductName"] = request.productName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateProduct",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateProductResponse({}));
    }
    /**
      * ## QPS limits
      * You can call this API operation up to 10 times per second per account.
      * >  The RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateProductRequest
      * @return UpdateProductResponse
     */
    async updateProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateProductWithOptions(request, runtime);
    }
    /**
      * ## Message deduplication rules
      * Based on the rules that you set, IoT Platform determines whether to use the rules engine or server-side subscriptions to forward property data that is submitted by devices to a specified destination.
      * The triggering conditions of rules are related by the logic AND relation. For example, if you set the PropertyValueFilter=true and PropertyTimestampFilter=true conditions, the rule to remove duplicate messages is triggered only when both of the conditions are met.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateProductFilterConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateProductFilterConfigResponse
     */
    async updateProductFilterConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.propertyTimestampFilter)) {
            query["PropertyTimestampFilter"] = request.propertyTimestampFilter;
        }
        if (!tea_util_1.default.isUnset(request.propertyValueFilter)) {
            query["PropertyValueFilter"] = request.propertyValueFilter;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateProductFilterConfig",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateProductFilterConfigResponse({}));
    }
    /**
      * ## Message deduplication rules
      * Based on the rules that you set, IoT Platform determines whether to use the rules engine or server-side subscriptions to forward property data that is submitted by devices to a specified destination.
      * The triggering conditions of rules are related by the logic AND relation. For example, if you set the PropertyValueFilter=true and PropertyTimestampFilter=true conditions, the rule to remove duplicate messages is triggered only when both of the conditions are met.
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateProductFilterConfigRequest
      * @return UpdateProductFilterConfigResponse
     */
    async updateProductFilterConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateProductFilterConfigWithOptions(request, runtime);
    }
    /**
      * You can update a maximum of 10 tags in a single call.
      * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
      * ## QPS limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateProductTagsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateProductTagsResponse
     */
    async updateProductTagsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.productTag)) {
            query["ProductTag"] = request.productTag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateProductTags",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateProductTagsResponse({}));
    }
    /**
      * You can update a maximum of 10 tags in a single call.
      * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
      * ## QPS limits
      * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
      * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateProductTagsRequest
      * @return UpdateProductTagsResponse
     */
    async updateProductTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateProductTagsWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateProductTopicRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateProductTopicResponse
     */
    async updateProductTopicWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.codec)) {
            query["Codec"] = request.codec;
        }
        if (!tea_util_1.default.isUnset(request.desc)) {
            query["Desc"] = request.desc;
        }
        if (!tea_util_1.default.isUnset(request.enableProxySubscribe)) {
            query["EnableProxySubscribe"] = request.enableProxySubscribe;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.operation)) {
            query["Operation"] = request.operation;
        }
        if (!tea_util_1.default.isUnset(request.topicId)) {
            query["TopicId"] = request.topicId;
        }
        if (!tea_util_1.default.isUnset(request.topicShortName)) {
            query["TopicShortName"] = request.topicShortName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateProductTopic",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateProductTopicResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateProductTopicRequest
      * @return UpdateProductTopicResponse
     */
    async updateProductTopic(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateProductTopicWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateRuleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateRuleResponse
     */
    async updateRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.ruleDesc)) {
            query["RuleDesc"] = request.ruleDesc;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        if (!tea_util_1.default.isUnset(request.select)) {
            query["Select"] = request.select;
        }
        if (!tea_util_1.default.isUnset(request.shortTopic)) {
            query["ShortTopic"] = request.shortTopic;
        }
        if (!tea_util_1.default.isUnset(request.topic)) {
            query["Topic"] = request.topic;
        }
        if (!tea_util_1.default.isUnset(request.topicType)) {
            query["TopicType"] = request.topicType;
        }
        if (!tea_util_1.default.isUnset(request.where)) {
            query["Where"] = request.where;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateRuleResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateRuleRequest
      * @return UpdateRuleResponse
     */
    async updateRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateRuleWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateRuleActionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateRuleActionResponse
     */
    async updateRuleActionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.actionId)) {
            query["ActionId"] = request.actionId;
        }
        if (!tea_util_1.default.isUnset(request.configuration)) {
            query["Configuration"] = request.configuration;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateRuleAction",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateRuleActionResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateRuleActionRequest
      * @return UpdateRuleActionResponse
     */
    async updateRuleAction(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateRuleActionWithOptions(request, runtime);
    }
    async updateSceneRuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ruleContent)) {
            query["RuleContent"] = request.ruleContent;
        }
        if (!tea_util_1.default.isUnset(request.ruleDescription)) {
            query["RuleDescription"] = request.ruleDescription;
        }
        if (!tea_util_1.default.isUnset(request.ruleId)) {
            query["RuleId"] = request.ruleId;
        }
        if (!tea_util_1.default.isUnset(request.ruleName)) {
            query["RuleName"] = request.ruleName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateSceneRule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateSceneRuleResponse({}));
    }
    async updateSceneRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateSceneRuleWithOptions(request, runtime);
    }
    async updateSchedulePeriodWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.periodCode)) {
            body["PeriodCode"] = request.periodCode;
        }
        if (!tea_util_1.default.isUnset(request.soundCodeContent)) {
            body["SoundCodeContent"] = request.soundCodeContent;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateSchedulePeriod",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateSchedulePeriodResponse({}));
    }
    async updateSchedulePeriod(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateSchedulePeriodWithOptions(request, runtime);
    }
    async updateSoundCodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.duration)) {
            body["Duration"] = request.duration;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.soundCode)) {
            body["SoundCode"] = request.soundCode;
        }
        if (!tea_util_1.default.isUnset(request.soundCodeContent)) {
            body["SoundCodeContent"] = request.soundCodeContent;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateSoundCode",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateSoundCodeResponse({}));
    }
    async updateSoundCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateSoundCodeWithOptions(request, runtime);
    }
    async updateSoundCodeLabelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.label)) {
            body["Label"] = request.label;
        }
        if (!tea_util_1.default.isUnset(request.soundCode)) {
            body["SoundCode"] = request.soundCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateSoundCodeLabel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateSoundCodeLabelResponse({}));
    }
    async updateSoundCodeLabel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateSoundCodeLabelWithOptions(request, runtime);
    }
    async updateSoundCodeScheduleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.endDate)) {
            body["EndDate"] = request.endDate;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.scheduleCode)) {
            body["ScheduleCode"] = request.scheduleCode;
        }
        if (!tea_util_1.default.isUnset(request.startDate)) {
            body["StartDate"] = request.startDate;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["StartTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["Status"] = request.status;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateSoundCodeSchedule",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateSoundCodeScheduleResponse({}));
    }
    async updateSoundCodeSchedule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateSoundCodeScheduleWithOptions(request, runtime);
    }
    async updateSpeechWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new UpdateSpeechShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.soundCodeConfig)) {
            request.soundCodeConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.soundCodeConfig, "SoundCodeConfig", "json");
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.enableSoundCode)) {
            body["EnableSoundCode"] = request.enableSoundCode;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            body["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.projectCode)) {
            body["ProjectCode"] = request.projectCode;
        }
        if (!tea_util_1.default.isUnset(request.soundCodeConfigShrink)) {
            body["SoundCodeConfig"] = request.soundCodeConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.speechCode)) {
            body["SpeechCode"] = request.speechCode;
        }
        if (!tea_util_1.default.isUnset(request.speechRate)) {
            body["SpeechRate"] = request.speechRate;
        }
        if (!tea_util_1.default.isUnset(request.voice)) {
            body["Voice"] = request.voice;
        }
        if (!tea_util_1.default.isUnset(request.volume)) {
            body["Volume"] = request.volume;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateSpeech",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateSpeechResponse({}));
    }
    async updateSpeech(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateSpeechWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateSubscribeRelationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateSubscribeRelationResponse
     */
    async updateSubscribeRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.consumerGroupIds)) {
            query["ConsumerGroupIds"] = request.consumerGroupIds;
        }
        if (!tea_util_1.default.isUnset(request.deviceDataFlag)) {
            query["DeviceDataFlag"] = request.deviceDataFlag;
        }
        if (!tea_util_1.default.isUnset(request.deviceLifeCycleFlag)) {
            query["DeviceLifeCycleFlag"] = request.deviceLifeCycleFlag;
        }
        if (!tea_util_1.default.isUnset(request.deviceStatusChangeFlag)) {
            query["DeviceStatusChangeFlag"] = request.deviceStatusChangeFlag;
        }
        if (!tea_util_1.default.isUnset(request.deviceTagFlag)) {
            query["DeviceTagFlag"] = request.deviceTagFlag;
        }
        if (!tea_util_1.default.isUnset(request.deviceTopoLifeCycleFlag)) {
            query["DeviceTopoLifeCycleFlag"] = request.deviceTopoLifeCycleFlag;
        }
        if (!tea_util_1.default.isUnset(request.foundDeviceListFlag)) {
            query["FoundDeviceListFlag"] = request.foundDeviceListFlag;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.mnsConfiguration)) {
            query["MnsConfiguration"] = request.mnsConfiguration;
        }
        if (!tea_util_1.default.isUnset(request.otaEventFlag)) {
            query["OtaEventFlag"] = request.otaEventFlag;
        }
        if (!tea_util_1.default.isUnset(request.otaJobFlag)) {
            query["OtaJobFlag"] = request.otaJobFlag;
        }
        if (!tea_util_1.default.isUnset(request.otaVersionFlag)) {
            query["OtaVersionFlag"] = request.otaVersionFlag;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.subscribeFlags)) {
            query["SubscribeFlags"] = request.subscribeFlags;
        }
        if (!tea_util_1.default.isUnset(request.thingHistoryFlag)) {
            query["ThingHistoryFlag"] = request.thingHistoryFlag;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateSubscribeRelation",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateSubscribeRelationResponse({}));
    }
    /**
      * ## Limits
      * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * >  RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateSubscribeRelationRequest
      * @return UpdateSubscribeRelationResponse
     */
    async updateSubscribeRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateSubscribeRelationWithOptions(request, runtime);
    }
    /**
      * ## Limits
      * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
      * *   When you call this operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
      * *   You can call this operation to update only one feature. TSL features include properties, services, and events.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateThingModelRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateThingModelResponse
     */
    async updateThingModelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.functionBlockId)) {
            query["FunctionBlockId"] = request.functionBlockId;
        }
        if (!tea_util_1.default.isUnset(request.functionBlockName)) {
            query["FunctionBlockName"] = request.functionBlockName;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            query["Identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.thingModelJson)) {
            query["ThingModelJson"] = request.thingModelJson;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateThingModel",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateThingModelResponse({}));
    }
    /**
      * ## Limits
      * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
      * *   When you call this operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
      * *   You can call this operation to update only one feature. TSL features include properties, services, and events.
      * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateThingModelRequest
      * @return UpdateThingModelResponse
     */
    async updateThingModel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateThingModelWithOptions(request, runtime);
    }
    /**
      * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateThingScriptRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateThingScriptResponse
     */
    async updateThingScriptWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.scriptContent)) {
            query["ScriptContent"] = request.scriptContent;
        }
        if (!tea_util_1.default.isUnset(request.scriptType)) {
            query["ScriptType"] = request.scriptType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateThingScript",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateThingScriptResponse({}));
    }
    /**
      * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
      * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
      * > RAM users of an Alibaba Cloud account share the quota of the account.
      *
      * @param request UpdateThingScriptRequest
      * @return UpdateThingScriptResponse
     */
    async updateThingScript(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateThingScriptWithOptions(request, runtime);
    }
    async updateTopicConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.codec)) {
            query["Codec"] = request.codec;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.enableBroadcast)) {
            query["EnableBroadcast"] = request.enableBroadcast;
        }
        if (!tea_util_1.default.isUnset(request.enableProxySubscribe)) {
            query["EnableProxySubscribe"] = request.enableProxySubscribe;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.operation)) {
            query["Operation"] = request.operation;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.topicFullName)) {
            query["TopicFullName"] = request.topicFullName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateTopicConfig",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateTopicConfigResponse({}));
    }
    async updateTopicConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateTopicConfigWithOptions(request, runtime);
    }
    async writeDevicesHotStorageDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deviceName)) {
            query["DeviceName"] = request.deviceName;
        }
        if (!tea_util_1.default.isUnset(request.iotId)) {
            query["IotId"] = request.iotId;
        }
        if (!tea_util_1.default.isUnset(request.iotInstanceId)) {
            query["IotInstanceId"] = request.iotInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.items)) {
            query["Items"] = request.items;
        }
        if (!tea_util_1.default.isUnset(request.productKey)) {
            query["ProductKey"] = request.productKey;
        }
        if (!tea_util_1.default.isUnset(request.userTopic)) {
            query["UserTopic"] = request.userTopic;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "WriteDevicesHotStorageData",
            version: "2018-01-20",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new WriteDevicesHotStorageDataResponse({}));
    }
    async writeDevicesHotStorageData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.writeDevicesHotStorageDataWithOptions(request, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map